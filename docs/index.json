{
  "api/index.html": {
    "href": "api/index.html",
    "title": "PLACEHOLDER | TimeSeriesAnalysis reference documentation",
    "keywords": "PLACEHOLDER TODO: Add .NET projects to the src folder and run docfx to generate REAL API Documentation !"
  },
  "api/TimeSeriesAnalysis.Array2D.html": {
    "href": "api/TimeSeriesAnalysis.Array2D.html",
    "title": "Class Array2D | TimeSeriesAnalysis reference documentation",
    "keywords": "Class Array2D Non-generic 2D-array methods Inheritance System.Object Array2D Inherited Members System.Object.ToString() System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.ReferenceEquals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() Namespace : TimeSeriesAnalysis Assembly : TimeSeriesAnalysis.dll Syntax public static class Array2D Methods GetColumnParsedAsDateTime(String[,], Int32, String) Parses a column of strings in an array/matrix of strings Declaration public static DateTime[] GetColumnParsedAsDateTime(this string[, ] matrix, int columnNumber, string dateFormat) Parameters Type Name Description System.String [,] matrix a 2D-aray of strings System.Int32 columnNumber the index of the column to parse System.String dateFormat the DateTime dateformat,For the format of dateFormat, see https://docs.microsoft.com/en-us/dotnet/standard/base-types/custom-date-and-time-format-strings Returns Type Description System.DateTime []"
  },
  "api/TimeSeriesAnalysis.Array2D-1.html": {
    "href": "api/TimeSeriesAnalysis.Array2D-1.html",
    "title": "Class Array2D<T> | TimeSeriesAnalysis reference documentation",
    "keywords": "Class Array2D<T> Generic array operations that can be done on arrays of any type, for operators specific to numerical arrays(matrices) see Matrix.cs Inheritance System.Object Array2D<T> Inherited Members System.Object.ToString() System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.ReferenceEquals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() Namespace : TimeSeriesAnalysis Assembly : TimeSeriesAnalysis.dll Syntax public class Array2D<T> Type Parameters Name Description T Methods Convert2DtoJagged(T[,]) converts a 2d array into a jagged array Declaration public static T[][] Convert2DtoJagged(T[, ] matrix) Parameters Type Name Description T[,] matrix Returns Type Description T[][] GetColumn(T[,], Int32) returns the column of the matrix with the given index Declaration public static T[] GetColumn(T[, ] matrix, int columnNumber) Parameters Type Name Description T[,] matrix System.Int32 columnNumber Returns Type Description T[] GetColumns(T[,], Int32[]) returns all the columns correspoding to columnNumbers in a 2d-array Declaration public static T[, ] GetColumns(T[, ] matrix, int[] columnNumbers) Parameters Type Name Description T[,] matrix System.Int32 [] columnNumbers Returns Type Description T[,] GetRow(T[,], Int32) returns the row of the matrix with the given index as an vector Declaration public static T[] GetRow(T[, ] matrix, int rowNumber) Parameters Type Name Description T[,] matrix System.Int32 rowNumber Returns Type Description T[] InitFromColumnList(List<T[]>) Initializes a 2D array from a list of arrays representing each column in the array Declaration public static T[, ] InitFromColumnList(List<T[]> columnList) Parameters Type Name Description System.Collections.Generic.List <T[]> columnList Returns Type Description T[,] null if list columnList dimensions do not match Transpose(T[,]) transposes a 2d-array (rows are turned into columns and vice versa) Declaration public static T[, ] Transpose(T[, ] matrix) Parameters Type Name Description T[,] matrix Returns Type Description T[,]"
  },
  "api/TimeSeriesAnalysis.Array2DExtensionMethods.html": {
    "href": "api/TimeSeriesAnalysis.Array2DExtensionMethods.html",
    "title": "Class Array2DExtensionMethods | TimeSeriesAnalysis reference documentation",
    "keywords": "Class Array2DExtensionMethods Extension methods based on Array2D Inheritance System.Object Array2DExtensionMethods Inherited Members System.Object.ToString() System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.ReferenceEquals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() Namespace : TimeSeriesAnalysis Assembly : TimeSeriesAnalysis.dll Syntax public static class Array2DExtensionMethods Methods Convert2DtoJagged(Double[,]) Converts a 2d-array to a jagged array Declaration public static double[][] Convert2DtoJagged(this double[, ] matrix) Parameters Type Name Description System.Double [,] matrix Returns Type Description System.Double [][] GetColumn(Double[,], Int32) returns the column of a 2d-array of doubles corresponding to columnIndex(starts at zero) Declaration public static double[] GetColumn(this double[, ] matrix, int columnIndex) Parameters Type Name Description System.Double [,] matrix System.Int32 columnIndex Returns Type Description System.Double [] GetColumn(String[,], Int32) returns the column of a 2d-array of strings corresponding to columnIndex(starts at zero) Declaration public static string[] GetColumn(this string[, ] matrix, int columnIndex) Parameters Type Name Description System.String [,] matrix System.Int32 columnIndex Returns Type Description System.String [] GetColumnParsedAsDateTime(String[,], Int32, String) Parses a column in a 2d-array and returns the results as a vector of date-times. Declaration public static DateTime[] GetColumnParsedAsDateTime(this string[, ] matrix, int columnNumber, string dateFormat) Parameters Type Name Description System.String [,] matrix System.Int32 columnNumber System.String dateFormat Returns Type Description System.DateTime [] GetColumns(Double[,], Int32[]) Returns the columns corresponding to columnNumbers as a 2d-array Declaration public static double[, ] GetColumns(this double[, ] matrix, int[] columnNumbers) Parameters Type Name Description System.Double [,] matrix System.Int32 [] columnNumbers Returns Type Description System.Double [,] GetNColumns(Double[,]) Return the number of columns of a 2d-matrix Declaration public static int GetNColumns(this double[, ] matrix) Parameters Type Name Description System.Double [,] matrix Returns Type Description System.Int32 GetNRows(Double[,]) Return the number of rows of a 2d-matrix Declaration public static int GetNRows(this double[, ] matrix) Parameters Type Name Description System.Double [,] matrix Returns Type Description System.Int32 GetRow(Double[,], Int32) returns the row of a 2d-array of doubles corresponding to columnIndex(starts at zero) Declaration public static double[] GetRow(this double[, ] matrix, int rowNumber) Parameters Type Name Description System.Double [,] matrix System.Int32 rowNumber Returns Type Description System.Double [] GetRow(String[,], Int32) returns the row of a 2d-array of strings corresponding to columnIndex(starts at zero) Declaration public static string[] GetRow(this string[, ] matrix, int rowNumber) Parameters Type Name Description System.String [,] matrix System.Int32 rowNumber Returns Type Description System.String [] GetRowsAfterIndex(DateTime[], Int32) Returns rows starting with rowIndex and onwards Declaration public static DateTime[] GetRowsAfterIndex(this DateTime[] array, int rowIndex) Parameters Type Name Description System.DateTime [] array System.Int32 rowIndex Returns Type Description System.DateTime [] GetRowsAfterIndex(Double[], Int32) Returns rows starting with rowIndex and onwards Declaration public static double[] GetRowsAfterIndex(this double[] array, int rowIndex) Parameters Type Name Description System.Double [] array System.Int32 rowIndex Returns Type Description System.Double [] GetRowsAfterIndex(Double[,], Int32) Returns rows starting with rowIndex and onwards Declaration public static double[, ] GetRowsAfterIndex(this double[, ] array, int rowIndex) Parameters Type Name Description System.Double [,] array System.Int32 rowIndex Returns Type Description System.Double [,] Transpose(Double[,]) Transposes a 2d-matrix. Declaration public static double[, ] Transpose(this double[, ] matrix) Parameters Type Name Description System.Double [,] matrix Returns Type Description System.Double [,] WriteColumn(Double[,], Int32, Double[]) overwrites the columin in matrix with the new column newColumnValues Declaration public static double[, ] WriteColumn(this double[, ] matrix, int colIdx, double[] newColumnValues) Parameters Type Name Description System.Double [,] matrix System.Int32 colIdx System.Double [] newColumnValues Returns Type Description System.Double [,]"
  },
  "api/TimeSeriesAnalysis.Dynamic.BandPass.html": {
    "href": "api/TimeSeriesAnalysis.Dynamic.BandPass.html",
    "title": "Class BandPass | TimeSeriesAnalysis reference documentation",
    "keywords": "Class BandPass Numerical band-pass filter based on LowPass This filter is in a recursive(feedback) IIR form that is simple to implement, has few coefficients, requires litte memory and computation. This filter is causal, meaning that for calculating the filtered value at time k it does not use future values such as k+1 , but this is at the expense of introducing a time-shift/phase-shift. Inheritance System.Object BandPass Inherited Members System.Object.ToString() System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.ReferenceEquals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() Namespace : TimeSeriesAnalysis.Dynamic Assembly : TimeSeriesAnalysis.dll Syntax public class BandPass Constructors BandPass(Double) Declaration public BandPass(double TimeBase_s) Parameters Type Name Description System.Double TimeBase_s Methods Filter(Double, Double, Double, Int32, Boolean) Adds a single data point to the filter Declaration public double Filter(double signal, double lpFilterTc_s, double hpFilterTc_s, int order = 1, bool doReset = false) Parameters Type Name Description System.Double signal data point System.Double lpFilterTc_s low-passfilter time constant in seconds System.Double hpFilterTc_s high-passfilter time constant in seconds System.Int32 order filter order, either 1 or 2 is supported System.Boolean doReset usually false, setting to true causes filter to reset to the value of signal Returns Type Description System.Double Filter(Double[], Double, Double, Int32) Filter an entire time-series in one command Declaration public double[] Filter(double[] signal, double lpFilterTc_s, double hpFilterTc_s, int order = 1) Parameters Type Name Description System.Double [] signal the vector of the entire time-series to be filtered System.Double lpFilterTc_s filter time constant System.Double hpFilterTc_s filter time constant System.Int32 order filter order, either 1 or 2 Returns Type Description System.Double [] a vector of the filtered time-series"
  },
  "api/TimeSeriesAnalysis.Dynamic.DefaultProcessModel.html": {
    "href": "api/TimeSeriesAnalysis.Dynamic.DefaultProcessModel.html",
    "title": "Class DefaultProcessModel | TimeSeriesAnalysis reference documentation",
    "keywords": "Class DefaultProcessModel Process model class for the \"Default\" process model. Inheritance System.Object DefaultProcessModel Implements IProcessModel < DefaultProcessModelParameters > Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.ReferenceEquals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() Namespace : TimeSeriesAnalysis.Dynamic Assembly : TimeSeriesAnalysis.dll Syntax public class DefaultProcessModel : IProcessModel<DefaultProcessModelParameters> Constructors DefaultProcessModel(DefaultProcessModelParameters, Double) Constructor Declaration public DefaultProcessModel(DefaultProcessModelParameters modelParameters, double timeBase_s) Parameters Type Name Description DefaultProcessModelParameters modelParameters model paramter object System.Double timeBase_s the timebase in seconds, the time interval between samples and between calls to Iterate DefaultProcessModel(DefaultProcessModelParameters, ProcessDataSet) Initalizer of model that for the given dataSet also creates the resulting y_sim Declaration public DefaultProcessModel(DefaultProcessModelParameters modelParameters, ProcessDataSet dataSet) Parameters Type Name Description DefaultProcessModelParameters modelParameters ProcessDataSet dataSet Properties FittedDataSet Declaration public ProcessDataSet FittedDataSet { get; set; } Property Value Type Description ProcessDataSet Methods GetModelParameters() Get the objet of model paramters contained in the model Declaration public DefaultProcessModelParameters GetModelParameters() Returns Type Description DefaultProcessModelParameters Model paramter object InitSim(Double) Initalize the process model with a sampling time Declaration public void InitSim(double timeBase_s) Parameters Type Name Description System.Double timeBase_s the timebase in seconds, the length of time between calls to Iterate(data sampling time interval) IsModelStatic() Is the model static or dynamic? Declaration public bool IsModelStatic() Returns Type Description System.Boolean Returns true if the model is static(no time constant or time delay terms),otherwise false. Iterate(Double[]) Iterates the process model state one time step, based on the inputs given Declaration public double Iterate(double[] inputsU) Parameters Type Name Description System.Double [] inputsU vector of inputs Returns Type Description System.Double the updated process model output ToString() Create a nice human-readable summary of all the important data contained in the model object. This is especially useful for unit-testing and development. Declaration public override string ToString() Returns Type Description System.String Overrides System.Object.ToString() Implements IProcessModel<T>"
  },
  "api/TimeSeriesAnalysis.Dynamic.DefaultProcessModelIdentifier.html": {
    "href": "api/TimeSeriesAnalysis.Dynamic.DefaultProcessModelIdentifier.html",
    "title": "Class DefaultProcessModelIdentifier | TimeSeriesAnalysis reference documentation",
    "keywords": "Class DefaultProcessModelIdentifier Identifier of the \"Default\" process model - a dynamic process model with time-constant, time-delay, linear process gain and optional (nonlinear)curvature process gains. This model class is sufficent for most real-world dynamic systems, yet also introduces the fewest possible paramters to describe the system in an attempt to avoiding over-fitting/over-parametrization Inheritance System.Object DefaultProcessModelIdentifier Inherited Members System.Object.ToString() System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.ReferenceEquals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() Namespace : TimeSeriesAnalysis.Dynamic Assembly : TimeSeriesAnalysis.dll Syntax public class DefaultProcessModelIdentifier : IProcessModelIdentifier<DefaultProcessModel, DefaultProcessModelParameters> Constructors DefaultProcessModelIdentifier() Declaration public DefaultProcessModelIdentifier() Methods Identify(ref ProcessDataSet) Identifies the \"Default\" process model that best fits the dataSet given Declaration public DefaultProcessModel Identify(ref ProcessDataSet dataSet) Parameters Type Name Description ProcessDataSet dataSet The dataset containing the ymeas and U that is to be fitted against, a new y_sim is also added Returns Type Description DefaultProcessModel returning the model parameters"
  },
  "api/TimeSeriesAnalysis.Dynamic.DefaultProcessModelParameters.html": {
    "href": "api/TimeSeriesAnalysis.Dynamic.DefaultProcessModelParameters.html",
    "title": "Class DefaultProcessModelParameters | TimeSeriesAnalysis reference documentation",
    "keywords": "Class DefaultProcessModelParameters Parameters data class of the \"Default\" process model Inheritance System.Object DefaultProcessModelParameters Implements IFittedProcessModelParameters IProcessModelParameters Inherited Members System.Object.ToString() System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.ReferenceEquals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() Namespace : TimeSeriesAnalysis.Dynamic Assembly : TimeSeriesAnalysis.dll Syntax public class DefaultProcessModelParameters : IFittedProcessModelParameters, IProcessModelParameters Constructors DefaultProcessModelParameters() Declaration public DefaultProcessModelParameters() Properties Bias Declaration public double Bias { get; set; } Property Value Type Description System.Double FittingObjFunVal Declaration public double FittingObjFunVal { get; set; } Property Value Type Description System.Double FittingRsq Declaration public double FittingRsq { get; set; } Property Value Type Description System.Double ProcessGainCurvatures Declaration public double[] ProcessGainCurvatures { get; set; } Property Value Type Description System.Double [] ProcessGains Declaration public double[] ProcessGains { get; set; } Property Value Type Description System.Double [] TimeConstant_s Declaration public double TimeConstant_s { get; set; } Property Value Type Description System.Double TimeDelay_s Declaration public double TimeDelay_s { get; set; } Property Value Type Description System.Double U0 Declaration public double[] U0 { get; set; } Property Value Type Description System.Double [] WasAbleToIdentify Declaration public bool WasAbleToIdentify { get; set; } Property Value Type Description System.Boolean Methods AbleToIdentify() Declaration public bool AbleToIdentify() Returns Type Description System.Boolean AddWarning(ProcessIdentWarnings) Declaration public void AddWarning(ProcessIdentWarnings warning) Parameters Type Name Description ProcessIdentWarnings warning GetFittingObjFunVal() Declaration public double GetFittingObjFunVal() Returns Type Description System.Double GetFittingR2() Declaration public double GetFittingR2() Returns Type Description System.Double GetWarningList() Declaration public List<ProcessIdentWarnings> GetWarningList() Returns Type Description System.Collections.Generic.List < ProcessIdentWarnings > Implements IFittedProcessModelParameters IProcessModelParameters"
  },
  "api/TimeSeriesAnalysis.Dynamic.HighPass.html": {
    "href": "api/TimeSeriesAnalysis.Dynamic.HighPass.html",
    "title": "Class HighPass | TimeSeriesAnalysis reference documentation",
    "keywords": "Class HighPass A high-pass recursive time-series filter based on LowPass . This filter is in a recursive(feedback) IIR form that is simple to implement, has few coefficients, requires litte memory and computation. This filter is causal, meaning that for calculating the filtered value at time k it does not use future values such as k+1 , but this is at the expense of introducing a time-shift/phase-shift. Inheritance System.Object HighPass Inherited Members System.Object.ToString() System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.ReferenceEquals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() Namespace : TimeSeriesAnalysis.Dynamic Assembly : TimeSeriesAnalysis.dll Syntax public class HighPass Constructors HighPass(Double) Declaration public HighPass(double TimeBase_s) Parameters Type Name Description System.Double TimeBase_s Methods Filter(Double, Double, Int32, Boolean) Adds a single data point to the filter Declaration public double Filter(double signal, double FilterTc_s, int order = 1, bool doReset = false) Parameters Type Name Description System.Double signal data point System.Double FilterTc_s filter time constant in seconds System.Int32 order filter order, eitehr 1 or 2 is supported System.Boolean doReset usually false, setting to true causes filter to reset to the value of signal Returns Type Description System.Double Filter(Double[], Double, Int32) Filter an entire time-series in one command Declaration public double[] Filter(double[] signal, double FilterTc_s, int order = 1) Parameters Type Name Description System.Double [] signal the vector of the entire time-series to be filtered System.Double FilterTc_s filter time constant System.Int32 order filter order, either 1 or 2 Returns Type Description System.Double [] a vector of the filtered time-series"
  },
  "api/TimeSeriesAnalysis.Dynamic.html": {
    "href": "api/TimeSeriesAnalysis.Dynamic.html",
    "title": "Namespace TimeSeriesAnalysis.Dynamic | TimeSeriesAnalysis reference documentation",
    "keywords": "Namespace TimeSeriesAnalysis.Dynamic Classes BandPass Numerical band-pass filter based on LowPass This filter is in a recursive(feedback) IIR form that is simple to implement, has few coefficients, requires litte memory and computation. This filter is causal, meaning that for calculating the filtered value at time k it does not use future values such as k+1 , but this is at the expense of introducing a time-shift/phase-shift. DefaultProcessModel Process model class for the \"Default\" process model. DefaultProcessModelIdentifier Identifier of the \"Default\" process model - a dynamic process model with time-constant, time-delay, linear process gain and optional (nonlinear)curvature process gains. This model class is sufficent for most real-world dynamic systems, yet also introduces the fewest possible paramters to describe the system in an attempt to avoiding over-fitting/over-parametrization DefaultProcessModelParameters Parameters data class of the \"Default\" process model HighPass A high-pass recursive time-series filter based on LowPass . This filter is in a recursive(feedback) IIR form that is simple to implement, has few coefficients, requires litte memory and computation. This filter is causal, meaning that for calculating the filtered value at time k it does not use future values such as k+1 , but this is at the expense of introducing a time-shift/phase-shift. LowPass Numerical low-pass filtering of time-series. This filter is in a recursive(feedback) IIR form that is simple to implement, has few coefficients, requires litte memory and computation. This filter is causal, meaning that for calcuating the filtered value at time k it does not use future values such as k+1 , but this is at the expense of introducing a time-shift/phase-shift. /// MovingAvg Moving-average filter of time-series ProcessDataSet The data for a porition of a process, containg only one output and one or multiple inputs that influence it ProcessSimulator<T1, T2> Simulate any process model that has implemented the IProcessModel interface. This class relies on depencency injection and interfaces, so that the the specifics of how models outputs are calculated should be encapsulated in the passed model objects. SinusModel A model of a sinusioid. This class is mainly intended for testing. SinusModelParameters Parameters belonging to the SinusModel class. Note that this class implements the IProcessModelParameters as it is not intended to be fitted against data, but is useful more as a signal generator for testing. TimeDelay Delays a signal by a specific number of time steps, keeping an internal buffer of delayed values between iterations. Interfaces IFittedProcessModelParameters IProcessModel<T> Generic interface of process model IProcessModelParameters This is a simplified interface that is inherited by IFittedProcessModelParamters. It is made to logically separate the interfaces of model paramters that were determined by fitting, and those that are simply hard-coded either from a priori process knowledge or as example systems developed during unit-testing. The ProcessSimulator class should expected models with paramters that derive from this base interface, be they fitted or apriori. Enums ProcessIdentWarnings Enum of recognized warning or error states during identification of process model"
  },
  "api/TimeSeriesAnalysis.Dynamic.IFittedProcessModelParameters.html": {
    "href": "api/TimeSeriesAnalysis.Dynamic.IFittedProcessModelParameters.html",
    "title": "Interface IFittedProcessModelParameters | TimeSeriesAnalysis reference documentation",
    "keywords": "Interface IFittedProcessModelParameters Namespace : TimeSeriesAnalysis.Dynamic Assembly : TimeSeriesAnalysis.dll Syntax public interface IFittedProcessModelParameters : IProcessModelParameters Methods AbleToIdentify() Aks if model was able to be identified or not Declaration bool AbleToIdentify() Returns Type Description System.Boolean true, if the model identification was able to successfully decide on a set of parameters, otherwise false AddWarning(ProcessIdentWarnings) Declaration void AddWarning(ProcessIdentWarnings warnings) Parameters Type Name Description ProcessIdentWarnings warnings GetFittingObjFunVal() An objective function value that describes the fit of the model to the fitting dataset (useful when ranking models, for instance when determining time delay) Declaration double GetFittingObjFunVal() Returns Type Description System.Double GetFittingR2() The root-mean-square of the fit of the model to the fitting dataset (useful when ranking models, for instance when determining time delay) Declaration double GetFittingR2() Returns Type Description System.Double GetWarningList() Declaration List<ProcessIdentWarnings> GetWarningList() Returns Type Description System.Collections.Generic.List < ProcessIdentWarnings >"
  },
  "api/TimeSeriesAnalysis.Dynamic.IProcessModel-1.html": {
    "href": "api/TimeSeriesAnalysis.Dynamic.IProcessModel-1.html",
    "title": "Interface IProcessModel<T> | TimeSeriesAnalysis reference documentation",
    "keywords": "Interface IProcessModel<T> Generic interface of process model Namespace : TimeSeriesAnalysis.Dynamic Assembly : TimeSeriesAnalysis.dll Syntax public interface IProcessModel<T> where T : IProcessModelParameters Type Parameters Name Description T The process model parameters class Methods GetModelParameters() Get the model parameters Declaration T GetModelParameters() Returns Type Description T the paramters objet of the model Iterate(Double[]) Iterate the process model one timestep forward Declaration double Iterate(double[] inputsU) Parameters Type Name Description System.Double [] inputsU a 2d array of inputs, one row for each time step, or null if model is autonomous Returns Type Description System.Double the value of the output y of the process model at the new time step"
  },
  "api/TimeSeriesAnalysis.Dynamic.IProcessModelParameters.html": {
    "href": "api/TimeSeriesAnalysis.Dynamic.IProcessModelParameters.html",
    "title": "Interface IProcessModelParameters | TimeSeriesAnalysis reference documentation",
    "keywords": "Interface IProcessModelParameters This is a simplified interface that is inherited by IFittedProcessModelParamters. It is made to logically separate the interfaces of model paramters that were determined by fitting, and those that are simply hard-coded either from a priori process knowledge or as example systems developed during unit-testing. The ProcessSimulator class should expected models with paramters that derive from this base interface, be they fitted or apriori. Namespace : TimeSeriesAnalysis.Dynamic Assembly : TimeSeriesAnalysis.dll Syntax public interface IProcessModelParameters"
  },
  "api/TimeSeriesAnalysis.Dynamic.LowPass.html": {
    "href": "api/TimeSeriesAnalysis.Dynamic.LowPass.html",
    "title": "Class LowPass | TimeSeriesAnalysis reference documentation",
    "keywords": "Class LowPass Numerical low-pass filtering of time-series. This filter is in a recursive(feedback) IIR form that is simple to implement, has few coefficients, requires litte memory and computation. This filter is causal, meaning that for calcuating the filtered value at time k it does not use future values such as k+1 , but this is at the expense of introducing a time-shift/phase-shift. /// Inheritance System.Object LowPass Inherited Members System.Object.ToString() System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.ReferenceEquals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() Namespace : TimeSeriesAnalysis.Dynamic Assembly : TimeSeriesAnalysis.dll Syntax public class LowPass Constructors LowPass(Double) Constructor Declaration public LowPass(double TimeBase_s) Parameters Type Name Description System.Double TimeBase_s The time base, the time interval between each time step of the dataset, in seconds Methods Filter(Double, Double, Int32, Boolean) Adds a single data point to the filter Declaration public double Filter(double signal, double FilterTc_s, int order = 1, bool doReset = false) Parameters Type Name Description System.Double signal data point System.Double FilterTc_s filter time constant in seconds System.Int32 order filter order, either 1 or 2 is supported System.Boolean doReset usually false, setting to true causes filter to reset to the value of signal Returns Type Description System.Double Filter(Double[], Double, Int32) Filter an entire time-series in one command Declaration public double[] Filter(double[] signal, double FilterTc_s, int order = 1) Parameters Type Name Description System.Double [] signal the vector of the entire time-series to be filtered System.Double FilterTc_s filter time constant System.Int32 order filter order, either 1 or 2 Returns Type Description System.Double [] a vector of the filtered time-series"
  },
  "api/TimeSeriesAnalysis.Dynamic.MovingAvg.html": {
    "href": "api/TimeSeriesAnalysis.Dynamic.MovingAvg.html",
    "title": "Class MovingAvg | TimeSeriesAnalysis reference documentation",
    "keywords": "Class MovingAvg Moving-average filter of time-series Inheritance System.Object MovingAvg Inherited Members System.Object.ToString() System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.ReferenceEquals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() Namespace : TimeSeriesAnalysis.Dynamic Assembly : TimeSeriesAnalysis.dll Syntax public class MovingAvg Constructors MovingAvg(Int32) constructor Declaration public MovingAvg(int bufferSize) Parameters Type Name Description System.Int32 bufferSize the number of samples to average, which determines the size of the buffer to create Methods Add(Double) Add one more value to the moving-average filter, call this method iterativly. Declaration public double Add(double val) Parameters Type Name Description System.Double val the scalar value to be added Returns Type Description System.Double"
  },
  "api/TimeSeriesAnalysis.Dynamic.ProcessDataSet.html": {
    "href": "api/TimeSeriesAnalysis.Dynamic.ProcessDataSet.html",
    "title": "Class ProcessDataSet | TimeSeriesAnalysis reference documentation",
    "keywords": "Class ProcessDataSet The data for a porition of a process, containg only one output and one or multiple inputs that influence it Inheritance System.Object ProcessDataSet Inherited Members System.Object.ToString() System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.ReferenceEquals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() Namespace : TimeSeriesAnalysis.Dynamic Assembly : TimeSeriesAnalysis.dll Syntax public class ProcessDataSet Constructors ProcessDataSet(Double, Double[,], Double[], String) Constructor for dta set with inputs U , i.e. where a relationship that at least partially explains y_meas is konwn Declaration public ProcessDataSet(double timeBase_s, double[, ] U, double[] y_meas = null, string name = null) Parameters Type Name Description System.Double timeBase_s the time base in seconds System.Double [,] U The number of rows of the 2D-array U determines the duration dataset System.Double [] y_meas the measured output of the system, can be null System.String name optional internal name of dataset ProcessDataSet(Double, Int32, String) Constructor for data set without inputs - for \"autonomous\" processes such as sinusoids, rand walks or other disturbancs. Declaration public ProcessDataSet(double timeBase_s, int numDataPoints, string name = null) Parameters Type Name Description System.Double timeBase_s the time base in seconds System.Int32 numDataPoints the desired nubmer of datapoints of the dataset System.String name optional internal name of dataset Fields t0 Declaration public DateTime t0 Field Value Type Description System.DateTime Properties NumDataPoints Declaration public int NumDataPoints { get; } Property Value Type Description System.Int32 ProcessName Declaration public string ProcessName { get; } Property Value Type Description System.String TimeBase_s Declaration public double TimeBase_s { get; set; } Property Value Type Description System.Double Times Declaration public DateTime[] Times { get; } Property Value Type Description System.DateTime [] U Declaration public double[, ] U { get; } Property Value Type Description System.Double [,] Y_meas Declaration public double[] Y_meas { get; set; } Property Value Type Description System.Double [] Y_sim Declaration public double[] Y_sim { get; set; } Property Value Type Description System.Double [] Methods GetAverageU() Get the average value of each input in the dataset. This is useful when defining model local around a working point. Declaration public double[] GetAverageU() Returns Type Description System.Double [] an array of averages, each corrsponding to one column of U. Returns null if it was not possible to calculate averages GetTimeSpan() Get the time spanned by the dataset Declaration public TimeSpan GetTimeSpan() Returns Type Description System.TimeSpan The time spanned by the dataset"
  },
  "api/TimeSeriesAnalysis.Dynamic.ProcessIdentWarnings.html": {
    "href": "api/TimeSeriesAnalysis.Dynamic.ProcessIdentWarnings.html",
    "title": "Enum ProcessIdentWarnings | TimeSeriesAnalysis reference documentation",
    "keywords": "Enum ProcessIdentWarnings Enum of recognized warning or error states during identification of process model Namespace : TimeSeriesAnalysis.Dynamic Assembly : TimeSeriesAnalysis.dll Syntax public enum ProcessIdentWarnings Fields Name Description DataSetVeryShortComparedtoTMax The dataset is time span is very short compared to the maximal time-constant given as input to the algorithm Nothing No errors or warnings NotPossibleToIdentify It was not possible to identify the RegressionProblemFailedToYieldSolution TimeConstantEstimateNotConsistent Time constant estimates vary significantly across dataset, indicating that something is wrong TimeConstantEstimateTooBig Estimation returned an enourmous time constant, this is an indication of something is wrong TimeConstantNotIdentifiable Time constant is not identifiable from dataset TimeDelayAtMaximumConstraint The time delay which gave the lowest objective function is the biggest allowed time delay consider increasing this limit or if something is wrong TimeDelayInternalInconsistencyBetweenObjFunAndUncertainty When considering different time delays internally, you expect the \"best\" to have both the lowest objective functino and the lowest paramter uncertainty but for some reason this is not the case"
  },
  "api/TimeSeriesAnalysis.Dynamic.ProcessSimulator-2.html": {
    "href": "api/TimeSeriesAnalysis.Dynamic.ProcessSimulator-2.html",
    "title": "Class ProcessSimulator<T1, T2> | TimeSeriesAnalysis reference documentation",
    "keywords": "Class ProcessSimulator<T1, T2> Simulate any process model that has implemented the IProcessModel interface. This class relies on depencency injection and interfaces, so that the the specifics of how models outputs are calculated should be encapsulated in the passed model objects. Inheritance System.Object ProcessSimulator<T1, T2> Inherited Members System.Object.ToString() System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.ReferenceEquals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() Namespace : TimeSeriesAnalysis.Dynamic Assembly : TimeSeriesAnalysis.dll Syntax public class ProcessSimulator<T1, T2> where T1 : IProcessModel<T2> where T2 : IProcessModelParameters Type Parameters Name Description T1 T2 Methods EmulateYmeas(T1, ref ProcessDataSet) Simulation is written to ymeas instead of ysim. This is useful when creating generic datasets for testing and validation. Declaration public static void EmulateYmeas(T1 model, ref ProcessDataSet processDataSet) Parameters Type Name Description T1 model ProcessDataSet processDataSet Simulate(T1, ref ProcessDataSet, Boolean, Boolean) Simulates the output of the model based on the processDataSet provided, by default the output is written back to processDataSet.Y_sim or processDataSet.Y_meas By default this method adds to Y_sim o Y_meas if they already contain values. Declaration public static bool Simulate(T1 model, ref ProcessDataSet processDataSet, bool writeResultToYmeasInsteadOfYsim = false, bool doOverwriteY = false) Parameters Type Name Description T1 model model paramters ProcessDataSet processDataSet dataset containing the inputs U to be simulated System.Boolean writeResultToYmeasInsteadOfYsim if true , output is written to processDataSet.ymeas instead of processDataSet.ysim System.Boolean doOverwriteY (default is false)if true , output overwrites any datay in processDataSet.ymeas or processDataSet.ysim Returns Type Description System.Boolean Returns true if able to simulate, false otherwise."
  },
  "api/TimeSeriesAnalysis.Dynamic.SinusModel.html": {
    "href": "api/TimeSeriesAnalysis.Dynamic.SinusModel.html",
    "title": "Class SinusModel | TimeSeriesAnalysis reference documentation",
    "keywords": "Class SinusModel A model of a sinusioid. This class is mainly intended for testing. Inheritance System.Object SinusModel Implements IProcessModel < SinusModelParameters > Inherited Members System.Object.ToString() System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.ReferenceEquals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() Namespace : TimeSeriesAnalysis.Dynamic Assembly : TimeSeriesAnalysis.dll Syntax public class SinusModel : IProcessModel<SinusModelParameters> Constructors SinusModel(SinusModelParameters, Double) Declaration public SinusModel(SinusModelParameters parameters, double timeBase_s) Parameters Type Name Description SinusModelParameters parameters System.Double timeBase_s Methods GetModelParameters() Declaration public SinusModelParameters GetModelParameters() Returns Type Description SinusModelParameters Iterate(Double[]) Declaration public double Iterate(double[] inputsU) Parameters Type Name Description System.Double [] inputsU Returns Type Description System.Double Implements IProcessModel<T>"
  },
  "api/TimeSeriesAnalysis.Dynamic.SinusModelParameters.html": {
    "href": "api/TimeSeriesAnalysis.Dynamic.SinusModelParameters.html",
    "title": "Class SinusModelParameters | TimeSeriesAnalysis reference documentation",
    "keywords": "Class SinusModelParameters Parameters belonging to the SinusModel class. Note that this class implements the IProcessModelParameters as it is not intended to be fitted against data, but is useful more as a signal generator for testing. Inheritance System.Object SinusModelParameters Implements IProcessModelParameters Inherited Members System.Object.ToString() System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.ReferenceEquals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() Namespace : TimeSeriesAnalysis.Dynamic Assembly : TimeSeriesAnalysis.dll Syntax public class SinusModelParameters : IProcessModelParameters Fields amplitude Declaration public double amplitude Field Value Type Description System.Double period_s Declaration public double period_s Field Value Type Description System.Double Implements IProcessModelParameters"
  },
  "api/TimeSeriesAnalysis.Dynamic.TimeDelay.html": {
    "href": "api/TimeSeriesAnalysis.Dynamic.TimeDelay.html",
    "title": "Class TimeDelay | TimeSeriesAnalysis reference documentation",
    "keywords": "Class TimeDelay Delays a signal by a specific number of time steps, keeping an internal buffer of delayed values between iterations. Inheritance System.Object TimeDelay Inherited Members System.Object.ToString() System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.ReferenceEquals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() Namespace : TimeSeriesAnalysis.Dynamic Assembly : TimeSeriesAnalysis.dll Syntax public class TimeDelay Constructors TimeDelay(Double, Double) Initalize Declaration public TimeDelay(double timeBase_s, double timeDelay_s) Parameters Type Name Description System.Double timeBase_s the simulation time interval between each subsequent call to Delay (in seconds) System.Double timeDelay_s the time delay to be simulated(in seconds). Note that the time delay will be rounded up to neares whole number factor of timeBase_s Methods Delay(Double) Delays output by a certain number of time steps Declaration public double Delay(double inputSignal) Parameters Type Name Description System.Double inputSignal input signal to be delayed Returns Type Description System.Double a version of inputSignal that is delayed"
  },
  "api/TimeSeriesAnalysis.html": {
    "href": "api/TimeSeriesAnalysis.html",
    "title": "Namespace TimeSeriesAnalysis | TimeSeriesAnalysis reference documentation",
    "keywords": "Namespace TimeSeriesAnalysis Classes Array2D Non-generic 2D-array methods Array2D<T> Generic array operations that can be done on arrays of any type, for operators specific to numerical arrays(matrices) see Matrix.cs Array2DExtensionMethods Extension methods based on Array2D Matrix Operations for treating 2D-arrays as mathetmatical matrices RegressionResults Class that holds the results of a regression run. Vec Vec<T> Class for generic methods on any type T that treat arrays as vectors(sorting,slicing,concatenating). For mathematical methods on vectors of doubles and integers, look into non-generic sister class \"Vec\". VecExtensionMethods Utility functions and operations for treating arrays as mathetmatical vectors Enums VectorFindValueType VectorSortType"
  },
  "api/TimeSeriesAnalysis.Matrix.html": {
    "href": "api/TimeSeriesAnalysis.Matrix.html",
    "title": "Class Matrix | TimeSeriesAnalysis reference documentation",
    "keywords": "Class Matrix Operations for treating 2D-arrays as mathetmatical matrices Inheritance System.Object Matrix Inherited Members System.Object.ToString() System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.ReferenceEquals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() Namespace : TimeSeriesAnalysis Assembly : TimeSeriesAnalysis.dll Syntax public static class Matrix Methods AppendRow(Double[,], Double[]) Appends another row onto an existing matrix. Returns null if this was not possible(ie. dimnesions dont agree). Declaration public static double[, ] AppendRow(double[, ] matrix, double[] newRowVec) Parameters Type Name Description System.Double [,] matrix System.Double [] newRowVec Returns Type Description System.Double [,] ComponentMult(Double[,], Double[], Int32) Multipliy either entire matrix or single row(optional third input) by a vector (returns a matrix) Declaration public static double[, ] ComponentMult(double[, ] matrix, double[] vector, int singleMatrixRowToMult = -1) Parameters Type Name Description System.Double [,] matrix System.Double [] vector System.Int32 singleMatrixRowToMult Returns Type Description System.Double [,] Mult(Double[,], Double, Int32) Multipliy either entire matrix or single row(optional third input) by a scalar Declaration public static double[, ] Mult(double[, ] matrix, double scalar, int singleMatrixRowToMult = -1) Parameters Type Name Description System.Double [,] matrix System.Double scalar System.Int32 singleMatrixRowToMult Returns Type Description System.Double [,] Mult(Double[,], Double[]) Multipliy either entire matrix or single row(optional third input) by a vector (returns vector) Declaration public static double[] Mult(double[, ] matrix, double[] vector) Parameters Type Name Description System.Double [,] matrix System.Double [] vector Returns Type Description System.Double [] ReplaceColumn(Double[,], Int32, Double[]) Replace a single column of a matrix Declaration public static double[, ] ReplaceColumn(double[, ] matrix, int colIndex, double[] newColVec) Parameters Type Name Description System.Double [,] matrix System.Int32 colIndex System.Double [] newColVec Returns Type Description System.Double [,] ReplaceRow(Double[,], Int32, Double[]) Replace a single row of a matrix Declaration public static double[, ] ReplaceRow(double[, ] matrix, int rowIndex, double[] newRowVec) Parameters Type Name Description System.Double [,] matrix System.Int32 rowIndex System.Double [] newRowVec Returns Type Description System.Double [,]"
  },
  "api/TimeSeriesAnalysis.RegressionResults.html": {
    "href": "api/TimeSeriesAnalysis.RegressionResults.html",
    "title": "Class RegressionResults | TimeSeriesAnalysis reference documentation",
    "keywords": "Class RegressionResults Class that holds the results of a regression run. Inheritance System.Object RegressionResults Inherited Members System.Object.ToString() System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.ReferenceEquals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() Namespace : TimeSeriesAnalysis Assembly : TimeSeriesAnalysis.dll Syntax public class RegressionResults Constructors RegressionResults() Declaration public RegressionResults() Properties ableToIdentify Declaration public bool ableToIdentify { get; set; } Property Value Type Description System.Boolean Bias Declaration public double Bias { get; set; } Property Value Type Description System.Double objectiveFunctionValue Declaration public double objectiveFunctionValue { get; set; } Property Value Type Description System.Double param Declaration public double[] param { get; set; } Property Value Type Description System.Double [] param95prcConfInterval Declaration public double[] param95prcConfInterval { get; set; } Property Value Type Description System.Double [] Rsq R2-root-means-squared between Y and Y_modelled for the tuning dataset(a value between 0 and 100, higher is better) Declaration public double Rsq { get; set; } Property Value Type Description System.Double varCovarMatrix Declaration public double[][] varCovarMatrix { get; set; } Property Value Type Description System.Double [][] Y_modelled Declaration public double[] Y_modelled { get; set; } Property Value Type Description System.Double []"
  },
  "api/TimeSeriesAnalysis.Utility.CSV.html": {
    "href": "api/TimeSeriesAnalysis.Utility.CSV.html",
    "title": "Class CSV | TimeSeriesAnalysis reference documentation",
    "keywords": "Class CSV IO Utility class for loading time-series data from a plain text comma-separated variable(CSV) file Inheritance System.Object CSV Inherited Members System.Object.ToString() System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.ReferenceEquals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() Namespace : TimeSeriesAnalysis.Utility Assembly : TimeSeriesAnalysis.dll Syntax public class CSV Methods LoadDataFromCSV(String, out Double[,], out String[], out String[,]) Load time-series data from a CSV-file into variables for further processing Declaration public static bool LoadDataFromCSV(string filename, out double[, ] doubleData, out string[] variableNames, out string[, ] stringData) Parameters Type Name Description System.String filename path of file to be loaded System.Double [,] doubleData (output) the returned 2D array where each column is the data for one variable System.String [] variableNames (output) an array of the variable names in doubleData System.String [,] stringData (output)the raw data of the entire csv-file in a 2D array, only needed if parsing of other two variables has failed, and useful for retireving timestamps Returns Type Description System.Boolean RobustParseDouble(String, out Double) Loading string data into a double value. Declaration public static bool RobustParseDouble(string str, out double value) Parameters Type Name Description System.String str the string to be parsed System.Double value (output) is the value of the parsed double(if successfully parsed) Returns Type Description System.Boolean The method returns true if succesful, otherwise it returns false."
  },
  "api/TimeSeriesAnalysis.Utility.html": {
    "href": "api/TimeSeriesAnalysis.Utility.html",
    "title": "Namespace TimeSeriesAnalysis.Utility | TimeSeriesAnalysis reference documentation",
    "keywords": "Namespace TimeSeriesAnalysis.Utility Classes CSV IO Utility class for loading time-series data from a plain text comma-separated variable(CSV) file ParserFeedback Plot Static methods for plotting one or more time-series across one or more y-axes and one or more subplots. If you sometimes need to disable plots (for instance if plotting code is included in unit tests) see Plot4Test Plot4Test Version of Plot class where plots code can be Enabled()/Disabled() programatically. This allows you to keep all your \"Plot\" calls in your unit tests and turn them on as needed to debug a single test, while avoid being overwhelmed with plots if for instance re-running all unit tests. SignificantDigits Utility class to round double variables to a given nubmer of signficant digits. StringToFileWriter IO Utility class to write to file that implements IDisposable interface. Suggest to use this objects of this class within the using keyword so that file-resources are automatically freed in case your code is terminated before it has completed. TimeSeriesCreator UnixTime Utility class to work with unix time stamps Structs ParserFeedbackLogLine Enums ParserfeedbackMessageLevel"
  },
  "api/TimeSeriesAnalysis.Utility.ParserFeedback.html": {
    "href": "api/TimeSeriesAnalysis.Utility.ParserFeedback.html",
    "title": "Class ParserFeedback | TimeSeriesAnalysis reference documentation",
    "keywords": "Class ParserFeedback Inheritance System.Object ParserFeedback Inherited Members System.Object.ToString() System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.ReferenceEquals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() Namespace : TimeSeriesAnalysis.Utility Assembly : TimeSeriesAnalysis.dll Syntax public class ParserFeedback Constructors ParserFeedback(Boolean) Declaration public ParserFeedback(bool doOutputAlsoToConsole = false) Parameters Type Name Description System.Boolean doOutputAlsoToConsole Methods AddError(String) Declaration public void AddError(string message) Parameters Type Name Description System.String message AddFatalError(String) Declaration public void AddFatalError(string message) Parameters Type Name Description System.String message AddInfo(String) Adds an info message Declaration public void AddInfo(string message) Parameters Type Name Description System.String message AddWarning(String) Adds a warning Declaration public void AddWarning(string message) Parameters Type Name Description System.String message Close() Flushes all messages to file and closes file handlers. Declaration public void Close() CloseCaseLogFile() Declaration public void CloseCaseLogFile() CreateCaseLogFile(String, Int32) Creates a new empty log file for a specific case name. Calling this function before StoreMessage will cause all messages to be copied to it. Declaration public void CreateCaseLogFile(string caseName, int caseNum) Parameters Type Name Description System.String caseName System.Int32 caseNum CreateCommonHTMLfile() Creates a html file, where is \"case\" is presented in an iframe- useful for quickly viewing many cases Needs SetCaseArray to be called first Declaration public void CreateCommonHTMLfile() CreateCommonLogFile(String) Creates a new empty log file and, resets counters etc. This is a \"common\" file if no cases are specificed Declaration public void CreateCommonLogFile(string loggDir) Parameters Type Name Description System.String loggDir EnableConsoleOutput(Boolean) Declaration public void EnableConsoleOutput(bool doEnable) Parameters Type Name Description System.Boolean doEnable GetFirstErrorOrWarning() Intended for unit tests, get the first error or warning message Declaration public string GetFirstErrorOrWarning() Returns Type Description System.String GetListOfAllLogLinesAtOrAboveLevel(ParserfeedbackMessageLevel) Returns all log lines at or above a specified level Declaration public List<string> GetListOfAllLogLinesAtOrAboveLevel(ParserfeedbackMessageLevel desiredLevel = ParserfeedbackMessageLevel.warn) Parameters Type Name Description ParserfeedbackMessageLevel desiredLevel Returns Type Description System.Collections.Generic.List < System.String > GetListOfAllLogLinesAtOrBelowLevel(ParserfeedbackMessageLevel) Returns all log lines at or belowe a specified level Declaration public List<string> GetListOfAllLogLinesAtOrBelowLevel(ParserfeedbackMessageLevel desiredLevel = ParserfeedbackMessageLevel.warn) Parameters Type Name Description ParserfeedbackMessageLevel desiredLevel Returns Type Description System.Collections.Generic.List < System.String > GetListOfAllLogLinesOfLevel(ParserfeedbackMessageLevel) Returns all log lines of a specified level Declaration public List<string> GetListOfAllLogLinesOfLevel(ParserfeedbackMessageLevel desiredLevel) Parameters Type Name Description ParserfeedbackMessageLevel desiredLevel Returns Type Description System.Collections.Generic.List < System.String > GetLogFilename() Declaration public string GetLogFilename() Returns Type Description System.String GetLogFilePath() Declaration public string GetLogFilePath() Returns Type Description System.String IsNumberOfErrorsAndWarningsZero() For testing, this is a way to check that no errors or warnings have been given. Declaration public bool IsNumberOfErrorsAndWarningsZero() Returns Type Description System.Boolean ResetCounters() Declaration public void ResetCounters() SetCaseArray(String[]) Declaration public void SetCaseArray(string[] caseArray) Parameters Type Name Description System.String [] caseArray"
  },
  "api/TimeSeriesAnalysis.Utility.ParserFeedbackLogLine.html": {
    "href": "api/TimeSeriesAnalysis.Utility.ParserFeedbackLogLine.html",
    "title": "Struct ParserFeedbackLogLine | TimeSeriesAnalysis reference documentation",
    "keywords": "Struct ParserFeedbackLogLine Inherited Members System.ValueType.Equals(System.Object) System.ValueType.GetHashCode() System.ValueType.ToString() System.Object.Equals(System.Object, System.Object) System.Object.ReferenceEquals(System.Object, System.Object) System.Object.GetType() Namespace : TimeSeriesAnalysis.Utility Assembly : TimeSeriesAnalysis.dll Syntax public struct ParserFeedbackLogLine Fields message Declaration public string message Field Value Type Description System.String messageLevel Declaration public ParserfeedbackMessageLevel messageLevel Field Value Type Description ParserfeedbackMessageLevel time Declaration public DateTime time Field Value Type Description System.DateTime"
  },
  "api/TimeSeriesAnalysis.Utility.ParserfeedbackMessageLevel.html": {
    "href": "api/TimeSeriesAnalysis.Utility.ParserfeedbackMessageLevel.html",
    "title": "Enum ParserfeedbackMessageLevel | TimeSeriesAnalysis reference documentation",
    "keywords": "Enum ParserfeedbackMessageLevel Namespace : TimeSeriesAnalysis.Utility Assembly : TimeSeriesAnalysis.dll Syntax public enum ParserfeedbackMessageLevel Fields Name Description error fatal info warn"
  },
  "api/TimeSeriesAnalysis.Utility.Plot.html": {
    "href": "api/TimeSeriesAnalysis.Utility.Plot.html",
    "title": "Class Plot | TimeSeriesAnalysis reference documentation",
    "keywords": "Class Plot Static methods for plotting one or more time-series across one or more y-axes and one or more subplots. If you sometimes need to disable plots (for instance if plotting code is included in unit tests) see Plot4Test Inheritance System.Object Plot Inherited Members System.Object.ToString() System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.ReferenceEquals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() Namespace : TimeSeriesAnalysis.Utility Assembly : TimeSeriesAnalysis.dll Syntax public class Plot Methods FromList(List<Double[]>, List<String>, Int32, String, DateTime, String, Boolean, String) Time-series plotting in a pop-up browser window, based on plot.ly Declaration public static string FromList(List<double[]> dataList, List<string> plotNames, int dT_s, string comment = null, DateTime t0 = default(DateTime), string caseName = \"\", bool doStartChrome = true, string customPlotDataPath = null) Parameters Type Name Description System.Collections.Generic.List < System.Double []> dataList List of doubles, one entry for each time-series to be plotted System.Collections.Generic.List < System.String > plotNames List of string of unique names to describe each plot, prefixed by either \"y1=\"(top left),\"y2=\"(top right),\"y3=\"(bottom left) or \"y4=\"(bottom right) to denote what y-axis to plot the variable on System.Int32 dT_s the time between data samples in seconds System.String comment a comment that is shown in the plot System.DateTime t0 the DateTime of the first data point System.String caseName give each plot a casename if creating multiple plots with the re-occurring variable names System.Boolean doStartChrome By setting doStartChrome to false, you can skip opening up chrome, the link to figure will instead be returned System.String customPlotDataPath by overriding this variable, the data is written to another path than the default C:\\inetpub\\wwwroot\\plotly\\Data\\ Returns Type Description System.String The url of the resulting plot is returned"
  },
  "api/TimeSeriesAnalysis.Utility.Plot4Test.html": {
    "href": "api/TimeSeriesAnalysis.Utility.Plot4Test.html",
    "title": "Class Plot4Test | TimeSeriesAnalysis reference documentation",
    "keywords": "Class Plot4Test Version of Plot class where plots code can be Enabled()/Disabled() programatically. This allows you to keep all your \"Plot\" calls in your unit tests and turn them on as needed to debug a single test, while avoid being overwhelmed with plots if for instance re-running all unit tests. Inheritance System.Object Plot4Test Inherited Members System.Object.ToString() System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.ReferenceEquals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() Namespace : TimeSeriesAnalysis.Utility Assembly : TimeSeriesAnalysis.dll Syntax public class Plot4Test Constructors Plot4Test(Boolean, Int32) Determine wheter plots are to be enabled or disabled on. To further prevent thousands of plots from accidentally being created by this object a maximum number of plots is set, override as needed. Declaration public Plot4Test(bool enableByDefault = true, int maxNplots = 6) Parameters Type Name Description System.Boolean enableByDefault System.Int32 maxNplots Methods Disable() Disable all subsequent calls to plot using the same instance of this class. Declaration public void Disable() Enable() Enable all subsequent calls to plot using the same instance of this class. Declaration public void Enable() FromList(List<Double[]>, List<String>, Int32, String, DateTime, String, Boolean, String) Wrapper for Plot.FromList that Declaration public string FromList(List<double[]> dataList, List<string> plotNames, int dT_s, string comment = null, DateTime t0 = default(DateTime), string caseName = \"\", bool doStartChrome = true, string customPlotDataPath = null) Parameters Type Name Description System.Collections.Generic.List < System.Double []> dataList System.Collections.Generic.List < System.String > plotNames System.Int32 dT_s System.String comment System.DateTime t0 System.String caseName System.Boolean doStartChrome System.String customPlotDataPath Returns Type Description System.String GetNumberOfPlotsMade() Declaration public int GetNumberOfPlotsMade() Returns Type Description System.Int32"
  },
  "api/TimeSeriesAnalysis.Utility.SignificantDigits.html": {
    "href": "api/TimeSeriesAnalysis.Utility.SignificantDigits.html",
    "title": "Class SignificantDigits | TimeSeriesAnalysis reference documentation",
    "keywords": "Class SignificantDigits Utility class to round double variables to a given nubmer of signficant digits. Inheritance System.Object SignificantDigits Inherited Members System.Object.ToString() System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.ReferenceEquals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() Namespace : TimeSeriesAnalysis.Utility Assembly : TimeSeriesAnalysis.dll Syntax public static class SignificantDigits Fields DecimalSeparator Declaration public static string DecimalSeparator Field Value Type Description System.String Methods Format(Double, Int32) Rounds down to number of significant digits (26->20 if digits=1 for instance) Declaration public static double Format(double number, int digits) Parameters Type Name Description System.Double number System.Int32 digits Returns Type Description System.Double Format(Double, Int32, out Int32) Rounds down to number of significant digits (26->20 if digits=1 for instance) Declaration public static double Format(double number, int digits, out int exponent) Parameters Type Name Description System.Double number System.Int32 digits System.Int32 exponent Returns Type Description System.Double GetSciFormat(Double, out Double, out Int32) Returns number in scientific format with coefficient and exponential paramters Declaration public static void GetSciFormat(double number, out double coeff, out int exp) Parameters Type Name Description System.Double number System.Double coeff System.Int32 exp SciToDouble(Double, Int32) Converts a scientific number on the format coeff*10^exp to a double Declaration public static double SciToDouble(double coeff, int exp) Parameters Type Name Description System.Double coeff coefficient System.Int32 exp exponent Returns Type Description System.Double converted double"
  },
  "api/TimeSeriesAnalysis.Utility.StringToFileWriter.html": {
    "href": "api/TimeSeriesAnalysis.Utility.StringToFileWriter.html",
    "title": "Class StringToFileWriter | TimeSeriesAnalysis reference documentation",
    "keywords": "Class StringToFileWriter IO Utility class to write to file that implements IDisposable interface. Suggest to use this objects of this class within the using keyword so that file-resources are automatically freed in case your code is terminated before it has completed. Inheritance System.Object StringToFileWriter Implements System.IDisposable Inherited Members System.Object.ToString() System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.ReferenceEquals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() Namespace : TimeSeriesAnalysis.Utility Assembly : TimeSeriesAnalysis.dll Syntax public class StringToFileWriter : IDisposable Constructors StringToFileWriter(String) Declaration public StringToFileWriter(string filename) Parameters Type Name Description System.String filename StringToFileWriter(String, Encoding) Declaration public StringToFileWriter(string filename, Encoding encoding) Parameters Type Name Description System.String filename System.Text.Encoding encoding Methods Close() Declaration public void Close() CreateDirectoryStructure(String) Declaration public void CreateDirectoryStructure(string FilePath) Parameters Type Name Description System.String FilePath Dispose() Declaration public void Dispose() Dispose(Boolean) Declaration protected virtual void Dispose(bool disposing) Parameters Type Name Description System.Boolean disposing Write(String) Declaration public void Write(string text) Parameters Type Name Description System.String text Implements System.IDisposable"
  },
  "api/TimeSeriesAnalysis.Utility.TimeSeriesCreator.html": {
    "href": "api/TimeSeriesAnalysis.Utility.TimeSeriesCreator.html",
    "title": "Class TimeSeriesCreator | TimeSeriesAnalysis reference documentation",
    "keywords": "Class TimeSeriesCreator Inheritance System.Object TimeSeriesCreator Inherited Members System.Object.ToString() System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.ReferenceEquals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() Namespace : TimeSeriesAnalysis.Utility Assembly : TimeSeriesAnalysis.dll Syntax public class TimeSeriesCreator Methods CreateTimeSeries(DateTime, Int32, Int32) Create an array of DateTimes starting at t0 of length N and with sampling interval dT_s Declaration public static DateTime[] CreateTimeSeries(DateTime t0, int dT_s, int N) Parameters Type Name Description System.DateTime t0 first datetime in the array to be created System.Int32 dT_s sampling internval System.Int32 N number of desired data points Returns Type Description System.DateTime []"
  },
  "api/TimeSeriesAnalysis.Utility.UnixTime.html": {
    "href": "api/TimeSeriesAnalysis.Utility.UnixTime.html",
    "title": "Class UnixTime | TimeSeriesAnalysis reference documentation",
    "keywords": "Class UnixTime Utility class to work with unix time stamps Inheritance System.Object UnixTime Inherited Members System.Object.ToString() System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.ReferenceEquals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() Namespace : TimeSeriesAnalysis.Utility Assembly : TimeSeriesAnalysis.dll Syntax public class UnixTime Methods ConvertFromUnixTimestamp(Double) Converts a unix timestamp into a DateTime Declaration public static DateTime ConvertFromUnixTimestamp(double timestamp) Parameters Type Name Description System.Double timestamp the double time stamp to be converted Returns Type Description System.DateTime a converted DateTime object ConvertToUnixTimestamp(DateTime) Converts a DateTime into a unix timestamp Declaration public static double ConvertToUnixTimestamp(DateTime date) Parameters Type Name Description System.DateTime date Returns Type Description System.Double A unix time stamp double GetNowUnixTime() Declaration public static double GetNowUnixTime() Returns Type Description System.Double"
  },
  "api/TimeSeriesAnalysis.Vec.html": {
    "href": "api/TimeSeriesAnalysis.Vec.html",
    "title": "Class Vec | TimeSeriesAnalysis reference documentation",
    "keywords": "Class Vec Inheritance System.Object Vec Inherited Members System.Object.ToString() System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.ReferenceEquals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() Namespace : TimeSeriesAnalysis Assembly : TimeSeriesAnalysis.dll Syntax public static class Vec Methods Abs(Double[]) returns an array where each value is the absolute value of array1 Declaration public static double[] Abs(double[] array1) Parameters Type Name Description System.Double [] array1 Returns Type Description System.Double [] Add(Double[], Double) elementwise addition of val2 to array1 Declaration public static double[] Add(double[] array1, double val2) Parameters Type Name Description System.Double [] array1 System.Double val2 Returns Type Description System.Double [] Add(Double[], Double[]) returns an array which is the elementwise addition of array1 and array2 Declaration public static double[] Add(double[] array1, double[] array2) Parameters Type Name Description System.Double [] array1 System.Double [] array2 Returns Type Description System.Double [] Add(Int32[], Int32) elementwise addition of val2 to array1 Declaration public static int[] Add(int[] array1, int val2) Parameters Type Name Description System.Int32 [] array1 System.Int32 val2 Returns Type Description System.Int32 [] AppendTrailingIndices(List<Int32>) When filtering out bad data before identification, before fitting data to difference equations that depend both y[k] and y[k-1] it will some times be neccessary, to append the trailing indices for instance on Declaration public static List<int> AppendTrailingIndices(List<int> indiceArray) Parameters Type Name Description System.Collections.Generic.List < System.Int32 > indiceArray Returns Type Description System.Collections.Generic.List < System.Int32 > ContainsBadData(Double[]) Returns true f array contains a \"-9999\" or NaN indicating missing data Declaration public static bool ContainsBadData(double[] x) Parameters Type Name Description System.Double [] x Returns Type Description System.Boolean Cov(Double[], Double[], Boolean) returns the co-variance of two arrays(interpreted as \"vectors\") Declaration public static double Cov(double[] array1, double[] array2, bool doNormalize = false) Parameters Type Name Description System.Double [] array1 System.Double [] array2 System.Boolean doNormalize Returns Type Description System.Double Deserialize(String) de-serializes a single vector/array (written by serialize) Declaration public static double[] Deserialize(string fileName) Parameters Type Name Description System.String fileName Returns Type Description System.Double [] Diff(Double[]) returns an array of the difference between every neighbhoring item in array Declaration public static double[] Diff(double[] array) Parameters Type Name Description System.Double [] array Returns Type Description System.Double [] Div(Double[], Double) Divides an vector by a scalar value Declaration public static double[] Div(double[] vector, double scalar) Parameters Type Name Description System.Double [] vector System.Double scalar Returns Type Description System.Double [] an vector of values representing the array didived by a scalar. In case of NaN inputs or divide-by-zero NaN elements are returned. Div(Double[], Double[]) Divides two vectors of equal length Declaration public static double[] Div(double[] vector1, double[] vector2) Parameters Type Name Description System.Double [] vector1 System.Double [] vector2 Returns Type Description System.Double [] an vector of values representing the array didived by a scalar. In case of NaN inputs or divide-by-zero NaN elements are returned FindValues(Double[], Double, VectorFindValueType) return the indices of elements in the array that have certain relation to value given type (bigger,smaller,equal etc.) Also capable of finding NaN values Declaration public static List<int> FindValues(double[] vec, double value, VectorFindValueType type) Parameters Type Name Description System.Double [] vec System.Double value VectorFindValueType type Returns Type Description System.Collections.Generic.List < System.Int32 > Intersect(List<Int32>, List<Int32>) returns the intersection of array1 and array2, a list of elements that are in both vectors Declaration public static List<int> Intersect(List<int> vec1, List<int> vec2) Parameters Type Name Description System.Collections.Generic.List < System.Int32 > vec1 System.Collections.Generic.List < System.Int32 > vec2 Returns Type Description System.Collections.Generic.List < System.Int32 > InverseIndices(Int32, List<Int32>) given a list of sorted indeces and a desired vector size N, returns the indices that are not in \"sortedIndices\" i.e. of the \"other vectors Declaration public static List<int> InverseIndices(int N, List<int> sortedIndices) Parameters Type Name Description System.Int32 N System.Collections.Generic.List < System.Int32 > sortedIndices Returns Type Description System.Collections.Generic.List < System.Int32 > IsAllNaN(Double[]) Returns true if all elements in array are \"-9999\" or Double.NaN Declaration public static bool IsAllNaN(double[] array) Parameters Type Name Description System.Double [] array Returns Type Description System.Boolean IsAllValue(Double[], Double) Returns true if all elements in array are the specific value Declaration public static bool IsAllValue(double[] array, double value = 0) Parameters Type Name Description System.Double [] array System.Double value Returns Type Description System.Boolean MakeIndexArray(Int32, Int32) creates a monotonically increasing integer (11.12.13...) array starting at startValue and ending at endValue Declaration public static int[] MakeIndexArray(int startValue, int endValue) Parameters Type Name Description System.Int32 startValue System.Int32 endValue Returns Type Description System.Int32 [] Max(Double[]) Returns maximum value of array Declaration public static double Max(double[] array) Parameters Type Name Description System.Double [] array Returns Type Description System.Double Max(Double[], Double) Returns element-wise maximum of array element and value Declaration public static double[] Max(double[] array, double value) Parameters Type Name Description System.Double [] array System.Double value Returns Type Description System.Double [] Max(Double[], Double[]) Returns maximum value of two array as new array Declaration public static double[] Max(double[] array1, double[] array2) Parameters Type Name Description System.Double [] array1 System.Double [] array2 Returns Type Description System.Double [] Max(Double[], Int32, Int32) Returns maximum value of array between indices startInd and endInd Declaration public static double Max(double[] array, int startInd, int endInd) Parameters Type Name Description System.Double [] array System.Int32 startInd System.Int32 endInd Returns Type Description System.Double Max(Double[], out Int32) Returns maximum value of array and index of maximum value Declaration public static double Max(double[] array, out int ind) Parameters Type Name Description System.Double [] array System.Int32 ind Returns Type Description System.Double Mean(Double[]) returns the mean value of array1 Declaration public static double? Mean(double[] array1) Parameters Type Name Description System.Double [] array1 Returns Type Description System.Nullable < System.Double > Min(Double[]) Returns minimum value of array Declaration public static double Min(double[] array) Parameters Type Name Description System.Double [] array Returns Type Description System.Double Min(Double[], Double) Returns element-wise minimum of array element and value Declaration public static double[] Min(double[] array, double value) Parameters Type Name Description System.Double [] array System.Double value Returns Type Description System.Double [] Min(Double[], Double[]) Returns minimum value of two array as new array Declaration public static double[] Min(double[] array1, double[] array2) Parameters Type Name Description System.Double [] array1 System.Double [] array2 Returns Type Description System.Double [] Min(Double[], out Int32) Returns minimum value of array and index of maximum value Declaration public static double Min(double[] array, out int ind) Parameters Type Name Description System.Double [] array System.Int32 ind Returns Type Description System.Double Mult(Double[], Double) elementwise multipliation of val2 to array1 Declaration public static double[] Mult(double[] array1, double val2) Parameters Type Name Description System.Double [] array1 System.Double val2 Returns Type Description System.Double [] Multiply(Double[], Double[]) elementwise multiplication of array1 and array2, assuming they are same size Declaration public static double[] Multiply(double[] array1, double[] array2) Parameters Type Name Description System.Double [] array1 System.Double [] array2 Returns Type Description System.Double [] Rand(Int32, Double, Double, Nullable<Int32>) Create a vector of random numbers Declaration public static double[] Rand(int N, double minValue = 0, double maxValue = 1, int? seed = null) Parameters Type Name Description System.Int32 N the number of samples of the returned array System.Double minValue lower end of random number range System.Double maxValue higher end of random number range System.Nullable < System.Int32 > seed optionally, give in a seed number, this makes random sequence repeatable Returns Type Description System.Double [] an array of size N of random numbers between minValue and maxValue Range(Double[]) Returns range of an array, the difference between minimum and maximum Declaration public static double Range(double[] array) Parameters Type Name Description System.Double [] array Returns Type Description System.Double Regress(Double[], Double[][], Int32[]) Linear regression Declaration public static RegressionResults Regress(double[] Y, double[][] X, int[] yIndToIgnore = null) Parameters Type Name Description System.Double [] Y vector of responve variable values (to be modelled) System.Double [][] X matrix of of mainpulated values/independent values/regressors used to explain Y System.Int32 [] yIndToIgnore (optional) a list of the indices of values in Y to ignore in regression. By default it is null Returns Type Description RegressionResults an object of the RegressionResult class with the paramters, as well as some statistics on the fit and uncertainty thereof. ReplaceIndWithValue(Double[], List<Int32>, Double) Replace certain values in an array with a new value. Declaration public static double[] ReplaceIndWithValue(double[] array, List<int> indList, double valueToReplaceWith) Parameters Type Name Description System.Double [] array the array to be replaces System.Collections.Generic.List < System.Int32 > indList list of all the indices of all data points in array to be replaced System.Double valueToReplaceWith the new value to use in place of old values. Returns Type Description System.Double [] A copy of the original array with the values repalced as specified RSquared(Double[], Double[], List<Int32>) R-squared R-squared (R2) is a statistical measure that represents the proportion of the variance for a dependent variable that's explained by an independent variable or variables in a regression model. Whereas correlation explains the strength of the relationship between an independent and dependent variable, R-squared explains to what extent the variance of one variable explains the variance of the second variable. So, if the R2 of a model is 0.50 , then approximately half of the observed variation can be explained by the model's inputs. Declaration public static double RSquared(double[] vector1, double[] vector2, List<int> indToIgnoreExt = null) Parameters Type Name Description System.Double [] vector1 first vector System.Double [] vector2 second vector System.Collections.Generic.List < System.Int32 > indToIgnoreExt optionally: indices to be ignored(for instance bad values) Returns Type Description System.Double R2 squared, a value between -1 and 1 . If an error occured, Double.PositiveInfinity is returned SelfSumOfAbsErr(Double[]) sum of absolute error of the vector compared to itself Declaration public static double SelfSumOfAbsErr(double[] vec) Parameters Type Name Description System.Double [] vec Returns Type Description System.Double SelfSumOfSquareErr(Double[]) sum of square error of the vector compared to itself Declaration public static double SelfSumOfSquareErr(double[] vec) Parameters Type Name Description System.Double [] vec Returns Type Description System.Double Serialize(Double[], String) serializes a single vector/array to a file for persistent storage to a human-readable text format Vector data can then be retreived by companion method Deserialize Declaration public static bool Serialize(double[] vector, string fileName) Parameters Type Name Description System.Double [] vector vector to be written to afile System.String fileName the file name (or path) of the file to which the vector is to serialized to Returns Type Description System.Boolean Subtract(Double[], Double) elementwise subtraction of val2 from array1 Declaration public static double[] Subtract(double[] array1, double val2) Parameters Type Name Description System.Double [] array1 System.Double val2 Returns Type Description System.Double [] Subtract(Double[], Double[]) elementwise subtraction of array1 and array2, assuming they are same size Declaration public static double[] Subtract(double[] array1, double[] array2) Parameters Type Name Description System.Double [] array1 System.Double [] array2 Returns Type Description System.Double [] Subtract(Int32[], Int32) subtracts val2 from array2 elements Declaration public static int[] Subtract(int[] array1, int val2) Parameters Type Name Description System.Int32 [] array1 System.Int32 val2 Returns Type Description System.Int32 [] Sum(Double[]) returns the sum of array1 Declaration public static double? Sum(double[] array1) Parameters Type Name Description System.Double [] array1 Returns Type Description System.Nullable < System.Double > SumOfAbsErr(Double[], Double[], Int32) The sum of absolute errors (|a1-a2|) between array1 and array2 Declaration public static double SumOfAbsErr(double[] array1, double[] array2, int indexOffset = -1) Parameters Type Name Description System.Double [] array1 System.Double [] array2 System.Int32 indexOffset Returns Type Description System.Double SumOfSquareErr(Double[], Double, Boolean) sum of square error of the vector compared to a constant. by defautl the return value is normalized by dividing by, this normalization can be turned off Declaration public static double SumOfSquareErr(double[] vec, double constant, bool doNormalization = true) Parameters Type Name Description System.Double [] vec System.Double constant System.Boolean doNormalization Returns Type Description System.Double SumOfSquareErr(Double[], Double[], Int32, Boolean, List<Int32>) The sum of square errors (a1-a2)^2 between array1 and array2 . Declaration public static double SumOfSquareErr(double[] array1, double[] array2, int ymodOffset = -1, bool divByN = true, List<int> indToIgnore = null) Parameters Type Name Description System.Double [] array1 System.Double [] array2 System.Int32 ymodOffset System.Boolean divByN if true, the result is normalized by the number of good values System.Collections.Generic.List < System.Int32 > indToIgnore optionally a list of indices of array1 to ignore Returns Type Description System.Double ToString(Double[], Int32, String) Declaration public static string ToString(double[] array, int nSignificantDigits, string dividerStr = \";\") Parameters Type Name Description System.Double [] array System.Int32 nSignificantDigits System.String dividerStr Returns Type Description System.String Union(List<Int32>, List<Int32>) returns the union of array1 and array2, a list of elements that are in either vector Declaration public static List<int> Union(List<int> vec1, List<int> vec2) Parameters Type Name Description System.Collections.Generic.List < System.Int32 > vec1 System.Collections.Generic.List < System.Int32 > vec2 Returns Type Description System.Collections.Generic.List < System.Int32 > Var(Double[], Boolean) returns the variance of the array (always apositive number) Declaration public static double Var(double[] array1, bool doNormalize = false) Parameters Type Name Description System.Double [] array1 System.Boolean doNormalize Returns Type Description System.Double"
  },
  "api/TimeSeriesAnalysis.Vec-1.html": {
    "href": "api/TimeSeriesAnalysis.Vec-1.html",
    "title": "Class Vec<T> | TimeSeriesAnalysis reference documentation",
    "keywords": "Class Vec<T> Class for generic methods on any type T that treat arrays as vectors(sorting,slicing,concatenating). For mathematical methods on vectors of doubles and integers, look into non-generic sister class \"Vec\". Inheritance System.Object Vec<T> Inherited Members System.Object.ToString() System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.ReferenceEquals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() Namespace : TimeSeriesAnalysis Assembly : TimeSeriesAnalysis.dll Syntax public static class Vec<T> Type Parameters Name Description T Methods Concat(T[], T) concatenates the value y to the end of array x Declaration public static T[] Concat(T[] x, T y) Parameters Type Name Description T[] x T y Returns Type Description T[] Concat(T[], T[]) concatenates arrays x and y into a new larger array Declaration public static T[] Concat(T[] x, T[] y) Parameters Type Name Description T[] x T[] y Returns Type Description T[] Fill(T, Int32) creates an array of size N where every element has value value Declaration public static T[] Fill(T value, int N) Parameters Type Name Description T value System.Int32 N Returns Type Description T[] GetValuesAtIndices(T[], List<Int32>) returns an array of the values that are in array at the indeices given by indices list Declaration public static T[] GetValuesAtIndices(T[] array, List<int> indices) Parameters Type Name Description T[] array System.Collections.Generic.List < System.Int32 > indices Returns Type Description T[] ReplaceIndWithValuesPrior(Double[], List<Int32>) replaces all the vaules in array with indices in indList with the last good value prior to that index. Declaration public static double[] ReplaceIndWithValuesPrior(double[] array, List<int> indList) Parameters Type Name Description System.Double [] array System.Collections.Generic.List < System.Int32 > indList Returns Type Description System.Double [] Sort(T[], VectorSortType) sort the vector vec acording to the sortType. Declaration public static T[] Sort(T[] vec, VectorSortType sortType) Parameters Type Name Description T[] vec VectorSortType sortType Returns Type Description T[] Sort(T[], VectorSortType, out Int32[]) sort the vector vec acording to the sortType. The indices corresponding tot he sorted values are given out in the idx array. Declaration public static T[] Sort(T[] vec, VectorSortType sortType, out int[] idx) Parameters Type Name Description T[] vec VectorSortType sortType System.Int32 [] idx Returns Type Description T[] SubArray(T[], Int32, Int32) returns the portion of array1 starting and indStart, and ending at indEnd(or at the end if third paramter is omitted) Declaration public static T[] SubArray(T[] array1, int indStart, int indEnd = -9999) Parameters Type Name Description T[] array1 System.Int32 indStart System.Int32 indEnd Returns Type Description T[]"
  },
  "api/TimeSeriesAnalysis.VecExtensionMethods.html": {
    "href": "api/TimeSeriesAnalysis.VecExtensionMethods.html",
    "title": "Class VecExtensionMethods | TimeSeriesAnalysis reference documentation",
    "keywords": "Class VecExtensionMethods Utility functions and operations for treating arrays as mathetmatical vectors Inheritance System.Object VecExtensionMethods Inherited Members System.Object.ToString() System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.ReferenceEquals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() Namespace : TimeSeriesAnalysis Assembly : TimeSeriesAnalysis.dll Syntax public static class VecExtensionMethods Methods Add(Double[], Double) Declaration public static double[] Add(this double[] array, double scalar) Parameters Type Name Description System.Double [] array System.Double scalar Returns Type Description System.Double [] Mult(Double[], Double) Declaration public static double[] Mult(this double[] array, double scalar) Parameters Type Name Description System.Double [] array System.Double scalar Returns Type Description System.Double [] Sub(Double[], Double[]) Declaration public static double[] Sub(this double[] array1, double[] array2) Parameters Type Name Description System.Double [] array1 System.Double [] array2 Returns Type Description System.Double [] ToString(Double[], Int32, String) Declaration public static string ToString(this double[] array, int nSignificantDigits, string dividerStr = \";\") Parameters Type Name Description System.Double [] array System.Int32 nSignificantDigits System.String dividerStr Returns Type Description System.String"
  },
  "api/TimeSeriesAnalysis.VectorFindValueType.html": {
    "href": "api/TimeSeriesAnalysis.VectorFindValueType.html",
    "title": "Enum VectorFindValueType | TimeSeriesAnalysis reference documentation",
    "keywords": "Enum VectorFindValueType Namespace : TimeSeriesAnalysis Assembly : TimeSeriesAnalysis.dll Syntax public enum VectorFindValueType Fields Name Description BiggerOrEqual BiggerThan Equal NaN NotNaN SmallerOrEqual SmallerThan"
  },
  "api/TimeSeriesAnalysis.VectorSortType.html": {
    "href": "api/TimeSeriesAnalysis.VectorSortType.html",
    "title": "Enum VectorSortType | TimeSeriesAnalysis reference documentation",
    "keywords": "Enum VectorSortType Namespace : TimeSeriesAnalysis Assembly : TimeSeriesAnalysis.dll Syntax public enum VectorSortType Fields Name Description Ascending Descending"
  },
  "articles/ex_filtering.html": {
    "href": "articles/ex_filtering.html",
    "title": "Example 3 : Filtering | TimeSeriesAnalysis reference documentation",
    "keywords": "Example 3 : Filtering TimeSeriesAnalysis includes basic recursive filtering through the classes LowPass , HighPass and BandPass . To illustrate their capabilities, we create an artificial dataset which is made of two sinusoids sinus1 and sinus2 of different amplitudes and frequencies. Sinuses are implemented in a SinusModel class, and can be simulated by ProcessSimulator . The two sinues are added together by calling ProcessSimulator.Simulate() twice on the same ProcessDataSet . Now, we want to define a LowPass and HighPass filter that can separate out the high-frequency and low-frequency sinuses, and this is mainly a matter of choosing appropriate filter time constants of either filter. sinus1 has an period of 400 seconds, and thus goes from maximum to minimum amplitude in about ~200 seconds. Remembering that a first-order system by rule-of-thumb will take about 5 time-constants to implement 99% of a change, motivates a time constant of 200/5=40 seconds for the low-pass filter. By a similar logic,as sinus2 has a period of 25 seconds will go from maximum to minimum amplitude in about 12 seconcds, thus motivating a filter time-constant of about ~3 seconds. The example code(runnable through the Test Explorer ): public void Ex3_filters() { double timeBase_s = 1; int nStepsDuration = 2000; var sinus1 = new SinusModel(new SinusModelParameters { amplitude = 10, period_s = 400 },timeBase_s); var sinus2 = new SinusModel(new SinusModelParameters { amplitude = 1, period_s = 25 }, timeBase_s); var dataset = new ProcessDataSet(timeBase_s, nStepsDuration); ProcessSimulator<SinusModel, SinusModelParameters>.Simulate(sinus1, ref dataset); ProcessSimulator<SinusModel, SinusModelParameters>.Simulate(sinus2, ref dataset); var lpFilter = new LowPass(timeBase_s); var lpFiltered = lpFilter.Filter(dataset.Y_sim,40,1); var hpFilter = new HighPass(timeBase_s); var hpFiltered = hpFilter.Filter(dataset.Y_sim,3,1); Plot.FromList(new List<double[]> { dataset.Y_sim, lpFiltered, hpFiltered }, new List<string> { \"y1=y\",\"y3=y_lowpass\",\"y3=y_highpass\" }, (int)timeBase_s); } Running the above code results in the below plot. In the top plot y that is two sinusoids overlayed. The below plot shows the highpass- and lowpass-filtered versions of y and by the naked eye you can see that the filters have approximately managed to capture and separate out the two components. Note If you look closely, you will notice that y_highpass and y_lowpass sinusoids are delayed slightly in comparison to y , and also that the amplitudes of the two signals do not completely match the originals. This is due to the phase-shift and attenuation causes by the recurisve filters, and is good to be aware of. It would be possible to get even smoother filtered signals by increasing the filter order from 1 to 2 for either filter, but the penalty would be increased phase-shift."
  },
  "articles/ex_hello_world.html": {
    "href": "articles/ex_hello_world.html",
    "title": "Example 1 : A simple \"hello world\" | TimeSeriesAnalysis reference documentation",
    "keywords": "Example 1 : A simple \"hello world\" Consider the example ex1_hello_world in Examples.cs : [Test, Explicit] public void ex1_hello_world() { int dT_s = 1; double filterTc_s = 10; double[] input = Vec<double>.Concat(Vec<double>.Fill(0, 11), Vec<double>.Fill(1, 50)); LowPass lp = new LowPass(dT_s); var output = lp.Filter(input, filterTc_s); Plot.FromList(new List<double[]> { input, output}, new List<string> { \"y1=input\",\"y1=output\"}, dT_s, \"ex1_hello_world\", new DateTime(2020, 1, 1, 0, 0, 0)); } Which when run should creates the following plot. The line int dT_s = 1; specifies the sampling time , i.e. the number of seconds between each sample in the time-series, and both LowPass and Plot require this information to correctly interpret the time-series. The time-constant of the filter, expressed in seconds, is set by the line double filterTc_s = 10; . The concept of the time-constant is very central in the domain of filters, control and dynamic systems. A time constant by a loose definition the time it takes for a linear system to reach 67% of its next steady-state. In this example, a step change in input at time t=10s, has reached output=0.67 sometime between t=[21s,22s]. Another useful rule of thumb, is that a a linear system has reached to within 99% of it new steady-state by five times the time constant , so in this case output exceeds 0.99 by t=59s . The next line creates an array of doubles that describes the input to the filter. By means of Vec.Concat and Vec.Fill , this input is initialized to first 11 samples of of the value 0, followed by 50 samples of the value one, a step-change , another important concept in the analysis of dynamic systems. double[] input = Vec<double>.Concat(Vec<double>.Fill(0, 11),Vec<double>.Fill(1, 50)); The input array is filtered by a low-pass filter and, the resulting output is the second time-series vector considered in this example. LowPass lp = new LowPass(dT_s); var output = lp.Filter(input, filterTc_s); The final action in this example is to plot the two time-series together: Plot.FromList(new List<double[]> { input, output}, new List<string> { \"y1=input\",\"y1=output\"}, dT_s, \"ex1_hello_world\", new DateTime(2020, 1, 1, 0, 0, 0)); The first input to this method is the variables to plot as a List of doubles: new List<double[]> { input, output} . The Plot.FromList command can in principle handle any number of inputs in this manner. The second variable determines what axes the variable is to be plotted on and what names to give each time-series trend in the legend . The prefix y1= indicates that the variable is to be plotted on the left axes of the first subplot. The string \"ex1_hello_world\" is displayed as the plot title, and new DateTime(2020, 1, 1, 0, 0, 0) determines that the plot is to start at midnight on on the first day of 2020. Note Try changing new List<string> { \"y1=input\",\"y1=output\"} to new List<string> { \"y1=input\",\"y2=output\"} and notice how output is now plotted on the right axes. Then try new List<string> { \"y1=input\",\"y3=output\"} and notice output is now plotted on a second subplot below the input . Note This is an example of transient data, as the variable output is in a transient state for a significant part of the dataset. Note Try dragging and zooming the plot, and using the scooter to reading the exact time and value off the output variable in each time step in the transient. Notice that the plot.ly library provides an interactive menu of to the top right of the screen."
  },
  "articles/ex_linreg.html": {
    "href": "articles/ex_linreg.html",
    "title": "Example 2 : Linear regression example | TimeSeriesAnalysis reference documentation",
    "keywords": "Example 2 : Linear regression example In this example, a synthetic dataset is created with the help of helper methods from TimeSeriesAnalysis , then Vec.Regress is used to do linear regression on the dataset to determine the parameters which best describe the relationship between inputs u1,u2,u3 and output y . Vec.Rand is used to add noise to the dataset, Vec.Mult is used to multiply vector and scalars The code: [Test, Explicit] public void ex2_linreg() { double[] true_gains = {1,2,3}; double true_bias = 5; double noiseAmplitude = 0.1; double[] u1 = Vec<double>.Concat(Vec<double>.Fill(0, 11), Vec<double>.Fill(1, 50)); double[] u2 = Vec<double>.Concat(Vec<double>.Fill(1, 31), Vec<double>.Fill(2, 30)); double[] u3 = Vec<double>.Concat(Vec<double>.Fill(1, 21), Vec<double>.Fill(-1, 40)); double[] y = new double[u1.Length]; double[] noise = Vec.Mult(Vec.Rand(u1.Length, -1,1,0),noiseAmplitude); for (int k = 0; k < u1.Length; k++) { y[k] = true_gains[0] * u1[k] + true_gains[1] * u2[k] + true_gains[2] * u3[k] + true_bias + noise[k]; } Plot.FromList(new List<double[]> { y, u1, u2, u3 }, new List<string> { \"y1=y1\", \"y3=u1\", \"y3=u2\", \"y3=u3\" }, 1); double[][] U = new double[][] { u1, u2, u3 }; double[] estimated_parameters = Vec.Regress(y, U,null, out _, out double[] y_modelled, out double Rsq); TestContext.WriteLine(Vec.ToString(estimated_parameters,3)); TestContext.WriteLine(SignificantDigits.Format(Rsq,3)); Plot.FromList(new List<double[]>() { y, y_modelled }, new List<string>() { \"y1=y_meas\", \"y1=y_mod\" }, 1); } The dataset : Note The above is an example of how to plot time-series on multiple y-axes, which is extremely useful to visualize input/output relationships. The resulting modeled y_modelled compared to y : The estimated parameters (rounded to three significant digits) returned are: [1.02;2.01;3.02;5.01] which is very close to the true values: [1;2;3;5] Note The returned vector of parameters will be slightly dependent on the seed number given to Vec.Rand() , but if the inputs U have enough excitation , the significance should be minimal. The returned Rsquare is 99,9 , indicating that in this case the model describes variations in the dataset very well, as should be expected in this case, as we have generated the dataset from a linear model that has the same structure as that used by Vec.Regress with the same inputs, and all three inputs vary enough and interdependently of each other."
  },
  "articles/ex_pid.html": {
    "href": "articles/ex_pid.html",
    "title": "Example 5 : Simulating PID-control | TimeSeriesAnalysis reference documentation",
    "keywords": "Example 5 : Simulating PID-control"
  },
  "articles/ex_sysid.html": {
    "href": "articles/ex_sysid.html",
    "title": "Example 4 : Fitting a dynamic model to transient data example | TimeSeriesAnalysis reference documentation",
    "keywords": "Example 4 : Fitting a dynamic model to transient data example public void Ex4_sysid() { int timeBase_s = 1; DefaultProcessModelParameters parameters = new DefaultProcessModelParameters { WasAbleToIdentify = true, TimeConstant_s = 15, ProcessGains = new double[] {1,2}, TimeDelay_s = 5, Bias = 5 }; DefaultProcessModel model = new DefaultProcessModel(parameters, timeBase_s); double[] u1 = Vec<double>.Concat(Vec<double>.Fill(0, 11), Vec<double>.Fill(1, 50)); double[] u2 = Vec<double>.Concat(Vec<double>.Fill(2, 31), Vec<double>.Fill(1, 30)); double[,] U = Array2D<double>.InitFromColumnList(new List<double[]>{u1 ,u2}); ProcessDataSet dataSet = new ProcessDataSet(timeBase_s,U); ProcessSimulator<DefaultProcessModel,DefaultProcessModelParameters>. EmulateYmeas(model, ref dataSet); Plot.FromList(new List<double[]> { dataSet.Y_meas, u1, u2 }, new List<string> { \"y1=y_meas\", \"y3=u1\", \"y3=u2\" }, timeBase_s); DefaultProcessModelIdentifier modelId = new DefaultProcessModelIdentifier(); DefaultProcessModel identifiedModel = modelId.Identify(ref dataSet); Plot.FromList(new List<double[]> { identifiedModel.FittedDataSet.Y_meas, identifiedModel.FittedDataSet.Y_sim }, new List<string> { \"y1=y_meas\", \"y1=y_sim\"}, timeBase_s); Console.WriteLine(identifiedModel.ToString()); }"
  },
  "articles/example_linreg.html": {
    "href": "articles/example_linreg.html",
    "title": "Example : realistic linear regression | TimeSeriesAnalysis reference documentation",
    "keywords": "Example : realistic linear regression This example uses a ficticious csv-file example.csv, that has column headers \"Time\",\"Var1\",\"Var2\",\"Var3\",\"Var4,\"Var5\",Var6\",\"Var7\". \"Var1\" is to be modelled by Var2 - Var6 as regressors, while Var7 is to be multiplied to Var2 - Var6 . The data contains some instances of -9999 which indicates bad data, and this is removed in preprocessing. A low-pass filter is used to imitate a time-constant in the system by smoothing the model inputs. Only the data starting after a specific t0 is to be used in the regression, so a subset of the raw data in the csv-file is given to regression. This example illustrates that by using the TimeSeriesAnalysis package, the complexity of the code required to do practical exploratory time-series analysis is comparable to what is normally accomplished by parsed languages such as Matlab, R or Python. using System; using System.Collections.Generic; using System.Linq; using TimeSeriesAnalysis; namespace SubseaPALL { class run { public static void Main() { CSV.loadDataFromCSV(@\"C:\\Appl\\ex1\\Data\\example.csv\", out double[,] data, out string[] variableNames,out string[,] stringData); int tInd = Array.IndexOf(variableNames, \"Time\"); DateTime[] dateTimes = stringData.GetColumnParsedAsDateTime(tInd, \"yyyy-MM-dd HH:mm:ss\"); TimeSpan span = dateTimes[1].Subtract(dateTimes[0]); int dT_s = (int)span.TotalSeconds; int t0Ind = 9476;// first instance DateTime t0 = dateTimes.ElementAt(t0Ind); int yInd = Array.IndexOf(variableNames, \"var1\"); //V1: use choke openings as inputs int u1Ind, u2Ind, u3Ind, u4Ind, u5Ind; u1Ind = Array.IndexOf(variableNames, \"var2\"); u2Ind = Array.IndexOf(variableNames, \"var3\"); u3Ind = Array.IndexOf(variableNames, \"var4\"); u4Ind = Array.IndexOf(variableNames, \"var5\"); u5Ind = Array.IndexOf(variableNames, \"var6\"); int u6ind = Array.IndexOf(variableNames, \"var7\"); int[] uIndArray = new int[] { u1Ind, u2Ind, u3Ind, u4Ind, u5Ind }; double[] y_raw = data.GetColumn(yInd); double[,] u_raw = data.GetColumns(uIndArray) ; double[] u6_raw = data.GetColumn(u6ind); // clip out desired chunk of data double[] y = y_raw.GetRowsAfterIndex(t0Ind); double[,] u = u_raw.GetRowsAfterIndex(t0Ind); double[] z_topside = u6_raw.GetRowsAfterIndex(t0Ind); // preprocessing - remove bad values List<int> yIndToIgnoreRaw = new List<int>(); for (int colInd = 0; colInd < u.GetNColumns(); colInd++) { List<int> badValInd = Vec.FindValues(u.GetColumn(colInd), -9999, FindValues.NaN); yIndToIgnoreRaw.AddRange(badValInd); } yIndToIgnoreRaw.AddRange(Vec.FindValues(y, -9999, FindValues.NaN)); yIndToIgnoreRaw.AddRange(Vec.FindValues(z_topside, -9999, FindValues.NaN)); List<int> yIndToIgnore =(List<int>)yIndToIgnoreRaw.Distinct().ToList(); // do scaling, input trickery and then regress u = u.Transpose(); double[] y_plot = Vec.ReplaceIndWithValuesPrior(y, yIndToIgnore);// -9999 destroys plot double[] u1_plot = Vec.ReplaceIndWithValuesPrior(u.GetRow(0), yIndToIgnore);// -9999 destroys plot double[] u2_plot = Vec.ReplaceIndWithValuesPrior(u.GetRow(1), yIndToIgnore);// -9999 destroys plot double[] u3_plot = Vec.ReplaceIndWithValuesPrior(u.GetRow(2), yIndToIgnore);// -9999 destroys plot double[] u4_plot = Vec.ReplaceIndWithValuesPrior(u.GetRow(3), yIndToIgnore);// -9999 destroys plot double[] u5_plot = Vec.ReplaceIndWithValuesPrior(u.GetRow(4), yIndToIgnore);// -9999 destroys plot double[] u6_plot = Vec.ReplaceIndWithValuesPrior(z_topside, yIndToIgnore);// -9999 destroys plot // temperature does not change much based on changes in the upper half of the range valve-opening rate, as flow rates also // do not change that much (valve flow vs. choke opening is nonlinear) double z_Max = 60; double z_MaxTopside = 80; u = Matrix.ReplaceRow(u,0, Vec.Min(u.GetRow(0), z_Max)); u = Matrix.ReplaceRow(u,1, Vec.Min(u.GetRow(1), z_Max)); u = Matrix.ReplaceRow(u,2, Vec.Min(u.GetRow(2), z_Max)); u = Matrix.ReplaceRow(u,3, Vec.Min(u.GetRow(3), z_Max)); u = Matrix.ReplaceRow(u,4, Vec.Min(u.GetRow(4), z_Max)); u = Matrix.Mult(u, 0.01); z_topside = Vec.Mult(Vec.Min(z_topside, z_MaxTopside), 0.01); z_topside = Vec.Mult(z_topside, 0.01); u = Matrix.Mult(u, z_topside); // lowpass filtering of inputs double TimeConstant_s = 1800;//73.24 LowPass filter = new LowPass(TimeConstant_s); u = Matrix.ReplaceRow(u, 0, filter.Filter(u.GetRow(0), TimeConstant_s)); u = Matrix.ReplaceRow(u, 1, filter.Filter(u.GetRow(1), TimeConstant_s)); u = Matrix.ReplaceRow(u, 2, filter.Filter(u.GetRow(2), TimeConstant_s)); u = Matrix.ReplaceRow(u, 3, filter.Filter(u.GetRow(3), TimeConstant_s)); u = Matrix.ReplaceRow(u, 4, filter.Filter(u.GetRow(4), TimeConstant_s)); if (u == null) { Console.WriteLine(\"u is null, something went wrong\"); return; } var uJaggedArray = u.Convert2DtoJagged(); double[] parameters = Vec.Regress(y, uJaggedArray, yIndToIgnore.ToArray(), out _, out double[] y_mod,out double Rsq); double[] e = Vec.Sub(y_plot, y_mod); //present results if (y_mod == null) { Console.WriteLine(\"something went wrong, regress returned null\"); } else { Plot.Six(u1_plot, u2_plot, u3_plot, u4_plot, u5_plot,u6_plot, dT_s,\"z_D1\", \"z_D2\", \"z_D3\", \"z_D4\",\"z_D5\",\"z_topside\",true,false,null,t0); Plot.Two(y_plot, y_mod, dT_s, \"T_Dtopside(meas)\", \"T_Dtopside(mod)\",true,false,\"Rsq\"+Rsq.ToString(\"#.##\"),t0); Plot.One(e,dT_s,\"avvik\",null, t0); } } } }"
  },
  "articles/examples.html": {
    "href": "articles/examples.html",
    "title": "Code examples | TimeSeriesAnalysis reference documentation",
    "keywords": "Code examples All examples are implemented in Examples.cs . Upon building the project, you can run and examine the examples from the Test Explorer as you would any unit test by right click>Run Test ."
  },
  "articles/getting_started.html": {
    "href": "articles/getting_started.html",
    "title": "| TimeSeriesAnalysis reference documentation",
    "keywords": ""
  },
  "articles/glossary.html": {
    "href": "articles/glossary.html",
    "title": "Glossary | TimeSeriesAnalysis reference documentation",
    "keywords": "Glossary Time base Time-base in this context is another expression for sampling time which is the inverse of the sampling rate . So a sampling frequency of 10 Hz , would mean a sampling time/time base of 0.1s . Linear versus non-linear systems A linear system refers to a system that can be described by a linear differential equation, i.e. its states are linear in the dependent variables u . A nonlinear is system is any system that is not linear. Example: If x is the system state, then dx/dt = b * u is linear while x = b * u + c * u^2 is non-linear State of a system So the state of a system is the values of a set of variables that together define the current condition of the system uniequly. Often in system identfication the system state is referred to as x . Note that the output y is not neccesarily the same as the state. If the system is described by the differential equation, then the state x is the solution of this equation set. Steady-state versus transient Steady-state in a differential equation is the condition that the differential terms are zero, so that the system remains at rest. Static versus dynamic A model is termed static if any changes in inputs fully propagete immediately the outputs. So a static model is a model with no transients , and thus has no time-constant or time-delay terms. Working point and local models Any nonlinear system can be approximated as linear around a working point . So a local model in this context is a model that is intended to mainly approximate the actual system close to a given value u0 of the manipulated variables. Depending on the degree of non-linearity, the working range aroundt the working point that the model is useful for will vary. Tuning dataset versus validation dataset The tuning dataset , also referred to as the fitted dataset is the actual set of data that the model was fitted against. It is common practice in system identifiation to evaluate models not on the fit to the tuning set but on a fresh set of data , and this fresh data set used for evaluation is referred to as the validation dataset ."
  },
  "articles/index.html": {
    "href": "articles/index.html",
    "title": "TimeSeriesAnalysis .NET class library | TimeSeriesAnalysis reference documentation",
    "keywords": "TimeSeriesAnalysis .NET class library At a glance TimeSeriesAnalysis is a .NET class library for making it easy to work with time series in .NET framework (written in C# ). It handles typical tasks related to time-series analysis such as loading time-series data from CSV-files, manipulating time-series data as arrays and vectors, filtering out values by range, detecting and removing bad values, smoothing fitting static models to time-series data by linear regression(based on Accord.NET ), fitting dynamic models to time-series by custom methods that build on linear regression, and plotting times-series (in a browser window with plot.ly ). dynamic simulation of systems that may include interatctions with PID-controllers (the library includes a reference PID-controller implementation). The aim of this library is to make the process of working with time series as easy as possible, and the resulting work flow should be comparable to working in Matlab , Python or R . This means that you can treat time series as vectors and matrices easily, without worrying about the arrays underneath, and perform operations like adding, subtracting, multiplying with vectors and matrices, as well as typical pre-processing tasks like selecting subsets of a larger dataset, removing spurious values, min/max range limits etc. The result is a that tasks that you would normally do in for instance Matlab due to the perceived simplicity offered by the language, can now be accomplished in about the same amount of code in C#/.NET . The benefit of doing this in C#/.NET that you get the benefits of a compiled type strict language, by writing your prototype code directly a language suitable for implementation, (unlike a prototype in some script languages). In some cases this may that you can avoid introducing Matlab code generator toolboxes which act as complex black-boxes, and often require expensive licenses. the resulting code does not required a paid license to run. you can easily extend your code to for instance run in parallel using the paralell.for functionality freely available in .NET, wheres this functionality may require a very expensive toolbox in a script language. Note Originally this code has been written with automation/control-engineering in mind, as control engineers typically prefer compiled languages such as C# for code that is to be integrated in the control system . Control systems are usually written in compiled languages in the C/C++/C# family, and the same is also true of other enterprise commercial software that deals heavily with time-series, such as dynamic simulators or condition-based monitoring systems. This repository could be a toolbox for building Advanced analytics tools as part of Industry 4.0 Plotting capabilities Plotting supports one or two subplots(stacked vertically) one or two y-axes on either subplot support for zooming in the plot, subplots x-axes are linked when zooming ability to turn trends on/off, which will cause auto-zoom to update ability to hover over trends to inspect values currently up to six trends can be plotted on a page in total(this can be increased if there is interest) The plotting leverages the JavaScript framework plot.ly . Some JavaScript extensions have been made to this toolbox to allow time-series to seamlessly be exported from your .NET code to the browser. Consider the unit-test PlotUnitTests.SubplotPositionWorksOk() : The code below is used to generate four \"vectors\", arrays of doubles, with a step change in each. public void SubplotPositionWorksOk() { double[] input2 = Vec<double>.Concat(Vec<double>.Fill(0, 20), Vec<double>.Fill(2, 20)); double[] input1 = Vec<double>.Concat(Vec<double>.Fill(0, 10), Vec<double>.Fill(1, 30)); double[] input3 = Vec<double>.Concat(Vec<double>.Fill(0, 30), Vec<double>.Fill(1, 10)); double[] input4 = Vec<double>.Concat(Vec<double>.Fill(0, 35), Vec<double>.Fill(1, 5)); string plotURL = Plot.FromList(new List<double[]>{ input1,input2,input3,input4}, new List<string>{ \"y1=input1\",\"y2=input2\",\"y3=input3\",\"y4=input4\"},1, \"unit test\",new DateTime(2020,1,1, 0,0,0), \"Test_SubplotPositionWorksOk\"); } Note Note how the Vec.Fill() an Vec.Concat() of TimeSeriesAnalysis package is used in this example to create two vectors of a given length and value and concatenate them in a single line of code. The above code generates the following interactive plot in a Chrome-window(this window pops up automatically): This plot has two subplots (one top, one bottom). Each subplot has both a left and a right axis: the top subplot has axes y1 and y2 and the bottom subplot has axes y3 and y4 . By using the top left menu, it is possible to zoom and drag the plots, and the two subplots are linked , meaning when you zoom in one of them, the x-axes of the other plot will zoom as well. Moving the cursor over each plot allows the values to be browsed by an interactive scooter . By clicking on the variable names in the legend on the top left, it is possible to disable plotting selected variables. Note Multiple plots will cause Chrome to display them in multiple tabs. A large number of figures can be generated and sorted in this way."
  },
  "articles/intro.html": {
    "href": "articles/intro.html",
    "title": "Introduction | TimeSeriesAnalysis reference documentation",
    "keywords": "Introduction In this folder you will find detailed worked-though articles including code samples."
  },
  "articles/nuget.html": {
    "href": "articles/nuget.html",
    "title": "Nuget package upload how-to | TimeSeriesAnalysis reference documentation",
    "keywords": "Nuget package upload how-to This is .NET framework 4.6.1 class library published to github packages, by means of the following tutorial: https://github.community/t/publish-net-framework-nuget-package/3077/2 and here: https://docs.microsoft.com/en-us/nuget/create-packages/creating-a-package-msbuild Note that the steps here are somewhat different to most online tutorials which target .NET Core and use the \"dotnet\" CLI instead of \"nuget\" CLI. For future reference, this is the steps followed: make sure the classes you want to give access to are public. the description that will be shown in nuget when downloading is pulled from in the .csproj file beneath . Consider adding it. Also add the the url to the repository and some other info such as shown below: <RepositoryUrl>https://github.com/equinor/TimeSeriesAnalysis</RepositoryUrl> <RepositoryType>git</RepositoryType> <GeneratePackageOnBuild>true</GeneratePackageOnBuild> <PackageOutputPath>bin\\debug\\</PackageOutputPath> <Version>1.0.0</Version> <Authors>Steinar Elgsæter</Authors> <description>todo</description> recommend adding in information to the AssemblyInfo.cs before starting. a personal access token xxxxxxx needs to be generated for your user in github,and needs access to \"read:packages\", \"write:packages\" and \"repo\".organization access (authorize with SSO ) and then press \"authorize\" create a nuget.config file that defines \"github\" as a nuget destination: <configuration> <packageSources> <clear /> <add key=\"github\" value=\"https://nuget.pkg.github.com/equinor/index.json\" /> <add key=\"nuget\" value=\"https://api.nuget.org/v3/index.json\" /> </packageSources> <packageSourceCredentials> <github> <add key=\"Username\" value=\"yourgithubuser\" /> <add key=\"ClearTextPassword\" value=xxxxxxx\" /> </github> </packageSourceCredentials> </configuration> pacakges.nuget needs to be moved into project file *.csproj as items instead NuGet.Build.Tasks.Pack need to be added as a pacakage to project need to download nuget.exe and use it to push generated .nupkg file then to publish put the following two commands in a publish.bat file: nuget setapikey xxxxxxxx -source \"github\" nuget push bin\\Debug\\*.nupkg -source \"github\" -SkipDuplicate pause check that the script concludes with \"Your package was pushed\" and no error messages in yellow or red. notice that you need to iterate the version number in your .csproj file every time you push a new version of the package. Warning Make sure that you do not check-in the nuget.config file you create, as it contains a secret token. Add nuget.config to your git ignore file. Nuget package download how-to To use this nuget pacakge, you need to incldue the nuget.config file above in the solution that intends to pull down the package. You can then select github as the package source in Visual Studio \"Manage Nuget packages for Solution\"."
  },
  "articles/nuget_setup.html": {
    "href": "articles/nuget_setup.html",
    "title": "Setting up NuGet | TimeSeriesAnalysis reference documentation",
    "keywords": "Setting up NuGet TimeSeriesAnalysis uses NuGet to retrieve pre-compiled open-source packages on which it is based. NuGet can be set up in several different ways. TimeSeriesAnalysis uses the PackageReference type of configuration, in which NuGet configuration is stored in TimeSeriesAnalysis.csprocj . Note NuGet will not create a local packages subfolder upon a NuGet restore .Instead it creates a global package folder on your computer in the folder %userprofile%\\.nuget\\packages . In some cases it is insightful to examine the contents of this folder if you are having any NuGet issues. In Visual Studio , examine the menu TOOLS>NuGet Package Manager>Package Manager Settings . You should have the following selected: Allow NuGet to download missing packages (should be Checked ) Automatically check for missing packages during build in Visual Studio (should be Checked ) Default package management format should be PacakgeReference Note If you are having issues with NuGet, you can try pressing Clear All NuGet Cache(s) in the above dialog box. Solution Explorer>Solution TimeSeries analysis(right click)>Restore NuGet packages should run with zero errors (observe the Output>Package Manger for possible error) messages."
  },
  "articles/plot_setup.html": {
    "href": "articles/plot_setup.html",
    "title": "Setting up plots | TimeSeriesAnalysis reference documentation",
    "keywords": "Setting up plots If you have set up plotting correctly, you should be able to run the \"PlotUnitTests\" test from the Test Explorer in Visual Studio and plots should appear in a new browser window. For plotting to work you need four prerequisites Chrome must installed in C:\\Program Files (x86)\\Google\\Chrome\\Application\\chrome.exe you need to be running a local http-server, with a subfolder plotly that contains the javscript files in the \"www\\plotly\" subfolder in the TimeSeriesAnalysis repository the folder C:\\inetpub\\wwwroot\\plotly\\Data needs to exist on your computer, as data will be written in here the front-end javascript code needs to find the time-series data in csv-files in its localhost\\plotly\\data folder. (if your http-server is serving antoher folder than C:\\inetpub\\wwwroot\\ up on localhost , you need to use mklink` to link this folder with the http-server's [root]\\plotly\\data`` folder ) Chrome Currently, plotting requires Chrome,and the project expects Chrome to be installed in the folder C:\\Program Files (x86)\\Google\\Chrome\\Application\\chrome.exe . Running a local HTTP-server In Windows, if you are not already running a http-server, the easiest way to install one may be to install Internet Information Services(IIS) . This is done from Control Panel->Windows Features and selecting Internet information Services in the menu that appears (requires Administrator priveleges). If setting up a new server, it is advantageous to map the folder c:\\inetpub . Serving up the \"plotly\" folder When running a local http-server for development, you will need to add the folder \"plotly\" to it. The preferable way to to this is to add a symbolic link to the TimeSeriesAnalysis folder rather than copying files, to allow for version control. Suppose that your TimeSeriesAnalysis source code is stored in C:\\appl\\source\\TimeSeriesAnalysis , and that you are running an http-sever that is hosting the folder C:\\inetpub to your localhost . In Windows : Start a command prompt (cmd.exe) session in Windows with administrator privileges and give the following command: mklink /D c:\\inetpub\\wwwroot\\plotly C:\\appl\\source\\TimeSeriesAnalysis\\www\\plotly Note Plotting using the Plot class will cause browser windows to open on localhost\\plotly\\index.html . This html-file expects to find javscript files CsvToTable.js , plotlyInterface.js and vendor\\plotly.min.js . vendor\\plotly.min.js is obtained from https://plotly.com/javascript/getting-started/ and you can swap the given file for other versions if needed. If necessary localhost\\plotly\\data needs to symbolically linked to c:/inetpub/www/plotly/data folder If your http-server is mapping \"c:\\inetpub\", then you will not need to do this step. TimeSeriesAnalysis will write data into C:\\inetpub\\plotly\\Data and it will thus be found by the javascript browser-side code and run to display your plots. If you are serving up another folder [PathXYZ] on your computer to localhost, and do not want to change this, you will have to make a symoblic link like so: mklink /D C:\\inetpub\\wwwroot\\plotly\\Data C:\\[PathXYZ]\\plotly\\Data Note It is also possible to pass a custom data folder path to Plot.FromList ."
  },
  "articles/sysid.html": {
    "href": "articles/sysid.html",
    "title": "| TimeSeriesAnalysis reference documentation",
    "keywords": ""
  },
  "articles/sysid_defaultmodel.html": {
    "href": "articles/sysid_defaultmodel.html",
    "title": "| TimeSeriesAnalysis reference documentation",
    "keywords": ""
  },
  "articles/unit_tests.html": {
    "href": "articles/unit_tests.html",
    "title": "Setting up and running unit tests | TimeSeriesAnalysis reference documentation",
    "keywords": "Setting up and running unit tests Note Unit tests are an important part of the documenting this class library, as they give examples of how to run the public interface of the library, and document the expected output. Thus, unit tests are worth studying even for users who do not intend to write or modify unit tests. Unit tests are implemented using NUnit 3. In Visual Studio you should be able to browse the unit tests in the window Tests>>Test Explorer . In the Test Explorer window, pressing Run All tests should cause all tests to turn green . In some cases, it may be that the tests appear grayed or or with a blue exclamation point beside them. That indicate an issue with the installation of the Nunit3TestAdapter package through NuGet, which is required for integration NUnit with Visual Studio. Note If you want to submit a pull request for new functionality, writing a new a unit test is required. Note Note that some tests related to plotting are Explicit , and will need be run one-by-one. This has been done this way as this tests require manual inspection, and to avoid drowning the user in plots when re-running unit tests."
  },
  "contributing.html": {
    "href": "contributing.html",
    "title": "Contributing | TimeSeriesAnalysis reference documentation",
    "keywords": "Contributing This project welcomes contributions and suggestions. We believe in collaboration. Collaboration with developers and users, vendors and educational institutions, partners and competitors. Within and outside our industry. When contributing to this repository, please first discuss the change you wish to make via issue, or by the GitHub discussions forum, or any other method with the owners of this repository before making a change. What kind of contributions? Expanding on capability of the array/matrix classes Array/Matrix/Vector classes do not contain every conceivable operation. If you find that the method you need is missing, addition of new methods that perform new operations are appreciated. Expanding on the (dynamic) system-identification tool set Do you have a great idea for how better to identify models for dynamic systems? If you would like to contribute your own method into the tool set, that sort of method is much appreciated. This library was initially developed with the DefaultProcessModel in mind, but is should be possible to extend the library with other process model parametrization. To do so, you should replicate how the DefautlProcessModel has been implemented, and your model classes should implement the interfaces specified. Expanding on the capability of the PID-controller It will always be possible to add more functionality to the PID-controller, to accommodate different types of advanced control that it may not currently support. Benchmarking and academic comparisons If you would like to compare and benchmark other methods in this project, such as the PID-controller or system identification, that would be much appreciated (even if the other methods you tried appear to be better). For academic use, this project could be used as a reference for academics who are developing their own methods. Bug fixes Any bugs you may find, you are encouraged to report using our issue tracker, and if you can propose a fix, that is much appreciated Pull request Proposed code changes to this project should be submitted for review as pull requests. Requirements for pull requests: pull request should only address a single feature/issue all existing tests should pass any new feature should be supported by at least one new unit tests, that both shows that the new feature works and documents how to use the new feature be available for questions of the reviewer. for complex methods such as those related to filtering, dynamic models or PID-control, unit tests should use the Plot class to plot the time-series that illustrate the test data sets used and the results of any new calculation. It is much easier to understand capability visually both for code review but also for other users."
  },
  "readme.html": {
    "href": "readme.html",
    "title": "TimeSeriesAnalysis | TimeSeriesAnalysis reference documentation",
    "keywords": "TimeSeriesAnalysis TimeSeriesAnalysis is a class library that allows you to work .NET efficiently with time-series that may include transients or dynamics . Why? Because the final product of many enterprise time-series applications(like control algorithms or dynamic simulators) is required to be implemented in .NET, why not create a toolbox streamline such development as much possible? With good tooling, it may even be possible to start early research/prototyping/data analysis directly in .NET, removing the need to port code later. In a rush: getting started check out the repository build. (Developed with Visual Studio 2019 ) open Test Explorer and read/run unit tests too examine capability and API of the class library did not work? Please refer to the detailed Getting started chapter in the documentation below. Documentation: Getting started, code examples and API reference documentation 🔴 TimeSeriesAnalysis reference documentation 🔴 Contributing This project welcomes contributions and suggestions. Please read CONTRIBUTING.md for details on our code of conduct, and the process for submitting pull requests. Discussion forum Questions related to TimeSeriesAnalysis can be posted in the github discussion pages . Authors and contact persons Steinar Elgsæter License TimeSeriesAnalysis is distributed under the MIT license ."
  }
}