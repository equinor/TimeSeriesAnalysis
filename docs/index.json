{
  "api/index.html": {
    "href": "api/index.html",
    "title": "PLACEHOLDER | TimeSeriesAnalysis reference documentation",
    "keywords": "PLACEHOLDER TODO: Add .NET projects to the src folder and run docfx to generate REAL API Documentation !"
  },
  "api/TimeSeriesAnalysis.Array2D.html": {
    "href": "api/TimeSeriesAnalysis.Array2D.html",
    "title": "Class Array2D | TimeSeriesAnalysis reference documentation",
    "keywords": "Class Array2D Non-generic 2D-array methods Inheritance System.Object Array2D Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : TimeSeriesAnalysis Assembly : TimeSeriesAnalysis.dll Syntax public static class Array2D Methods GetColumnParsedAsDateTime(String[,], Int32, String) Parses a column of strings in an array/matrix of strings Declaration public static DateTime[] GetColumnParsedAsDateTime(this string[, ] matrix, int columnNumber, string dateFormat) Parameters Type Name Description System.String [,] matrix a 2D-aray of strings System.Int32 columnNumber the index of the column to parse System.String dateFormat the DateTime dateformat,For the format of dateFormat, see https://docs.microsoft.com/en-us/dotnet/standard/base-types/custom-date-and-time-format-strings Returns Type Description System.DateTime []"
  },
  "api/TimeSeriesAnalysis.Array2D-1.html": {
    "href": "api/TimeSeriesAnalysis.Array2D-1.html",
    "title": "Class Array2D<T> | TimeSeriesAnalysis reference documentation",
    "keywords": "Class Array2D<T> Generic array operations that can be done on arrays of any type, for operators specific to numerical arrays(matrices) see Matrix.cs Inheritance System.Object Array2D<T> Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : TimeSeriesAnalysis Assembly : TimeSeriesAnalysis.dll Syntax public class Array2D<T> Type Parameters Name Description T Methods Append(T[][], T[]) Combine two arrays into a single array(increasing the number of rows) Declaration public static T[][] Append(T[][] array1, T[] vector) Parameters Type Name Description T[][] array1 T[] vector a vector Returns Type Description T[][] null if unsuccessful Combine(T[][], T[][]) Combine two arrays into a single array(increasing the number of rows) Declaration public static T[][] Combine(T[][] array1, T[][] array2) Parameters Type Name Description T[][] array1 T[][] array2 Returns Type Description T[][] null if unsuccessful Create(T[]) Create 2d-array with only a single column Declaration public static T[, ] Create(T[] columnArray) Parameters Type Name Description T[] columnArray Returns Type Description T[,] Created2DFromJagged(T[][]) Convert a jagged array to a 2d-array Declaration public static T[, ] Created2DFromJagged(T[][] matrix) Parameters Type Name Description T[][] matrix Returns Type Description T[,] CreateFromList(List<T[]>) Initializes a 2D array from a list of arrays representing each column in the array Declaration public static T[, ] CreateFromList(List<T[]> columnList) Parameters Type Name Description System.Collections.Generic.List <T[]> columnList Returns Type Description T[,] null if list columnList dimensions do not match CreateJaggedFrom2D(T[,]) Convert a 2D array into a jagged array Declaration public static T[][] CreateJaggedFrom2D(T[, ] matrix) Parameters Type Name Description T[,] matrix Returns Type Description T[][] CreateJaggedFromList(List<T[]>, List<Int32>) Convert a list of 1D arrays to a jagged array Declaration public static T[][] CreateJaggedFromList(List<T[]> listOfArrays, List<int> indicesToIgnore = null) Parameters Type Name Description System.Collections.Generic.List <T[]> listOfArrays System.Collections.Generic.List < System.Int32 > indicesToIgnore optionally, indices in each variable to ignore Returns Type Description T[][] null if unsuccessful Downsample(T[,], Int32) Downsample a matrix where times are rows and variables are columns Declaration public static T[, ] Downsample(T[, ] matrix, int downsampleFactor) Parameters Type Name Description T[,] matrix System.Int32 downsampleFactor Returns Type Description T[,] GetColumn(T[][], Int32) returns the column of the matrix with the given index Declaration public static T[] GetColumn(T[][] matrix, int columnNumber) Parameters Type Name Description T[][] matrix System.Int32 columnNumber Returns Type Description T[] GetColumn(T[,], Int32) returns the column of the matrix with the given index Declaration public static T[] GetColumn(T[, ] matrix, int columnNumber) Parameters Type Name Description T[,] matrix System.Int32 columnNumber Returns Type Description T[] GetColumns(T[,], Int32[]) returns all the columns correspoding to columnNumbers in a 2d-array Declaration public static T[, ] GetColumns(T[, ] matrix, int[] columnNumbers) Parameters Type Name Description T[,] matrix System.Int32 [] columnNumbers Returns Type Description T[,] GetRow(T[,], Int32) returns the row of the matrix with the given index as an vector Declaration public static T[] GetRow(T[, ] matrix, int rowNumber) Parameters Type Name Description T[,] matrix System.Int32 rowNumber Returns Type Description T[] Transpose(T[,]) transposes a 2d-array (rows are turned into columns and vice versa) Declaration public static T[, ] Transpose(T[, ] matrix) Parameters Type Name Description T[,] matrix Returns Type Description T[,]"
  },
  "api/TimeSeriesAnalysis.Array2DExtensionMethods.html": {
    "href": "api/TimeSeriesAnalysis.Array2DExtensionMethods.html",
    "title": "Class Array2DExtensionMethods | TimeSeriesAnalysis reference documentation",
    "keywords": "Class Array2DExtensionMethods Extension methods based on Array2D Inheritance System.Object Array2DExtensionMethods Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : TimeSeriesAnalysis Assembly : TimeSeriesAnalysis.dll Syntax public static class Array2DExtensionMethods Methods Convert2DtoJagged(Double[,]) Converts a 2d-array to a jagged array Declaration public static double[][] Convert2DtoJagged(this double[, ] matrix) Parameters Type Name Description System.Double [,] matrix Returns Type Description System.Double [][] GetColumn(Double[,], Int32) returns the column of a 2d-array of doubles corresponding to columnIndex(starts at zero) Declaration public static double[] GetColumn(this double[, ] matrix, int columnIndex) Parameters Type Name Description System.Double [,] matrix System.Int32 columnIndex Returns Type Description System.Double [] GetColumn(String[,], Int32) returns the column of a 2d-array of strings corresponding to columnIndex(starts at zero) Declaration public static string[] GetColumn(this string[, ] matrix, int columnIndex) Parameters Type Name Description System.String [,] matrix System.Int32 columnIndex Returns Type Description System.String [] GetColumnParsedAsDateTime(String[,], Int32, String) Parses a column in a 2d-array and returns the results as a vector of date-times. Declaration public static DateTime[] GetColumnParsedAsDateTime(this string[, ] matrix, int columnNumber, string dateFormat) Parameters Type Name Description System.String [,] matrix System.Int32 columnNumber System.String dateFormat Returns Type Description System.DateTime [] GetColumns(Double[,], Int32[]) Returns the columns corresponding to columnNumbers as a 2d-array Declaration public static double[, ] GetColumns(this double[, ] matrix, int[] columnNumbers) Parameters Type Name Description System.Double [,] matrix System.Int32 [] columnNumbers Returns Type Description System.Double [,] GetNColumns(Double[][]) Get number of columns Declaration public static int GetNColumns(this double[][] matrix) Parameters Type Name Description System.Double [][] matrix Returns Type Description System.Int32 GetNColumns(Double[,]) Return the number of columns of a 2d-matrix Declaration public static int GetNColumns(this double[, ] matrix) Parameters Type Name Description System.Double [,] matrix Returns Type Description System.Int32 GetNRows(Double[][]) Get nubmer of rows Declaration public static int GetNRows(this double[][] matrix) Parameters Type Name Description System.Double [][] matrix Returns Type Description System.Int32 GetNRows(Double[,]) Return the number of rows of a 2d-matrix Declaration public static int GetNRows(this double[, ] matrix) Parameters Type Name Description System.Double [,] matrix Returns Type Description System.Int32 GetRow(Double[,], Int32) returns the row of a 2d-array of doubles corresponding to columnIndex(starts at zero) Declaration public static double[] GetRow(this double[, ] matrix, int rowNumber) Parameters Type Name Description System.Double [,] matrix System.Int32 rowNumber Returns Type Description System.Double [] GetRow(String[,], Int32) returns the row of a 2d-array of strings corresponding to columnIndex(starts at zero) Declaration public static string[] GetRow(this string[, ] matrix, int rowNumber) Parameters Type Name Description System.String [,] matrix System.Int32 rowNumber Returns Type Description System.String [] GetRowsAfterIndex(DateTime[], Int32) Returns rows starting with rowIndex and onwards Declaration public static DateTime[] GetRowsAfterIndex(this DateTime[] array, int rowIndex) Parameters Type Name Description System.DateTime [] array System.Int32 rowIndex Returns Type Description System.DateTime [] GetRowsAfterIndex(Double[], Int32) Returns rows starting with rowIndex and onwards Declaration public static double[] GetRowsAfterIndex(this double[] array, int rowIndex) Parameters Type Name Description System.Double [] array System.Int32 rowIndex Returns Type Description System.Double [] GetRowsAfterIndex(Double[,], Int32) Returns rows starting with rowIndex and onwards Declaration public static double[, ] GetRowsAfterIndex(this double[, ] array, int rowIndex) Parameters Type Name Description System.Double [,] array System.Int32 rowIndex Returns Type Description System.Double [,] Transpose(Double[,]) Transposes a 2d-matrix. Declaration public static double[, ] Transpose(this double[, ] matrix) Parameters Type Name Description System.Double [,] matrix Returns Type Description System.Double [,] WriteColumn(Double[,], Int32, Double[]) overwrites the columin in matrix with the new column newColumnValues Declaration public static double[, ] WriteColumn(this double[, ] matrix, int colIdx, double[] newColumnValues) Parameters Type Name Description System.Double [,] matrix System.Int32 colIdx System.Double [] newColumnValues Returns Type Description System.Double [,]"
  },
  "api/TimeSeriesAnalysis.BandPass.html": {
    "href": "api/TimeSeriesAnalysis.BandPass.html",
    "title": "Class BandPass | TimeSeriesAnalysis reference documentation",
    "keywords": "Class BandPass Numerical band-pass filter based on LowPass This filter is in a recursive(feedback) IIR form that is simple to implement, has few coefficients, requires litte memory and computation. This filter is causal, meaning that for calculating the filtered value at time k it does not use future values such as k+1 , but this is at the expense of introducing a time-shift/phase-shift. LowPass HighPass MovingAvg Inheritance System.Object BandPass Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : TimeSeriesAnalysis Assembly : TimeSeriesAnalysis.dll Syntax public class BandPass Constructors BandPass(Double, Double) Declaration public BandPass(double TimeBase_s, double nanValue = -9999) Parameters Type Name Description System.Double TimeBase_s System.Double nanValue value to be treated as NaN Methods Filter(Double, Double, Double, Int32, Boolean) Adds a single data point to the filter Declaration public double Filter(double signal, double lpFilterTc_s, double hpFilterTc_s, int order = 1, bool doReset = false) Parameters Type Name Description System.Double signal data point System.Double lpFilterTc_s low-passfilter time constant in seconds System.Double hpFilterTc_s high-passfilter time constant in seconds System.Int32 order filter order, either 1 or 2 is supported System.Boolean doReset usually false, setting to true causes filter to reset to the value of signal Returns Type Description System.Double Filter(Double[], Double, Double, Int32) Filter an entire time-series in one command Declaration public double[] Filter(double[] signal, double lpFilterTc_s, double hpFilterTc_s, int order = 1) Parameters Type Name Description System.Double [] signal the vector of the entire time-series to be filtered System.Double lpFilterTc_s filter time constant System.Double hpFilterTc_s filter time constant System.Int32 order filter order, either 1 or 2 Returns Type Description System.Double [] a vector of the filtered time-series"
  },
  "api/TimeSeriesAnalysis.CorrelationCalculator.html": {
    "href": "api/TimeSeriesAnalysis.CorrelationCalculator.html",
    "title": "Class CorrelationCalculator | TimeSeriesAnalysis reference documentation",
    "keywords": "Class CorrelationCalculator Inheritance System.Object CorrelationCalculator Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : TimeSeriesAnalysis Assembly : TimeSeriesAnalysis.dll Syntax public class CorrelationCalculator Methods Calculate(Double[], Double[], List<Int32>) Calculate the correlation factor between signal1 and signal 2. Declaration public static double Calculate(double[] signal1, double[] signal2, List<int> indicesToIgnore = null) Parameters Type Name Description System.Double [] signal1 System.Double [] signal2 System.Collections.Generic.List < System.Int32 > indicesToIgnore Optionally ignore indices in this list from signal1 and signal2 Returns Type Description System.Double Calculate(String, TimeSeriesDataSet, List<Int32>) Calculates correlation factors [-1,1] for a signal against all other signals in the dataset (this corresponds to one row or one column of the covariance matrix) Declaration public static Dictionary<string, double> Calculate(string signalName, TimeSeriesDataSet dataSet, List<int> indicesToIgnore = null) Parameters Type Name Description System.String signalName TimeSeriesDataSet dataSet System.Collections.Generic.List < System.Int32 > indicesToIgnore these indices are ignored in the calculation (pre-filtered bad or out of range values) Returns Type Description System.Collections.Generic.Dictionary < System.String , System.Double > CalculateAndOrder(String, TimeSeriesDataSet, Double, Double) Calculates correlation factors [-1,1] for a signal against all other signals in the dataset returning the results in a list from highest to lowest score absolute correlation factor Declaration public static List<CorrelationObject> CalculateAndOrder(string mainSignalName, TimeSeriesDataSet dataSet, double minimumCorrCoeffToDoTimeshiftCalc = 0.4, double minimumRsqAbs = 10) Parameters Type Name Description System.String mainSignalName TimeSeriesDataSet dataSet the dataset, which must have a correctly set timestamps in order to estimate time constants System.Double minimumCorrCoeffToDoTimeshiftCalc calculate time-shift for every corr coeff that is above this threshold(0.0-1.0) System.Double minimumRsqAbs for a time-shift to be valid, the resulting model nees to have Rsq over this threshold Returns Type Description System.Collections.Generic.List < CorrelationObject > a CorrelateTwoVectors(Double[], Double[], List<Int32>) Declaration public static double CorrelateTwoVectors(double[] v1, double[] v2, List<int> indicesToIgnore) Parameters Type Name Description System.Double [] v1 System.Double [] v2 System.Collections.Generic.List < System.Int32 > indicesToIgnore Returns Type Description System.Double"
  },
  "api/TimeSeriesAnalysis.CorrelationObject.html": {
    "href": "api/TimeSeriesAnalysis.CorrelationObject.html",
    "title": "Class CorrelationObject | TimeSeriesAnalysis reference documentation",
    "keywords": "Class CorrelationObject Inheritance System.Object CorrelationObject Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : TimeSeriesAnalysis Assembly : TimeSeriesAnalysis.dll Syntax public class CorrelationObject Constructors CorrelationObject(String, Double, Nullable<Double>, Nullable<Double>) Declaration public CorrelationObject(string name, double value, double? timeConstant_s = null, double? timeDelay_s = null) Parameters Type Name Description System.String name System.Double value System.Nullable < System.Double > timeConstant_s System.Nullable < System.Double > timeDelay_s Fields correlationFactor Declaration public double correlationFactor Field Value Type Description System.Double signalName Declaration public string signalName Field Value Type Description System.String timeConstant_s Declaration public double? timeConstant_s Field Value Type Description System.Nullable < System.Double > timeDelay_s Declaration public double? timeDelay_s Field Value Type Description System.Nullable < System.Double >"
  },
  "api/TimeSeriesAnalysis.Dynamic.ClosedLoopUnitIdentifier.html": {
    "href": "api/TimeSeriesAnalysis.Dynamic.ClosedLoopUnitIdentifier.html",
    "title": "Class ClosedLoopUnitIdentifier | TimeSeriesAnalysis reference documentation",
    "keywords": "Class ClosedLoopUnitIdentifier Identification that attempts to identify a unit model jointly with estimating the additive signal acting on the output(disturbance signal) yet is counter-acted by closed-loop (feedback)control, such as with PID-control. The approach requires combining information in the measured output signal with the information in the manipulated variable(determined by active control) that is inputted into the process In order to accomplish this estimation, the process model and the disturbance signal are estimated together. Inheritance System.Object ClosedLoopUnitIdentifier Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : TimeSeriesAnalysis.Dynamic Assembly : TimeSeriesAnalysis.dll Syntax public class ClosedLoopUnitIdentifier Methods ClosedLoopSim(UnitDataSet, UnitParameters, PidParameters, Double[], String) Declaration public bool ClosedLoopSim(UnitDataSet unitData, UnitParameters modelParams, PidParameters pidParams, double[] disturbance, string name) Parameters Type Name Description UnitDataSet unitData UnitParameters modelParams PidParameters pidParams System.Double [] disturbance System.String name Returns Type Description System.Boolean Identify(UnitDataSet, PidParameters, Int32) Identify the unit model of a closed-loop system and the distrubance (additive output signal) Declaration public (UnitModel, double[]) Identify(UnitDataSet dataSet, PidParameters pidParams = null, int pidInputIdx = 0) Parameters Type Name Description UnitDataSet dataSet the unit data set, containing both the input to the unit and the output PidParameters pidParams if the setpoint of the control changes in the time-set, then the paramters of pid control need to be given. System.Int32 pidInputIdx the index of the PID-input to the unit model Returns Type Description System.ValueTuple < UnitModel , System.Double []> The unit model, with the name of the newly created disturbance added to the additiveInputSignals Remarks Currently always assumes that PID-index is first index of unit model(can be improved)"
  },
  "api/TimeSeriesAnalysis.Dynamic.Comment.html": {
    "href": "api/TimeSeriesAnalysis.Dynamic.Comment.html",
    "title": "Class Comment | TimeSeriesAnalysis reference documentation",
    "keywords": "Class Comment Inheritance System.Object Comment Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : TimeSeriesAnalysis.Dynamic Assembly : TimeSeriesAnalysis.dll Syntax public class Comment Constructors Comment(String, DateTime, String, Double) Declaration public Comment(string author, DateTime date, string comment, double plantScore = 0) Parameters Type Name Description System.String author System.DateTime date System.String comment System.Double plantScore Fields author Declaration public string author Field Value Type Description System.String comment Declaration public string comment Field Value Type Description System.String date Declaration public DateTime date Field Value Type Description System.DateTime plantScore Declaration public double plantScore Field Value Type Description System.Double"
  },
  "api/TimeSeriesAnalysis.Dynamic.ConnectionParser.html": {
    "href": "api/TimeSeriesAnalysis.Dynamic.ConnectionParser.html",
    "title": "Class ConnectionParser | TimeSeriesAnalysis reference documentation",
    "keywords": "Class ConnectionParser Class that tracks which model is connected to which in a set of models. This is important when traversing the models when simulating with the PlantSimulator , as these models need to be run in a specific order Inheritance System.Object ConnectionParser Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : TimeSeriesAnalysis.Dynamic Assembly : TimeSeriesAnalysis.dll Syntax public class ConnectionParser Constructors ConnectionParser() Constructor Declaration public ConnectionParser() Fields connections Declaration [JsonInclude] public List<(string, string)> connections Field Value Type Description System.Collections.Generic.List < System.ValueTuple < System.String , System.String >> Methods FindComputationalLoops(Dictionary<String, ISimulatableModel>) Parses models and determines if there are co-dependent models Declaration public Dictionary<string, List<string>> FindComputationalLoops(Dictionary<string, ISimulatableModel> modelDict) Parameters Type Name Description System.Collections.Generic.Dictionary < System.String , ISimulatableModel > modelDict Returns Type Description System.Collections.Generic.Dictionary < System.String , System.Collections.Generic.List < System.String >> a dictionary with an ID and a list of all involved modelIDs GetAllDownstreamModelIDs(String) Get all the models which are connected to a given model one level directly downstream of it Declaration public List<string> GetAllDownstreamModelIDs(string modelID) Parameters Type Name Description System.String modelID Returns Type Description System.Collections.Generic.List < System.String > GetAllUpstreamModels(String) Get all the models which are connected to a given model one level directly upstream of it Declaration public List<string> GetAllUpstreamModels(string modelID) Parameters Type Name Description System.String modelID Returns Type Description System.Collections.Generic.List < System.String > GetUnitModelControlledByPID(String, Dictionary<String, ISimulatableModel>) Get unit model controlled by PDI Declaration public string GetUnitModelControlledByPID(string pidModelID, Dictionary<string, ISimulatableModel> modelDict) Parameters Type Name Description System.String pidModelID System.Collections.Generic.Dictionary < System.String , ISimulatableModel > modelDict Returns Type Description System.String returns null if no model is found GetUpstreamPIDIds(String, Dictionary<String, ISimulatableModel>) Get the ID of the PID-controller that is upstream a given modelID Declaration public string[] GetUpstreamPIDIds(string modelID, Dictionary<string, ISimulatableModel> modelDict) Parameters Type Name Description System.String modelID System.Collections.Generic.Dictionary < System.String , ISimulatableModel > modelDict Returns Type Description System.String [] HasUpstreamPID(String, Dictionary<String, ISimulatableModel>) Query if the model has an upstream PID-model. Declaration public bool HasUpstreamPID(string modelID, Dictionary<string, ISimulatableModel> modelDict) Parameters Type Name Description System.String modelID System.Collections.Generic.Dictionary < System.String , ISimulatableModel > modelDict Returns Type Description System.Boolean InitAndDetermineCalculationOrderOfModels(Dictionary<String, ISimulatableModel>) Determine the order in which the models must be solved Declaration public (List<string>, Dictionary<string, List<string>>) InitAndDetermineCalculationOrderOfModels(Dictionary<string, ISimulatableModel> modelDict) Parameters Type Name Description System.Collections.Generic.Dictionary < System.String , ISimulatableModel > modelDict Returns Type Description System.ValueTuple < System.Collections.Generic.List < System.String >, System.Collections.Generic.Dictionary < System.String , System.Collections.Generic.List < System.String >>> returns the langword_csharp_string of sorted model IDs, the order in which modelDict models are to be run. If the plant contains computational loops, the IDs of the computational loops are also in these lists instead of the indivudal models."
  },
  "api/TimeSeriesAnalysis.Dynamic.DisturbanceIdentifier.html": {
    "href": "api/TimeSeriesAnalysis.Dynamic.DisturbanceIdentifier.html",
    "title": "Class DisturbanceIdentifier | TimeSeriesAnalysis reference documentation",
    "keywords": "Class DisturbanceIdentifier An algorithm that attempts to re-create the additive output disturbance acting on a signal Y while PID-control attempts to counter-act the disturbance by adjusting its manipulated output u. Inheritance System.Object DisturbanceIdentifier Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : TimeSeriesAnalysis.Dynamic Assembly : TimeSeriesAnalysis.dll Syntax public class DisturbanceIdentifier Methods EstDisturbanceBasedOnProcessModel(UnitDataSet, UnitModel, Int32) Only uses Y_meas and U in unitDataSet, i.e. does not consider feedback Declaration public static DisturbanceIdResult EstDisturbanceBasedOnProcessModel(UnitDataSet unitDataSet, UnitModel unitModel, int inputIdx = 0) Parameters Type Name Description UnitDataSet unitDataSet UnitModel unitModel System.Int32 inputIdx Returns Type Description DisturbanceIdResult EstimateDisturbance(UnitDataSet, UnitModel, Int32, PidParameters, Boolean) Estimates the disturbance time-series over a given unit data set given an estimate of the unit model (reference unit model) for a closed loop system. Declaration public static DisturbanceIdResult EstimateDisturbance(UnitDataSet unitDataSet_raw, UnitModel unitModel, int pidInputIdx = 0, PidParameters pidParams = null, bool doDebugPlot = false) Parameters Type Name Description UnitDataSet unitDataSet_raw UnitModel unitModel the estimate of the unit System.Int32 pidInputIdx PidParameters pidParams System.Boolean doDebugPlot Returns Type Description DisturbanceIdResult"
  },
  "api/TimeSeriesAnalysis.Dynamic.DisturbanceIdResult.html": {
    "href": "api/TimeSeriesAnalysis.Dynamic.DisturbanceIdResult.html",
    "title": "Class DisturbanceIdResult | TimeSeriesAnalysis reference documentation",
    "keywords": "Class DisturbanceIdResult Internal class to store a single sub-run of the DisturnanceIdentifierInternal Inheritance System.Object DisturbanceIdResult Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : TimeSeriesAnalysis.Dynamic Assembly : TimeSeriesAnalysis.dll Syntax public class DisturbanceIdResult Constructors DisturbanceIdResult(Int32) Declaration public DisturbanceIdResult(int N) Parameters Type Name Description System.Int32 N DisturbanceIdResult(UnitDataSet) Declaration public DisturbanceIdResult(UnitDataSet dataSet) Parameters Type Name Description UnitDataSet dataSet Fields adjustedUnitDataSet Declaration public UnitDataSet adjustedUnitDataSet Field Value Type Description UnitDataSet d_est Declaration public double[] d_est Field Value Type Description System.Double [] d_HF Declaration public double[] d_HF Field Value Type Description System.Double [] d_LF Declaration public double[] d_LF Field Value Type Description System.Double [] estPidProcessGain Declaration public double estPidProcessGain Field Value Type Description System.Double isAllZero Declaration public bool isAllZero Field Value Type Description System.Boolean N Declaration public int N Field Value Type Description System.Int32 zeroReason Declaration public DisturbanceSetToZeroReason zeroReason Field Value Type Description DisturbanceSetToZeroReason Methods Copy() Declaration public DisturbanceIdResult Copy() Returns Type Description DisturbanceIdResult SetToZero() Declaration public void SetToZero()"
  },
  "api/TimeSeriesAnalysis.Dynamic.DisturbanceSetToZeroReason.html": {
    "href": "api/TimeSeriesAnalysis.Dynamic.DisturbanceSetToZeroReason.html",
    "title": "Enum DisturbanceSetToZeroReason | TimeSeriesAnalysis reference documentation",
    "keywords": "Enum DisturbanceSetToZeroReason Namespace : TimeSeriesAnalysis.Dynamic Assembly : TimeSeriesAnalysis.dll Syntax public enum DisturbanceSetToZeroReason Fields Name Description NotRunYet SetpointWasDetected UnitSimulatorUnableToRun"
  },
  "api/TimeSeriesAnalysis.Dynamic.Divide.html": {
    "href": "api/TimeSeriesAnalysis.Dynamic.Divide.html",
    "title": "Class Divide | TimeSeriesAnalysis reference documentation",
    "keywords": "Class Divide Simulatable divide block, requires exactly two inputs Inheritance System.Object ModelBaseClass Divide Implements ISimulatableModel Inherited Members ModelBaseClass.ID ModelBaseClass.ModelInputIDs ModelBaseClass.additiveInputIDs ModelBaseClass.outputID ModelBaseClass.outputIdentID ModelBaseClass.processModelType ModelBaseClass.comment ModelBaseClass.x ModelBaseClass.y ModelBaseClass.color ModelBaseClass.GetID() ModelBaseClass.SetID(String) ModelBaseClass.SetProcessModelType(ModelType) ModelBaseClass.GetProcessModelType() ModelBaseClass.SetInputIDs(String[], Nullable<Int32>) ModelBaseClass.AddSignalToOutput(String) ModelBaseClass.GetModelInputIDs() ModelBaseClass.GetAdditiveInputIDs() ModelBaseClass.GetBothKindsOfInputIDs() ModelBaseClass.SetOutputID(String) ModelBaseClass.GetOutputID() ModelBaseClass.GetOutputIdentID() ModelBaseClass.GetLengthOfInputVector() System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : TimeSeriesAnalysis.Dynamic Assembly : TimeSeriesAnalysis.dll Syntax public class Divide : ModelBaseClass, ISimulatableModel Constructors Divide(DivideParameters, String) Constructor Declaration public Divide(DivideParameters divideParameters, string ID) Parameters Type Name Description DivideParameters divideParameters System.String ID Fields divideParameters Declaration public DivideParameters divideParameters Field Value Type Description DivideParameters Methods GetOutputSignalType() Gives the type of the output signal Declaration public override SignalType GetOutputSignalType() Returns Type Description SignalType Overrides ModelBaseClass.GetOutputSignalType() GetSteadyStateInput(Double, Int32, Double[]) Not implemented Declaration public double? GetSteadyStateInput(double y0, int inputIdx = 0, double[] givenInputValues = null) Parameters Type Name Description System.Double y0 System.Int32 inputIdx System.Double [] givenInputValues Returns Type Description System.Nullable < System.Double > GetSteadyStateOutput(Double[]) Get the steady state value of the model output Declaration public double? GetSteadyStateOutput(double[] u0) Parameters Type Name Description System.Double [] u0 vector of inputs for which the steady state is to be calculated Returns Type Description System.Nullable < System.Double > the steady-state value, if it is not possible to calculate, a null is returned IsModelSimulatable(out String) Declaration public bool IsModelSimulatable(out string explain) Parameters Type Name Description System.String explain Returns Type Description System.Boolean Iterate(Double[], Double, Double) Iterate simulation Declaration public double[] Iterate(double[] inputsU, double timeBase_s, double badDataID = -9999) Parameters Type Name Description System.Double [] inputsU System.Double timeBase_s System.Double badDataID Returns Type Description System.Double [] WarmStart(Double[], Double) Not implemented Declaration public void WarmStart(double[] inputs, double output) Parameters Type Name Description System.Double [] inputs System.Double output Implements ISimulatableModel"
  },
  "api/TimeSeriesAnalysis.Dynamic.DivideParameters.html": {
    "href": "api/TimeSeriesAnalysis.Dynamic.DivideParameters.html",
    "title": "Class DivideParameters | TimeSeriesAnalysis reference documentation",
    "keywords": "Class DivideParameters Paramters of the divide model Inheritance System.Object ModelParametersBaseClass DivideParameters Inherited Members ModelParametersBaseClass.Fitting System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : TimeSeriesAnalysis.Dynamic Assembly : TimeSeriesAnalysis.dll Syntax public class DivideParameters : ModelParametersBaseClass Constructors DivideParameters() Declaration public DivideParameters() Properties NanValueIn protect from specific bad value Declaration public double NanValueIn { get; set; } Property Value Type Description System.Double NanValueOut value to give if divideByZero Declaration public double NanValueOut { get; set; } Property Value Type Description System.Double Y_max maximum output value Declaration public double Y_max { get; set; } Property Value Type Description System.Double Y_min minimum output value Declaration public double Y_min { get; set; } Property Value Type Description System.Double"
  },
  "api/TimeSeriesAnalysis.Dynamic.FittingInfo.html": {
    "href": "api/TimeSeriesAnalysis.Dynamic.FittingInfo.html",
    "title": "Class FittingInfo | TimeSeriesAnalysis reference documentation",
    "keywords": "Class FittingInfo FittingInfo Be careful as the objective function is different for the static estimation that considers the absolute values, while dynamic estimation considers \"diffs\"- for this reason it is best to use RsqDiff and RsqAbs when comparing different model runs which can be a combination fo static and dynamic Inheritance System.Object FittingInfo Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : TimeSeriesAnalysis.Dynamic Assembly : TimeSeriesAnalysis.dll Syntax public class FittingInfo Properties EndTime End time of fitting data set Declaration public DateTime EndTime { get; set; } Property Value Type Description System.DateTime FitScorePrc A score that is 100% if model describes all variations and 0% if model is no better at describing variation than the flat average line. Negative if the model is worse than a flat average line. Declaration public double FitScorePrc { get; set; } Property Value Type Description System.Double NFittingBadDataPoints Number of bad data points ignored during fitting Declaration public double NFittingBadDataPoints { get; set; } Property Value Type Description System.Double NFittingTotalDataPoints Number of total data points (good and bad) available for fitting Declaration public double NFittingTotalDataPoints { get; set; } Property Value Type Description System.Double ObjFunValAbs The value of the objective function during fitting, lower is better(used to choose among models) This is the R-squared of the \"absolute\" sum(ymeas[k]-ymod[k-1]) > Declaration public double ObjFunValAbs { get; set; } Property Value Type Description System.Double ObjFunValDiff The value of the objective function during fitting, lower is better(used to choose among models) This is the R-squared of the \"differences\" sum(ymeas[k]-ymeas[k-1] -(ymod[k]-ymod[k-1]) ) > Declaration public double ObjFunValDiff { get; set; } Property Value Type Description System.Double RsqAbs The value of the R2 or root mean square This is the R-squared of the \"absolute\" sum(ymeas[k] - ymod[k] ) > Declaration public double RsqAbs { get; set; } Property Value Type Description System.Double RsqDiff The value of the R2 or root mean square of fitting,higher is better (used to choose among models) This is the R-squared of the \"differences\" sum(ymeas[k]-ymeas[k-1] -(ymod[k]-ymod[k-1]) ) > Declaration public double RsqDiff { get; set; } Property Value Type Description System.Double SolverID A string that identifies the solver that was used to find the model Declaration public string SolverID { get; set; } Property Value Type Description System.String StartTime Start time of fitting data set Declaration public DateTime StartTime { get; set; } Property Value Type Description System.DateTime WasAbleToIdentify True if identification was able to identify, otherwise false. Declaration public bool WasAbleToIdentify { get; set; } Property Value Type Description System.Boolean Methods CalcCommonFitMetricsFromDataset(UnitDataSet, List<Int32>) NB! this code seems to have an error with negative rsqdiff for cases when there yIndicesToIgnore is not empty. It may be preferable to use the output of the regression, as this avoids duplicating logic. Declaration public void CalcCommonFitMetricsFromDataset(UnitDataSet dataSet, List<int> yIndicesToIgnore) Parameters Type Name Description UnitDataSet dataSet System.Collections.Generic.List < System.Int32 > yIndicesToIgnore"
  },
  "api/TimeSeriesAnalysis.Dynamic.FittingSpecs.html": {
    "href": "api/TimeSeriesAnalysis.Dynamic.FittingSpecs.html",
    "title": "Class FittingSpecs | TimeSeriesAnalysis reference documentation",
    "keywords": "Class FittingSpecs variables that are set prior to fitting. Inheritance System.Object FittingSpecs GainSchedFittingSpecs Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : TimeSeriesAnalysis.Dynamic Assembly : TimeSeriesAnalysis.dll Syntax public class FittingSpecs Constructors FittingSpecs() Declaration public FittingSpecs() FittingSpecs(Double[], Double[]) Declaration public FittingSpecs(double[] u0, double[] uNorm) Parameters Type Name Description System.Double [] u0 System.Double [] uNorm Fields U_max_fit the maximum allowed input value(if set to NaN, then fitting considers all data) Declaration public double[] U_max_fit Field Value Type Description System.Double [] U_min_fit The minimum input value(if set to NaN,then fitting considers all data) Declaration public double[] U_min_fit Field Value Type Description System.Double [] u0 A vector of values subtracted form u to set the local opertating point: (u-u0)/uNorm Can be set to null, in which case no value is subtracted from u Declaration public double[] u0 Field Value Type Description System.Double [] uNorm A vector of values used to normalize u internally in the model by the equation: (u-u0)/uNorm Can be set to null, in which case u is left un-normalized. Declaration public double[] uNorm Field Value Type Description System.Double [] Y_max_fit all values above this threshold are ignored during fitting(if set to NaN, no maximum is applied) Declaration public double? Y_max_fit Field Value Type Description System.Nullable < System.Double > Y_min_fit all values below this threshold are ignored during fitting(if set to NaN, no minimum is applied) Declaration public double? Y_min_fit Field Value Type Description System.Nullable < System.Double >"
  },
  "api/TimeSeriesAnalysis.Dynamic.GainSchedDataSet.html": {
    "href": "api/TimeSeriesAnalysis.Dynamic.GainSchedDataSet.html",
    "title": "Class GainSchedDataSet | TimeSeriesAnalysis reference documentation",
    "keywords": "Class GainSchedDataSet The data for a porition of a process, containg only one output and one or multiple inputs that influence it Inheritance System.Object GainSchedDataSet Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : TimeSeriesAnalysis.Dynamic Assembly : TimeSeriesAnalysis.dll Syntax public class GainSchedDataSet Constructors GainSchedDataSet(String) Constructor for data set without inputs - for \"autonomous\" processes such as sinusoids, rand walks or other disturbancs. Declaration public GainSchedDataSet(string name = null) Parameters Type Name Description System.String name optional internal name of dataset GainSchedDataSet((Double[], DateTime[]), (Double[], DateTime[]), String) Create a dataset for single-input system from two signals that have separate but overlapping time-series(each given as value-date tuples) Declaration public GainSchedDataSet((double[], DateTime[]) u, (double[], DateTime[]) y_meas, string name = null) Parameters Type Name Description System.ValueTuple < System.Double [], System.DateTime []> u tuple of values and dates describing u System.ValueTuple < System.Double [], System.DateTime []> y_meas tuple of values and dates describing y System.String name name of dataset GainSchedDataSet(GainSchedDataSet) Create a copy of an existing data set Declaration public GainSchedDataSet(GainSchedDataSet otherDataSet) Parameters Type Name Description GainSchedDataSet otherDataSet GainSchedDataSet(GainSchedDataSet, Int32) Create a downsampled copy of an existing data set Declaration public GainSchedDataSet(GainSchedDataSet originalDataSet, int downsampleFactor) Parameters Type Name Description GainSchedDataSet originalDataSet System.Int32 downsampleFactor factor by which to downsample the original dataset Fields IndicesToIgnore Indices that are ignored in Y during fitting. Declaration public List<int> IndicesToIgnore Field Value Type Description System.Collections.Generic.List < System.Int32 > Properties BadDataID Some systems for storing data do not support \"NaN\", but instead some other magic value is reserved for indicating that a value is bad or missing. Declaration public double BadDataID { get; set; } Property Value Type Description System.Double D Additve output disturbance D (Y = X+ D) Declaration public double[] D { get; set; } Property Value Type Description System.Double [] ProcessName Name Declaration public string ProcessName { get; } Property Value Type Description System.String Times Timestamps Declaration public DateTime[] Times { get; set; } Property Value Type Description System.DateTime [] U Input U (given) Declaration public double[, ] U { get; set; } Property Value Type Description System.Double [,] U_sim Input U(simulated) - in the case of PID-control Declaration public double[, ] U_sim { get; set; } Property Value Type Description System.Double [,] Warnings list of warings during identification Declaration public List<GainSchedWarnings> Warnings { get; set; } Property Value Type Description System.Collections.Generic.List < GainSchedWarnings > Y_meas Output Y (measured) Declaration public double[] Y_meas { get; set; } Property Value Type Description System.Double [] Y_setpoint Setpoint - (if sub-process includes a PID-controller) Declaration public double[] Y_setpoint { get; set; } Property Value Type Description System.Double [] Y_sim Output Y (simulated) Declaration public double[] Y_sim { get; set; } Property Value Type Description System.Double [] Methods CreateTimeStamps(Double, Nullable<DateTime>) Declaration public void CreateTimeStamps(double timeBase_s, DateTime? t0 = null) Parameters Type Name Description System.Double timeBase_s System.Nullable < System.DateTime > t0 DetermineIndicesToIgnore(FittingSpecs) Declaration public void DetermineIndicesToIgnore(FittingSpecs fittingSpecs) Parameters Type Name Description FittingSpecs fittingSpecs GetAverageU() Get the average value of each input in the dataset. This is useful when defining model local around a working point. Declaration public double[] GetAverageU() Returns Type Description System.Double [] an array of averages, each corrsponding to one column of U. Returns null if it was not possible to calculate averages GetNumDataPoints() Declaration public int GetNumDataPoints() Returns Type Description System.Int32 GetTimeBase() Gets the time between samples in seconds, returns zero if times are not set Declaration public double GetTimeBase() Returns Type Description System.Double GetTimeSpan() Get the time spanned by the dataset Declaration public TimeSpan GetTimeSpan() Returns Type Description System.TimeSpan The time spanned by the dataset, or null if times are not set SetInputUFitMaxAndMin(Double[], Double[]) Tags indices to be removed if either of the inputs are outside the range defined by [uMinFit,uMaxFit]. uMinFit,uMaxFit may include NaN or BadDataID for values if no max/min applies to the specific input Declaration public void SetInputUFitMaxAndMin(double[] uMinFit, double[] uMaxFit) Parameters Type Name Description System.Double [] uMinFit vector of minimum values for each element in U System.Double [] uMaxFit vector of maximum values for each element in U"
  },
  "api/TimeSeriesAnalysis.Dynamic.GainSchedFittingSpecs.html": {
    "href": "api/TimeSeriesAnalysis.Dynamic.GainSchedFittingSpecs.html",
    "title": "Class GainSchedFittingSpecs | TimeSeriesAnalysis reference documentation",
    "keywords": "Class GainSchedFittingSpecs variables that are set prior to fitting. Inheritance System.Object FittingSpecs GainSchedFittingSpecs Inherited Members FittingSpecs.u0 FittingSpecs.uNorm FittingSpecs.Y_min_fit FittingSpecs.Y_max_fit FittingSpecs.U_min_fit FittingSpecs.U_max_fit System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : TimeSeriesAnalysis.Dynamic Assembly : TimeSeriesAnalysis.dll Syntax public class GainSchedFittingSpecs : FittingSpecs Constructors GainSchedFittingSpecs() Declaration public GainSchedFittingSpecs() Fields uGainScheduledInputIndex for gain-scheduling, thresholds of u for changing between gains. Default is 0, i.e. first input is used for gain-scheduling. Declaration public int uGainScheduledInputIndex Field Value Type Description System.Int32 uGainThresholds for gain-scheduling, thresholds of u for changing between gains. Declaration public double[] uGainThresholds Field Value Type Description System.Double [] uTimeConstantThresholds for gain-scheduling, thresholds of u for changing between gains. Declaration public double[] uTimeConstantThresholds Field Value Type Description System.Double []"
  },
  "api/TimeSeriesAnalysis.Dynamic.GainSchedIdentifier.html": {
    "href": "api/TimeSeriesAnalysis.Dynamic.GainSchedIdentifier.html",
    "title": "Class GainSchedIdentifier | TimeSeriesAnalysis reference documentation",
    "keywords": "Class GainSchedIdentifier Inheritance System.Object GainSchedIdentifier Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : TimeSeriesAnalysis.Dynamic Assembly : TimeSeriesAnalysis.dll Syntax public static class GainSchedIdentifier Methods Identify(UnitDataSet, GainSchedFittingSpecs) Declaration public static GainSchedParameters Identify(UnitDataSet dataSet, GainSchedFittingSpecs gsFittingSpecs = null) Parameters Type Name Description UnitDataSet dataSet GainSchedFittingSpecs gsFittingSpecs Returns Type Description GainSchedParameters IdentifyGainsForGivenThresholds(UnitDataSet, GainSchedFittingSpecs) Identify a model when a given set of thresholds is already given in the supplied gsFittingSpecs Declaration public static GainSchedParameters IdentifyGainsForGivenThresholds(UnitDataSet dataSet, GainSchedFittingSpecs gsFittingSpecs) Parameters Type Name Description UnitDataSet dataSet GainSchedFittingSpecs gsFittingSpecs Returns Type Description GainSchedParameters"
  },
  "api/TimeSeriesAnalysis.Dynamic.GainSchedIdentWarnings.html": {
    "href": "api/TimeSeriesAnalysis.Dynamic.GainSchedIdentWarnings.html",
    "title": "Enum GainSchedIdentWarnings | TimeSeriesAnalysis reference documentation",
    "keywords": "Enum GainSchedIdentWarnings Enum of recognized warning or error states during identification of process model Namespace : TimeSeriesAnalysis.Dynamic Assembly : TimeSeriesAnalysis.dll Syntax public enum GainSchedIdentWarnings Fields Name Description InsufficientExcitationBetweenEachThresholdToBeCertainOfGains In order to identify model, the range of data used in the estimation of certain sub-models had to be increased beyond the threshold ranges. This can cause imprecise gains, and you may consider reducing the number of threshold, or obtaining a tuning data set with more information/exctiation. Nothing No errors or warnings UnableToIdentifySomeSubmodels Identifying some of the sub-models failed (possibly a sign of insufficient excitation)"
  },
  "api/TimeSeriesAnalysis.Dynamic.GainSchedModel.html": {
    "href": "api/TimeSeriesAnalysis.Dynamic.GainSchedModel.html",
    "title": "Class GainSchedModel | TimeSeriesAnalysis reference documentation",
    "keywords": "Class GainSchedModel Simulatable gain-scheduled model. A model for systems that cannot be adequately modelled by UnitModel,because they either have time constants or gains or both that vary signficantly depending on the value of one of the inputs. One input is selected as the \"scheduling varible\" and one ore more thresholds are given for this scheduling variable. The thresholds can be set indepently for time-contant and linear gain. Remember that with more thresholds defined, the higher the requirement for information content in data will be if the model is to be identified from it. This should not be confuesed with \"gain-scheduled\" PID-control, which is a similar concept but applied to PID-control parameters. See also: GainSchedParameters Inheritance System.Object ModelBaseClass GainSchedModel Implements ISimulatableModel Inherited Members ModelBaseClass.ID ModelBaseClass.ModelInputIDs ModelBaseClass.additiveInputIDs ModelBaseClass.outputID ModelBaseClass.outputIdentID ModelBaseClass.processModelType ModelBaseClass.comment ModelBaseClass.x ModelBaseClass.y ModelBaseClass.color ModelBaseClass.GetID() ModelBaseClass.SetID(String) ModelBaseClass.SetProcessModelType(ModelType) ModelBaseClass.GetProcessModelType() ModelBaseClass.SetInputIDs(String[], Nullable<Int32>) ModelBaseClass.AddSignalToOutput(String) ModelBaseClass.GetModelInputIDs() ModelBaseClass.GetAdditiveInputIDs() ModelBaseClass.GetBothKindsOfInputIDs() ModelBaseClass.SetOutputID(String) ModelBaseClass.GetOutputID() ModelBaseClass.GetOutputIdentID() System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) Namespace : TimeSeriesAnalysis.Dynamic Assembly : TimeSeriesAnalysis.dll Syntax public class GainSchedModel : ModelBaseClass, ISimulatableModel Constructors GainSchedModel(GainSchedParameters, String) Constructor Declaration [JsonConstructor] public GainSchedModel(GainSchedParameters modelParameters, string ID = \"not_named\") Parameters Type Name Description GainSchedParameters modelParameters model parameter object System.String ID a unique string that identifies this model in larger process models GainSchedModel(GainSchedParameters, GainSchedDataSet, String) Initalizer of model that for the given dataSet also creates the resulting y_sim Declaration public GainSchedModel(GainSchedParameters modelParameters, GainSchedDataSet dataSet, string ID = \"not_named\") Parameters Type Name Description GainSchedParameters modelParameters GainSchedDataSet dataSet System.String ID a unique string that identifies this model in larger process models Fields modelParameters Declaration public GainSchedParameters modelParameters Field Value Type Description GainSchedParameters Methods GetFittedDataSet() Declaration public GainSchedDataSet GetFittedDataSet() Returns Type Description GainSchedDataSet GetLengthOfInputVector() Returns the number of external inputs U of the model. Note that this model may have an disturbance signal added to the output in addition to the other signals. Declaration public override int GetLengthOfInputVector() Returns Type Description System.Int32 Overrides ModelBaseClass.GetLengthOfInputVector() GetModelParameters() Get the objet of model paramters contained in the model Declaration public GainSchedParameters GetModelParameters() Returns Type Description GainSchedParameters Model paramter object GetOutputSignalType() Get the type of output signal Declaration public override SignalType GetOutputSignalType() Returns Type Description SignalType Overrides ModelBaseClass.GetOutputSignalType() GetSteadyStateInput(Double, Int32, Double[]) Calcuate the steady-state input if the output and all-but-one input are known Declaration public double? GetSteadyStateInput(double x0, int inputIdx = 0, double[] givenInputs = null) Parameters Type Name Description System.Double x0 If no additive inputs y=x, otherwise subtract additive inputs from y to get x System.Int32 inputIdx System.Double [] givenInputs Returns Type Description System.Nullable < System.Double > GetSteadyStateOutput(Double[]) Get the steady state output y for a given input(including additive terms) Declaration public double? GetSteadyStateOutput(double[] u0) Parameters Type Name Description System.Double [] u0 Returns Type Description System.Nullable < System.Double > IsModelSimulatable(out String) Declaration public bool IsModelSimulatable(out string explainStr) Parameters Type Name Description System.String explainStr Returns Type Description System.Boolean Iterate(Double[], Double, Double) Iterates the process model state one time step, based on the inputs given Declaration public double[] Iterate(double[] inputs, double timeBase_s, double badValueIndicator = -9999) Parameters Type Name Description System.Double [] inputs vector of inputs U. Optionally the output disturbance D can be added as the last value. System.Double timeBase_s System.Double badValueIndicator value in U that is to be treated as NaN Returns Type Description System.Double [] the updated process model state(x) - the output without any output noise or disturbance. NaN is returned if model was not able to be identfied, or if no good values U values yet have been given. If some data points in U inputsU are NaN or equal to badValueIndicator , the last good value is returned SetFittedDataSet(GainSchedDataSet) Declaration public void SetFittedDataSet(GainSchedDataSet dataset) Parameters Type Name Description GainSchedDataSet dataset SetModelParameters(GainSchedParameters) Update the paramter object of the model Declaration public void SetModelParameters(GainSchedParameters parameters) Parameters Type Name Description GainSchedParameters parameters ToString() Create a nice human-readable summary of all the important data contained in the model object. This is especially useful for unit-testing and development. Declaration public override string ToString() Returns Type Description System.String Overrides System.Object.ToString() WarmStart(Double[], Double) Warm-starting Declaration public void WarmStart(double[] inputs = null, double output = 0) Parameters Type Name Description System.Double [] inputs not used, leave as null System.Double output not used, leave as null Implements ISimulatableModel"
  },
  "api/TimeSeriesAnalysis.Dynamic.GainSchedParameters.html": {
    "href": "api/TimeSeriesAnalysis.Dynamic.GainSchedParameters.html",
    "title": "Class GainSchedParameters | TimeSeriesAnalysis reference documentation",
    "keywords": "Class GainSchedParameters Parameters data class of the GainSchedModel Inheritance System.Object ModelParametersBaseClass GainSchedParameters Inherited Members ModelParametersBaseClass.Fitting System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : TimeSeriesAnalysis.Dynamic Assembly : TimeSeriesAnalysis.dll Syntax public class GainSchedParameters : ModelParametersBaseClass Constructors GainSchedParameters() Default constructor Declaration public GainSchedParameters() Fields FittingSpecs Declaration public FittingSpecs FittingSpecs Field Value Type Description FittingSpecs GainSchedParameterIndex The index of the scheduling-parameter among the model inputs(by default the first input is the schedulng variable) Declaration public int GainSchedParameterIndex Field Value Type Description System.Int32 Y_max the maximum allowed output value(if set to NaN, no maximum is applied) Declaration public double Y_max Field Value Type Description System.Double Y_min The minimum allowed output value(if set to NaN, no minimum is applied) Declaration public double Y_min Field Value Type Description System.Double Properties Bias The constant bias that is added so that models and dataset match on average, this value will depend on U0 and other parameters. Declaration public double Bias { get; set; } Property Value Type Description System.Double BiasUnc The 95% uncertainty of the bias Declaration public double? BiasUnc { get; set; } Property Value Type Description System.Nullable < System.Double > LinearGains An list of arrays of gains that determine how much in the steady state each input change affects the output(multiplied with (u-u0)) The size of the list should be one higher than the size of LinearGainThresholds. Declaration public List<double[]> LinearGains { get; set; } Property Value Type Description System.Collections.Generic.List < System.Double []> LinearGainThresholds Threshold for when to use different LinearGains, the size should be one less than LinearGains Declaration public double[] LinearGainThresholds { get; set; } Property Value Type Description System.Double [] LinearGainUnc An array of 95% uncertatinty in the linear gains (u-u0)) Declaration public double[] LinearGainUnc { get; set; } Property Value Type Description System.Double [] TimeConstant_s A time constant in seconds, the time a 1. order linear system requires to do 63% of a step response. Set to zero to turn off time constant in model. Declaration public double[] TimeConstant_s { get; set; } Property Value Type Description System.Double [] TimeConstantThresholds Thresholds for when to use timeconstants. Declaration public double[] TimeConstantThresholds { get; set; } Property Value Type Description System.Double [] TimeConstantUnc_s The uncertinty of the time constant estimate Declaration public double[] TimeConstantUnc_s { get; set; } Property Value Type Description System.Double [] TimeDelay_s The time delay in seconds.This number needs to be a multiple of the sampling rate. Set to zero to turn off time delay in model. There is no scheduling on the time delay. Declaration public double TimeDelay_s { get; set; } Property Value Type Description System.Double U0 The working point of the model, the value of each U around which the model is localized. If value is null c> then no U0 is used in the model Declaration public double[] U0 { get; set; } Property Value Type Description System.Double [] UNorm A \"normal range\" of U that is used in the nonlinear curvature term ((u-u0)/Unorm)^2. If value is null c> then no Unorm is used in the model Declaration public double[] UNorm { get; set; } Property Value Type Description System.Double [] Methods AddWarning(GainSchedIdentWarnings) Adds a identifiation warning to the object Declaration public void AddWarning(GainSchedIdentWarnings warning) Parameters Type Name Description GainSchedIdentWarnings warning CreateCopy() Declaration public GainSchedParameters CreateCopy() Returns Type Description GainSchedParameters GetNumInputs() Get the number of inputs U to the model. Declaration public int GetNumInputs() Returns Type Description System.Int32 GetTotalCombinedProcessGain(Int32) Return the \"total combined\" process gain for a given index at u=u0, a combination of lineargain and curvature gain Note that for nonlinear processes, the process gain is given by a combination of the linear and curvature terms of the model : dy/du(u=u0) Declaration public double GetTotalCombinedProcessGain(int inputIdx) Parameters Type Name Description System.Int32 inputIdx Returns Type Description System.Double GetTotalCombinedProcessGainUncertainty(Int32) Return the process gain uncertatinty for a given input index at u=u0 Note that for nonlinear processes, the process gain is given by a combination of the linear and curvature terms of the model : dy/du(u=u0) Declaration public double GetTotalCombinedProcessGainUncertainty(int inputIdx) Parameters Type Name Description System.Int32 inputIdx Returns Type Description System.Double GetWarningList() Get the list of all warnings given during identification of the model Declaration public List<GainSchedIdentWarnings> GetWarningList() Returns Type Description System.Collections.Generic.List < GainSchedIdentWarnings >"
  },
  "api/TimeSeriesAnalysis.Dynamic.GainSchedSimulator.html": {
    "href": "api/TimeSeriesAnalysis.Dynamic.GainSchedSimulator.html",
    "title": "Class GainSchedSimulator | TimeSeriesAnalysis reference documentation",
    "keywords": "Class GainSchedSimulator Stand-alone simulation of any ISimulatableModel model. Inheritance System.Object GainSchedSimulator Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : TimeSeriesAnalysis.Dynamic Assembly : TimeSeriesAnalysis.dll Syntax public class GainSchedSimulator Constructors GainSchedSimulator(GainSchedModel) Constructor Declaration public GainSchedSimulator(GainSchedModel model) Parameters Type Name Description GainSchedModel model Methods CoSimulate(PidModel, ref GainSchedDataSet, Boolean, Boolean) Declaration public bool CoSimulate(PidModel pid, ref GainSchedDataSet processDataSet, bool pidActsOnPastStep = true, bool writeResultToYmeasInsteadOfYsim = false) Parameters Type Name Description PidModel pid GainSchedDataSet processDataSet System.Boolean pidActsOnPastStep System.Boolean writeResultToYmeasInsteadOfYsim Returns Type Description System.Boolean Simulate(ref GainSchedDataSet, Boolean, Boolean) Simulates the output of the model based on the processDataSet.U provided, by default the output is written back to processDataSet.Y_sim or processDataSet.Y_meas By default this method adds to Y_sim o Y_meas if they already contain values. Declaration public double[] Simulate(ref GainSchedDataSet processDataSet, bool writeResultToYmeasInsteadOfYsim = false, bool doOverwriteY = false) Parameters Type Name Description GainSchedDataSet processDataSet dataset containing the inputs U to be simulated System.Boolean writeResultToYmeasInsteadOfYsim if true , output is written to processDataSet.ymeas instead of processDataSet.ysim System.Boolean doOverwriteY (default is false)if true , output overwrites any data in processDataSet.ymeas or processDataSet.ysim Returns Type Description System.Double [] Returns the simulate y if able to simulate,otherwise null SimulateYmeas(ref GainSchedDataSet, Double) Simulation is written to ymeas instead of ysim. This is useful when creating generic datasets for testing/test driven development. Declaration public void SimulateYmeas(ref GainSchedDataSet processDataSet, double noiseAmplitude = 0) Parameters Type Name Description GainSchedDataSet processDataSet System.Double noiseAmplitude optionally adds noise to the \"measured\" y (for testing purposes)"
  },
  "api/TimeSeriesAnalysis.Dynamic.GainSchedWarnings.html": {
    "href": "api/TimeSeriesAnalysis.Dynamic.GainSchedWarnings.html",
    "title": "Enum GainSchedWarnings | TimeSeriesAnalysis reference documentation",
    "keywords": "Enum GainSchedWarnings Enum of recognized warning or error states during identification of process model Namespace : TimeSeriesAnalysis.Dynamic Assembly : TimeSeriesAnalysis.dll Syntax public enum GainSchedWarnings Fields Name Description FailedToInitializeGainSchedModel Failed to initalize the gain scheduling model Nothing No errors or warnings"
  },
  "api/TimeSeriesAnalysis.Dynamic.html": {
    "href": "api/TimeSeriesAnalysis.Dynamic.html",
    "title": "Namespace TimeSeriesAnalysis.Dynamic | TimeSeriesAnalysis reference documentation",
    "keywords": "Namespace TimeSeriesAnalysis.Dynamic Classes ClosedLoopUnitIdentifier Identification that attempts to identify a unit model jointly with estimating the additive signal acting on the output(disturbance signal) yet is counter-acted by closed-loop (feedback)control, such as with PID-control. The approach requires combining information in the measured output signal with the information in the manipulated variable(determined by active control) that is inputted into the process In order to accomplish this estimation, the process model and the disturbance signal are estimated together. Comment ConnectionParser Class that tracks which model is connected to which in a set of models. This is important when traversing the models when simulating with the PlantSimulator , as these models need to be run in a specific order DisturbanceIdentifier An algorithm that attempts to re-create the additive output disturbance acting on a signal Y while PID-control attempts to counter-act the disturbance by adjusting its manipulated output u. DisturbanceIdResult Internal class to store a single sub-run of the DisturnanceIdentifierInternal Divide Simulatable divide block, requires exactly two inputs DivideParameters Paramters of the divide model FittingInfo FittingInfo Be careful as the objective function is different for the static estimation that considers the absolute values, while dynamic estimation considers \"diffs\"- for this reason it is best to use RsqDiff and RsqAbs when comparing different model runs which can be a combination fo static and dynamic FittingSpecs variables that are set prior to fitting. GainSchedDataSet The data for a porition of a process, containg only one output and one or multiple inputs that influence it GainSchedFittingSpecs variables that are set prior to fitting. GainSchedIdentifier GainSchedModel Simulatable gain-scheduled model. A model for systems that cannot be adequately modelled by UnitModel,because they either have time constants or gains or both that vary signficantly depending on the value of one of the inputs. One input is selected as the \"scheduling varible\" and one ore more thresholds are given for this scheduling variable. The thresholds can be set indepently for time-contant and linear gain. Remember that with more thresholds defined, the higher the requirement for information content in data will be if the model is to be identified from it. This should not be confuesed with \"gain-scheduled\" PID-control, which is a similar concept but applied to PID-control parameters. See also: GainSchedParameters GainSchedParameters Parameters data class of the GainSchedModel GainSchedSimulator Stand-alone simulation of any ISimulatableModel model. ModelBaseClass Abstract base class that contains common functionality across all models which are to implement ISimulatableModel ModelParametersBaseClass Abstract base class for ISimulatableModel classes PidAntiSurgeParams Class that contains special pid-controller parameters for anti-surge controllers PidModel PidController PidController Proporitional-Integral-Derivative(PID) controller that supports first and second order low pass filtering of process variable anti-windup bumpless transfer between auto and manual mode \"warmstarting\" -bumpless startup feedforward scaling of input and output values gain scheduling of Kp gain scheduling of Ti \"kicking\" as is usually applied to compressor recycling controllers/anti-surge min select/max select (also referred to as high select or low select: (multiple pid-controllers controlling the same output switch between auto and tracking mode) By design decision, this class should be kept relativly simple in terms of coding patterns, so that it is possible to hand-port this class to other languages (c++/c/Structured Text/Labview/Matlab etc). To simulate PID-control, use the wrapper class PIDModel, as it wraps this class and impelments the ISimulatableModel interface needed to simulate with ProcessSimulator PidModel PidFeedForward Parameters describing PID-controller parameters for feed-forward PidModel PidController PidFilter Class that handles the filtering of inputs y to a pid-controller Put into separate class as this is both a component of the PidController and of PidIdentifier, and important that implementation is equal. PidFilterParams Containing the information related to how a pid-controller should low-pass filter its input signal PidGainScheduling Parameters describing PID-controller parameters for gain-scheduling PidModel PidController PidIdentifier Class that attempts to identify the parameters(such as Kp and Ti) of a PID-controller from a given set of time-series of the input and output of said controller. PidModel Simulatable industrial PID-controller This class is as a wrapper for PidController class, that implements ISimulatableModel . To simulate minimum or maximum select controllers, combine this class with Select blocks. The controller paramters belong to different aspects of the controller like, tuning, scaling, gain-scheduling, feedforward and anti-surge are adjusted have been collected into a number of data-classes, linked below: PidParameters PidAntiSurgeParams PidFeedForward PidGainScheduling PidStatus PidScaling PidTuning PidParameters Parameters of the PIDModel PidModel PidController PidScaling Parameters describing PID-controller parameters for scaling PidModel PidController PidSimulator Simulate a PIDmodel PID for a given set of inputs timeseries PidTuning Parameters describing PID-controller tuning (Kp,Ti,Td) PidModel PidController PlantSimulator Simulates larger \"plant-models\" that is built up connected sub-models, that each implement ISimulatableModel To set up a simulation, first connect models, and then add external input signals. This class handles information about which model is connected to which, and handles callig sub-models in the correct order with the correct input signals. By default, the model attempts to start in steady-state, intalization handled by ProcessSimulatorInitalizer (this requires no user interaction) The building blocks of plant models are PIDModel , DefaultProcessModel and Select UnitModel PidModel PlantSimulatorInitalizer Select PlantSimulatorInitalizer Intializes a plant simulator in the first data point Currently, only initalizing to steady-state is supported. By design choice, this class traverses the models by logic to initialize the plant model rather than using mathematical programming/matrix solvers. PlantSimulatorSerializer Select Simulatable select block This block can function either as \"minimum\" or \"maximum\" selector, mainly inteded for simulating \"min select\" or \"max selct\" pid-control by combining with PidModel SerializeHelper SignalNamer Handles naming of individual signals in a process simulation TimeDelay Delays a signal by a specific number of time steps, keeping an internal buffer of delayed values between iterations. This is a reasuble class for providing time-delay functionality to simulatable models. UnitDataSet The data for a porition of a process, containg only one output and one or multiple inputs that influence it UnitIdentifier Identifier of the \"Default\" process model - a dynamic process model with time-constant, time-delay, linear process gain and optional (nonlinear)curvature process gains. This model class is sufficent for real-world linear or weakly nonlinear dynamic systems, yet also introduces the fewest possible parameters to describe the system in an attempt to avoiding over-fitting/over-parametrization The \"default\" process model is identified using a linear-in-parameters paramterization(paramters a,b,c), so that it can be solved by linear regression and identification should thus be both fast and stable. The issue with the parametriation(a,b,c) is that the meaning of each paramter is less inutitive, for instance the time constant depends on a, but linear gain depends on both a and b, while curvature depends on a and c. Looking at the unceratinty of each parameter to determine if the model should be dynamic or static or what the uncertainty of the time constant is, is very hard, and this observation motivates re-paramtrizing the model after identification. When assessing and simulating the model, parmaters are converted into more intuitive paramters \"time constant\", \"linear gains\" and \"curvature gain\" which are a different parametrization. The UnitIdentifier, UnitModel and UnitParamters classes handle this transition seamlessly to the user. Uncertainty is expressed in terms of this more intuitive parametrization, to allow for a more intuitive assessment of the parameters. Another advantage of the paramterization, is that the model internally separates betwen stedy-state and transient state, you can at any instance \"turn off\" dynamics and request the steady-state model output for the current input. This is useful if you have transient data that you want to analyze in the steady-state, as you can then fit the model to all available data-points without having to select what data points you beleive are at steady state, then you can disable dynamic terms to do a static analysis of the dynamic model. Time-delay is an integer parameter, and finding the time-delay alongside continous paramters turns the identification problem into a linear mixed-integer problem. The time delay identification is done by splitting the time-delay estimation from continous parameter identification, turning the solver into a sequential optimization solver. This logic to re-run estimation for multiple time-delays and selecting the best estiamte of time delay is deferred to TimeSeriesAnalysis.Dynamic.UnitTimeDelayIdentifier Since the aim is to identify transients/dynamics, the regression is done on model differences rather than absolute values UnitModel Simulatable \"default\" process model. This is a model that can be either dynamic or static, have one or multiple inputs and can be either linear in inputs or have inputs nonlinearity described by a second-order polynominal. Dynamics can be either 1.order time-constant, time-delay or both. The model also supports \"additive\" signals added to its output(intended for modeling disturbances.) The model is designed to lend itself well to identificaiton from industrial time-series datasets, and is supported by the accompanying identificaiton method UnitIdentifier . This model is also intended to be co-simulated with PidModel by PlantSimulator to study process control feedback loops. It is assumed that for most unit processes in industrial process control systems can be described sufficiently by this model, and thus that larger plants can be modeled by connecting unit models based on this model structure. It would be possible to extend this model to also describe second-order dynamics along the same principles by the intorduction of one additional paramters in future work. See also: UnitParameters UnitParameters Parameters data class of the UnitModel UnitSimulator Stand-alone simulation of any ISimulatableModel model. Interfaces ISimulatableModel Generic interface that any process model needs to implement if it is to be simulated by PlantSimulator . Enums DisturbanceSetToZeroReason GainSchedIdentWarnings Enum of recognized warning or error states during identification of process model GainSchedWarnings Enum of recognized warning or error states during identification of process model INDEX Enum to provide more readable code, for the input instance (int)INDEX.FIRST may be more readable than \"0\" ModelType Enum of recognized types of unit-models. This type is used to set the unit model unique identifier and is also used in internal logic in the large-scale dynamic simulations PidControllerType PidIdentWarning PidModelInputsIdx This determines the position in the U-vector given to Iterate for the class PIDModel PidStatus Enum to classify the status output of PidController.cs ProcessTimeDelayIdentWarnings Enum of recognized warning or error states during identification of time delays SelectType An enum of the type of Select model SignalType Enum of types of signals that ProcessSimulator must differentiate between UnitdentWarnings Enum of recognized warning or error states during identification of process model UnitWarnings Enum of recognized warning or error states during identification of process model"
  },
  "api/TimeSeriesAnalysis.Dynamic.INDEX.html": {
    "href": "api/TimeSeriesAnalysis.Dynamic.INDEX.html",
    "title": "Enum INDEX | TimeSeriesAnalysis reference documentation",
    "keywords": "Enum INDEX Enum to provide more readable code, for the input instance (int)INDEX.FIRST may be more readable than \"0\" Namespace : TimeSeriesAnalysis.Dynamic Assembly : TimeSeriesAnalysis.dll Syntax public enum INDEX Fields Name Description FIFTH FIRST FOURTH SECOND THIRD"
  },
  "api/TimeSeriesAnalysis.Dynamic.ISimulatableModel.html": {
    "href": "api/TimeSeriesAnalysis.Dynamic.ISimulatableModel.html",
    "title": "Interface ISimulatableModel | TimeSeriesAnalysis reference documentation",
    "keywords": "Interface ISimulatableModel Generic interface that any process model needs to implement if it is to be simulated by PlantSimulator . Namespace : TimeSeriesAnalysis.Dynamic Assembly : TimeSeriesAnalysis.dll Syntax public interface ISimulatableModel Methods AddSignalToOutput(String) Add an additive signal to the output Declaration void AddSignalToOutput(string additiveInputID) Parameters Type Name Description System.String additiveInputID GetAdditiveInputIDs() Get additive input IDs Declaration string[] GetAdditiveInputIDs() Returns Type Description System.String [] GetBothKindsOfInputIDs() Get both additive and model input IDs Declaration string[] GetBothKindsOfInputIDs() Returns Type Description System.String [] GetID() An unique name of the process model Declaration string GetID() Returns Type Description System.String GetLengthOfInputVector() Get the length of the input vector Declaration int GetLengthOfInputVector() Returns Type Description System.Int32 GetModelInputIDs() Return the inputIDs that are \"internal\" i.e. related to the model and internal state x, but not \"additive\" Declaration string[] GetModelInputIDs() Returns Type Description System.String [] GetOutputID() Get the output ID Declaration string GetOutputID() Returns Type Description System.String GetOutputIdentID() Get the ID of the \"OutputIdent\" signal Declaration string GetOutputIdentID() Returns Type Description System.String GetOutputSignalType() Get the type of the output signal Declaration SignalType GetOutputSignalType() Returns Type Description SignalType GetProcessModelType() Returns the type of process model Declaration ModelType GetProcessModelType() Returns Type Description ModelType GetSteadyStateInput(Double, Int32, Double[]) Calculates the value u0 of u that at steady-state will give the output value y0. This method is used when starting a method at steady-state (assumes that disturbance is zero!) Declaration double? GetSteadyStateInput(double x0, int inputIdx = 0, double[] givenInputValues = null) Parameters Type Name Description System.Double x0 value of x for which to find matching u0 System.Int32 inputIdx index of input(only applicable if multiple inputs) System.Double [] givenInputValues for multi-input systems, all values except one must be given to calculate the steady-state u0 Returns Type Description System.Nullable < System.Double > GetSteadyStateOutput(Double[]) Get the steady state value of the model output Declaration double? GetSteadyStateOutput(double[] u0) Parameters Type Name Description System.Double [] u0 vector of inputs for which the steady state is to be calculated Returns Type Description System.Nullable < System.Double > the steady-state value, if it is not possible to calculate, a null is returned IsModelSimulatable(out String) Returns true if the paramters are specified Declaration bool IsModelSimulatable(out string explanationStr) Parameters Type Name Description System.String explanationStr Returns Type Description System.Boolean string explaining why return is false, if applicable Iterate(Double[], Double, Double) Iterate the process model one timestep forward Declaration double[] Iterate(double[] inputsU, double timeBase_s, double badDataID = -9999) Parameters Type Name Description System.Double [] inputsU a 2d array of inputs, one row for each time step, or null if model is autonomous System.Double timeBase_s the time in seconds between the data samples of the inputs System.Double badDataID is a special reserverd value of inputs U that is to be treated as NaN Returns Type Description System.Double [] First value: the value of the state x of the process model at the new time step(be aware that if a disturbance is defined, they need ot be added to states to get y_sim ), if the model has additive outputs, the second state is the \"internal output\" upstream of those. SetInputIDs(String[], Nullable<Int32>) Set the input IDs Declaration bool SetInputIDs(string[] manipulatedVariablesU_stringIDs, int? index = null) Parameters Type Name Description System.String [] manipulatedVariablesU_stringIDs System.Nullable < System.Int32 > index Returns Type Description System.Boolean SetOutputID(String) Set the output ID Declaration void SetOutputID(string outputID) Parameters Type Name Description System.String outputID WarmStart(Double[], Double) If possible, set the internal state of the model so that the given inputs give the given output Declaration void WarmStart(double[] inputs, double output) Parameters Type Name Description System.Double [] inputs System.Double output"
  },
  "api/TimeSeriesAnalysis.Dynamic.ModelBaseClass.html": {
    "href": "api/TimeSeriesAnalysis.Dynamic.ModelBaseClass.html",
    "title": "Class ModelBaseClass | TimeSeriesAnalysis reference documentation",
    "keywords": "Class ModelBaseClass Abstract base class that contains common functionality across all models which are to implement ISimulatableModel Inheritance System.Object ModelBaseClass Divide GainSchedModel PidModel Select UnitModel Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : TimeSeriesAnalysis.Dynamic Assembly : TimeSeriesAnalysis.dll Syntax public abstract class ModelBaseClass Fields additiveInputIDs Unique signal IDs that are added to the output of the model(typically a disturbance) Declaration public List<string> additiveInputIDs Field Value Type Description System.Collections.Generic.List < System.String > color Optional color string when model is displayed as a graph Declaration public string color Field Value Type Description System.String comment Optional comment Declaration public string comment Field Value Type Description System.String ModelInputIDs Unique signal IDs that are mapped to the non-additive model inputs Declaration public string[] ModelInputIDs Field Value Type Description System.String [] outputID Unique signal ID that defines the name of output signal of the model Declaration public string outputID Field Value Type Description System.String outputIdentID Optional unique optional signal ID to be used for fitting/identification, if this is different from outputID. This tag is mainly for modeling estimated disturbance signals. Declaration public string outputIdentID Field Value Type Description System.String processModelType Declaration public ModelType processModelType Field Value Type Description ModelType x Optional visual position of model when displayed as graph: x-axis position(origo is top left) Declaration public double? x Field Value Type Description System.Nullable < System.Double > y Optional visual position of model when displayed as graph: y-axis position(origo is top left) Declaration public double? y Field Value Type Description System.Nullable < System.Double > Properties ID A unique ID string that is used to identify the model uniquely in a PlantSimulation Declaration public string ID { get; set; } Property Value Type Description System.String Methods AddSignalToOutput(String) Add an additive signal to the output Declaration public void AddSignalToOutput(string additiveInputID) Parameters Type Name Description System.String additiveInputID ID of signal to add GetAdditiveInputIDs() Get the DIs of any additive inputs that are included in model Declaration public string[] GetAdditiveInputIDs() Returns Type Description System.String [] returns null if no additive inputs are defined. GetBothKindsOfInputIDs() Gets IDS both of model inputs and additive model outputs Declaration public string[] GetBothKindsOfInputIDs() Returns Type Description System.String [] GetID() Get the ID of the model Declaration public string GetID() Returns Type Description System.String GetLengthOfInputVector() Get the length of the output vector Declaration public virtual int GetLengthOfInputVector() Returns Type Description System.Int32 GetModelInputIDs() Get the type of the process model Declaration public string[] GetModelInputIDs() Returns Type Description System.String [] GetOutputID() returns the output ID Declaration public virtual string GetOutputID() Returns Type Description System.String may return null if output is not set GetOutputIdentID() returns the ID of the signal the output is identified against Declaration public virtual string GetOutputIdentID() Returns Type Description System.String may return null if output is not set GetOutputSignalType() Get the type of the output signal Declaration public abstract SignalType GetOutputSignalType() Returns Type Description SignalType GetProcessModelType() Get the type of the process model Declaration public ModelType GetProcessModelType() Returns Type Description ModelType SetID(String) Set ID of the model Declaration public void SetID(string ID) Parameters Type Name Description System.String ID SetInputIDs(String[], Nullable<Int32>) Set the stringIDs of the one or more manipulated variables U that enter model. This method may append/lengthen the inputIDs Declaration public bool SetInputIDs(string[] U_stringIDs, int? idx = null) Parameters Type Name Description System.String [] U_stringIDs System.Nullable < System.Int32 > idx if non-null, this is the index of the element in U to set (U_stringIDs should then have just one element) Returns Type Description System.Boolean SetOutputID(String) Set the ID of the output Declaration public void SetOutputID(string outputID) Parameters Type Name Description System.String outputID SetProcessModelType(ModelType) Set the type of the process model Declaration public void SetProcessModelType(ModelType newType) Parameters Type Name Description ModelType newType"
  },
  "api/TimeSeriesAnalysis.Dynamic.ModelParametersBaseClass.html": {
    "href": "api/TimeSeriesAnalysis.Dynamic.ModelParametersBaseClass.html",
    "title": "Class ModelParametersBaseClass | TimeSeriesAnalysis reference documentation",
    "keywords": "Class ModelParametersBaseClass Abstract base class for ISimulatableModel classes Inheritance System.Object ModelParametersBaseClass DivideParameters GainSchedParameters PidParameters UnitParameters Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : TimeSeriesAnalysis.Dynamic Assembly : TimeSeriesAnalysis.dll Syntax public abstract class ModelParametersBaseClass Properties Fitting Declaration [JsonInclude] [JsonProperty(\"Fitting\")] public FittingInfo Fitting { get; } Property Value Type Description FittingInfo"
  },
  "api/TimeSeriesAnalysis.Dynamic.ModelType.html": {
    "href": "api/TimeSeriesAnalysis.Dynamic.ModelType.html",
    "title": "Enum ModelType | TimeSeriesAnalysis reference documentation",
    "keywords": "Enum ModelType Enum of recognized types of unit-models. This type is used to set the unit model unique identifier and is also used in internal logic in the large-scale dynamic simulations Namespace : TimeSeriesAnalysis.Dynamic Assembly : TimeSeriesAnalysis.dll Syntax public enum ModelType Fields Name Description Disturbance Disturbance model Divide Divide block GainSchedModel GainSched block PID PID-controller model Select Select-block SubProcess SubProcess model (a \"normal\" unit process) UnTyped Type is not set"
  },
  "api/TimeSeriesAnalysis.Dynamic.PidAntiSurgeParams.html": {
    "href": "api/TimeSeriesAnalysis.Dynamic.PidAntiSurgeParams.html",
    "title": "Class PidAntiSurgeParams | TimeSeriesAnalysis reference documentation",
    "keywords": "Class PidAntiSurgeParams Class that contains special pid-controller parameters for anti-surge controllers PidModel PidController Inheritance System.Object PidAntiSurgeParams Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : TimeSeriesAnalysis.Dynamic Assembly : TimeSeriesAnalysis.dll Syntax public class PidAntiSurgeParams Constructors PidAntiSurgeParams(Double, Nullable<Double>, Int32, Double) Constructor Declaration public PidAntiSurgeParams(double kickPrc, double? ffRampDownRatePrcPerMin, int nKicksFound = 0, double kickBelowThresholdE = -5) Parameters Type Name Description System.Double kickPrc System.Nullable < System.Double > ffRampDownRatePrcPerMin System.Int32 nKicksFound System.Double kickBelowThresholdE Fields ffRampDownRatePrcPerMin after a kick, valve closure will be rate-limited. Declaration public double? ffRampDownRatePrcPerMin Field Value Type Description System.Nullable < System.Double > kickBelowThresholdE if kick is \"ctrldev\" below this value (often zero) Declaration public double kickBelowThresholdE Field Value Type Description System.Double kickPrcPerSec how many percent to kick controller open if it closes Declaration public double kickPrcPerSec Field Value Type Description System.Double nKicksFound Kicks counter Declaration public int nKicksFound Field Value Type Description System.Int32"
  },
  "api/TimeSeriesAnalysis.Dynamic.PidController.html": {
    "href": "api/TimeSeriesAnalysis.Dynamic.PidController.html",
    "title": "Class PidController | TimeSeriesAnalysis reference documentation",
    "keywords": "Class PidController Proporitional-Integral-Derivative(PID) controller that supports first and second order low pass filtering of process variable anti-windup bumpless transfer between auto and manual mode \"warmstarting\" -bumpless startup feedforward scaling of input and output values gain scheduling of Kp gain scheduling of Ti \"kicking\" as is usually applied to compressor recycling controllers/anti-surge min select/max select (also referred to as high select or low select: (multiple pid-controllers controlling the same output switch between auto and tracking mode) By design decision, this class should be kept relativly simple in terms of coding patterns, so that it is possible to hand-port this class to other languages (c++/c/Structured Text/Labview/Matlab etc). To simulate PID-control, use the wrapper class PIDModel, as it wraps this class and impelments the ISimulatableModel interface needed to simulate with ProcessSimulator PidModel Inheritance System.Object PidController Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : TimeSeriesAnalysis.Dynamic Assembly : TimeSeriesAnalysis.dll Syntax public class PidController Constructors PidController(Double, Double, Double, Double, Double) Constructor Declaration public PidController(double TimeBase_s, double Kp = 1, double Ti = 50, double Td = 0, double nanValue = -9999) Parameters Type Name Description System.Double TimeBase_s System.Double Kp System.Double Ti System.Double Td System.Double nanValue Methods GetControllerStatus() Returns a status code, to determine if controller is in manual, auto or in tracking(relevant for split range controllers.) Declaration public PidStatus GetControllerStatus() Returns Type Description PidStatus GetFeedForward() Get the feedforward parameters of the controller Declaration public PidFeedForward GetFeedForward() Returns Type Description PidFeedForward GetGainScehduling(PidGainScheduling) Get the gain scheduling settings of the controller Declaration public PidGainScheduling GetGainScehduling(PidGainScheduling gainSchedulingObj) Parameters Type Name Description PidGainScheduling gainSchedulingObj Returns Type Description PidGainScheduling GetScaling() Get the object that contains scaling information Declaration public PidScaling GetScaling() Returns Type Description PidScaling GetTimeBase() Sets the length of time in seconds between each iteration of the controller, i.e. the \"clock time\" or \"time base\". This is very important to set correctly for the controller to function properly. Normally the clock time is set only once during intalization. Declaration public double GetTimeBase() Returns Type Description System.Double GetTrackingCutoff() Get the tracking cutoff parameter Declaration public double GetTrackingCutoff() Returns Type Description System.Double GetTrackingOffset() Returns the tracking offset of the controller, the offset that a non-active controller will add or subtract from its output when inactive in a split range control scheme Declaration public double GetTrackingOffset() Returns Type Description System.Double GetUIfInAuto() Returns the value of the output u that the controller would give if it was in auto. This is useful when considering turning on a controller that is in manual to see that the controller gives a sensible output. Call \"iterate\" first to update the internals of the controller. Declaration public double GetUIfInAuto() Returns Type Description System.Double GetUWithoutTracking() Split range controllers add an offset to the output u for inactive or \"tracking\" controllers. This function returns the \"raw\" u without tracking, which can be useful for initalizing simulations with split range control. Declaration public double GetUWithoutTracking() Returns Type Description System.Double Iterate(Double, Double, Nullable<Double>, Nullable<Double>, Nullable<Double>) Calculates the next u[k] output of the controller given the most recent process value and setpoint value, and optionally also including the tracking signal (only applicable if this is a split range controller) and optionally the gainScehduling variable if controller is to gain-schedule Declaration public double Iterate(double y_process_abs, double y_set_abs, double? uTrackSignal = null, double? gainSchedulingVariable = null, double? feedForwardVariable = null) Parameters Type Name Description System.Double y_process_abs System.Double y_set_abs System.Nullable < System.Double > uTrackSignal System.Nullable < System.Double > gainSchedulingVariable System.Nullable < System.Double > feedForwardVariable Returns Type Description System.Double Iterate(Double[], Double[], Double[]) Calculates an entire output vector u given vector of processes and setpoints (and optionally a tracking signal for split range) This method is useful for back-testing against historic data. Declaration public double[] Iterate(double[] y_process_abs, double[] y_set_abs, double[] uTrackSignal = null) Parameters Type Name Description System.Double [] y_process_abs System.Double [] y_set_abs System.Double [] uTrackSignal Returns Type Description System.Double [] SetAntiSurgeParams(PidAntiSurgeParams) Sets the anti-surge \"kick\" paramters of the controller Declaration public void SetAntiSurgeParams(PidAntiSurgeParams antiSurgeParams) Parameters Type Name Description PidAntiSurgeParams antiSurgeParams SetAutoMode() Set the control to autoamtic mode (i.e. u varies based on inputs and settings) (use SetManualMode to switch back) Declaration public void SetAutoMode() SetFeedForward(PidFeedForward) Set the feedforward of the controller Re-calling this setter to update Declaration public void SetFeedForward(PidFeedForward feedForwardObj) Parameters Type Name Description PidFeedForward feedForwardObj SetGainScehduling(PidGainScheduling) Set the gain scheduling of the controller (by default controller has no gain-scheduling) Re-calling this setter to update gain-scheduling Declaration public void SetGainScehduling(PidGainScheduling gainSchedulingObj) Parameters Type Name Description PidGainScheduling gainSchedulingObj SetKp(Double) Sets the Proportional gain(P) of the controller Declaration public void SetKp(double Kp) Parameters Type Name Description System.Double Kp SetManualMode() Set the control to manual mode (i.e. constant u). Will cause a bumpless transfer.(use SetAutoMode to switch back) Declaration public void SetManualMode() SetManualOutput(Double) Set the manual output of the model (will only be used if set) Declaration public void SetManualOutput(double uManual) Parameters Type Name Description System.Double uManual SetPidFiltering(PidFilterParams) Declaration public void SetPidFiltering(PidFilterParams pidFiltering) Parameters Type Name Description PidFilterParams pidFiltering SetScaling(PidScaling) Gives a PIDscaling object that specifies how input and output is to be scaled. Declaration public void SetScaling(PidScaling pidScaling) Parameters Type Name Description PidScaling pidScaling SetTd(Double) Sets the differential(D) time contant of the controller in seconds Declaration public void SetTd(double Td_seconds) Parameters Type Name Description System.Double Td_seconds SetTi(Double) Sets the Integral(I) time contant of the controller in seconds Declaration public void SetTi(double Ti_seconds) Parameters Type Name Description System.Double Ti_seconds SetTrackingOffset(Double, Double) Set the offset that is to be added or subtracte to a split range controller that is inactive or tracking. If this value is above zero, then the controller is MIN SELECT, if this value is negative then the controller is assumed MAX SELECT if this vlaue is zero, then trakcking will not work properly as controller will be unable to determine if its output was selected by looking at the tracking signal. Declaration public void SetTrackingOffset(double uTrackingOffset, double uTrackingCutoff = 0.5) Parameters Type Name Description System.Double uTrackingOffset System.Double uTrackingCutoff SetU0ForPcontrol(Double) For proportional-only controllers (P-controllers), a u0 offset to be added to u is specified by this method. Declaration public void SetU0ForPcontrol(double u0) Parameters Type Name Description System.Double u0 WarmStart(Double, Double, Double) Initalizes the controller internal state(integral term) to be steady at the given process value and output value, useful to avoid bumps when staring controller Declaration public void WarmStart(double y_process_abs, double y_set_abs, double u_abs) Parameters Type Name Description System.Double y_process_abs System.Double y_set_abs System.Double u_abs"
  },
  "api/TimeSeriesAnalysis.Dynamic.PidControllerType.html": {
    "href": "api/TimeSeriesAnalysis.Dynamic.PidControllerType.html",
    "title": "Enum PidControllerType | TimeSeriesAnalysis reference documentation",
    "keywords": "Enum PidControllerType Namespace : TimeSeriesAnalysis.Dynamic Assembly : TimeSeriesAnalysis.dll Syntax public enum PidControllerType Fields Name Description AntiSurge Duty Flow Level Pressure Temperature Unset"
  },
  "api/TimeSeriesAnalysis.Dynamic.PidFeedForward.html": {
    "href": "api/TimeSeriesAnalysis.Dynamic.PidFeedForward.html",
    "title": "Class PidFeedForward | TimeSeriesAnalysis reference documentation",
    "keywords": "Class PidFeedForward Parameters describing PID-controller parameters for feed-forward PidModel PidController Inheritance System.Object PidFeedForward Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : TimeSeriesAnalysis.Dynamic Assembly : TimeSeriesAnalysis.dll Syntax public class PidFeedForward Constructors PidFeedForward() Declaration public PidFeedForward() Fields FF_Gain feed-forward gain. If variable is zero then no feed-forward is added to output. Declaration public double FF_Gain Field Value Type Description System.Double FF_HP_Tc_s feed-forward high-pass time constant in seconds(should be smaller than FF_HP_Tc_s or zero.) Declaration public double FF_HP_Tc_s Field Value Type Description System.Double FF_LP_Tc_s feed-forward low-pass time constant in seconds (should be larger than FF_HP_Tc_s or zero.) Declaration public double FF_LP_Tc_s Field Value Type Description System.Double FFHP_filter_order feed-forward high pass filter order (0, 1 or 2) Declaration public int FFHP_filter_order Field Value Type Description System.Int32 FFLP_filter_order feed-forward low pass filter order (0, 1 or 2) Declaration public int FFLP_filter_order Field Value Type Description System.Int32 isFFActive if true, then the feed-forward term is added to the output Declaration public bool isFFActive Field Value Type Description System.Boolean"
  },
  "api/TimeSeriesAnalysis.Dynamic.PidFilter.html": {
    "href": "api/TimeSeriesAnalysis.Dynamic.PidFilter.html",
    "title": "Class PidFilter | TimeSeriesAnalysis reference documentation",
    "keywords": "Class PidFilter Class that handles the filtering of inputs y to a pid-controller Put into separate class as this is both a component of the PidController and of PidIdentifier, and important that implementation is equal. Inheritance System.Object PidFilter Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : TimeSeriesAnalysis.Dynamic Assembly : TimeSeriesAnalysis.dll Syntax public class PidFilter Constructors PidFilter(PidFilterParams, Double) Declaration public PidFilter(PidFilterParams filterParams, double timebase_s) Parameters Type Name Description PidFilterParams filterParams System.Double timebase_s Methods GetParams() Declaration public PidFilterParams GetParams() Returns Type Description PidFilterParams"
  },
  "api/TimeSeriesAnalysis.Dynamic.PidFilterParams.html": {
    "href": "api/TimeSeriesAnalysis.Dynamic.PidFilterParams.html",
    "title": "Class PidFilterParams | TimeSeriesAnalysis reference documentation",
    "keywords": "Class PidFilterParams Containing the information related to how a pid-controller should low-pass filter its input signal Inheritance System.Object PidFilterParams Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : TimeSeriesAnalysis.Dynamic Assembly : TimeSeriesAnalysis.dll Syntax public class PidFilterParams Constructors PidFilterParams(Boolean, Int32, Double) Declaration public PidFilterParams(bool IsEnabled = false, int FilterOrder = 0, double TimeConstant_s = 0) Parameters Type Name Description System.Boolean IsEnabled System.Int32 FilterOrder System.Double TimeConstant_s Fields FilterOrder The order of the low-pass filter. Values 0(off), 1 and 2 are supported Declaration public int FilterOrder Field Value Type Description System.Int32 IsEnabled Enable or disable the filtering with this variable Declaration public bool IsEnabled Field Value Type Description System.Boolean TimeConstant_s Time-constant in seconds of the low-pass filter Declaration public double TimeConstant_s Field Value Type Description System.Double"
  },
  "api/TimeSeriesAnalysis.Dynamic.PidGainScheduling.html": {
    "href": "api/TimeSeriesAnalysis.Dynamic.PidGainScheduling.html",
    "title": "Class PidGainScheduling | TimeSeriesAnalysis reference documentation",
    "keywords": "Class PidGainScheduling Parameters describing PID-controller parameters for gain-scheduling PidModel PidController Inheritance System.Object PidGainScheduling Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : TimeSeriesAnalysis.Dynamic Assembly : TimeSeriesAnalysis.dll Syntax public class PidGainScheduling Constructors PidGainScheduling() Constructor(disable gain-scheduling by default) Declaration public PidGainScheduling() PidGainScheduling(Double, Double) Constructor that enables gain-scheduling filter (but gain-scheduling still disabled) Declaration public PidGainScheduling(double TimeStep_s, double GSVariableLP_Tc_s) Parameters Type Name Description System.Double TimeStep_s System.Double GSVariableLP_Tc_s Fields GS_Kp_1 KP(proportional term) @ GsVariable=GS_x_1 Declaration public double GS_Kp_1 Field Value Type Description System.Double GS_Kp_2 KP(proportional term) @ GsVariable=GS_x_2 Declaration public double GS_Kp_2 Field Value Type Description System.Double GS_Kp_Max KP(proportional term) @ GsVariable=GS_x_Max Declaration public double GS_Kp_Max Field Value Type Description System.Double GS_Kp_Min KP(proportional term) @ GsVariable=GS_x_Min Declaration public double GS_Kp_Min Field Value Type Description System.Double GS_Ti_1 Ti(integral effect) @ GsVariable=GS_x_1 Declaration public double GS_Ti_1 Field Value Type Description System.Double GS_Ti_2 Ti(integral effect) @ GsVariable=GS_x_2 Declaration public double GS_Ti_2 Field Value Type Description System.Double GS_Ti_Max Ti(integral effect) @ GsVariable=GS_x_Max Declaration public double GS_Ti_Max Field Value Type Description System.Double GS_Ti_Min Ti(integral effect) @ GsVariable=GS_x_Min Declaration public double GS_Ti_Min Field Value Type Description System.Double GS_x_1 Gain-sheduling(x) variable x1,x=GsVariable Declaration public double GS_x_1 Field Value Type Description System.Double GS_x_2 Gain-sheduling(x) variable x2,x=GsVariable Declaration public double GS_x_2 Field Value Type Description System.Double GS_x_Max Gain-sheduling(x) variable maximum Declaration public double GS_x_Max Field Value Type Description System.Double GS_x_Min Gain-sheduling(x) variable minimum Declaration public double GS_x_Min Field Value Type Description System.Double GSActive_b if TRUE then the gainScheduling variable and gain-scheduling inputs are used Declaration public bool GSActive_b Field Value Type Description System.Boolean GSActiveTi_b if TRUE then the gainScheduling is also done on Ti Declaration public bool GSActiveTi_b Field Value Type Description System.Boolean"
  },
  "api/TimeSeriesAnalysis.Dynamic.PidIdentifier.html": {
    "href": "api/TimeSeriesAnalysis.Dynamic.PidIdentifier.html",
    "title": "Class PidIdentifier | TimeSeriesAnalysis reference documentation",
    "keywords": "Class PidIdentifier Class that attempts to identify the parameters(such as Kp and Ti) of a PID-controller from a given set of time-series of the input and output of said controller. Inheritance System.Object PidIdentifier Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : TimeSeriesAnalysis.Dynamic Assembly : TimeSeriesAnalysis.dll Syntax public class PidIdentifier Constructors PidIdentifier(PidScaling, Double, Double, PidControllerType) Declaration public PidIdentifier(PidScaling pidScaling = null, double maxExpectedTc_s = 0, double badValueIndicatingValue = -9999, PidControllerType type = PidControllerType.Unset) Parameters Type Name Description PidScaling pidScaling System.Double maxExpectedTc_s System.Double badValueIndicatingValue PidControllerType type Methods GetSimulatedU(PidParameters, UnitDataSet, Boolean) Declaration public double[] GetSimulatedU(PidParameters pidParams, UnitDataSet dataset, bool isPIDoutputDelayOneSample) Parameters Type Name Description PidParameters pidParams UnitDataSet dataset System.Boolean isPIDoutputDelayOneSample Returns Type Description System.Double [] Identify(ref UnitDataSet) Identifies a PID-controller from a UnitDataSet Declaration public PidParameters Identify(ref UnitDataSet dataSet) Parameters Type Name Description UnitDataSet dataSet a UnitDataSet, where .Y_meas, .Y_setpoint and .U are analyzed Returns Type Description PidParameters the identified parameters of the PID-controller"
  },
  "api/TimeSeriesAnalysis.Dynamic.PidIdentWarning.html": {
    "href": "api/TimeSeriesAnalysis.Dynamic.PidIdentWarning.html",
    "title": "Enum PidIdentWarning | TimeSeriesAnalysis reference documentation",
    "keywords": "Enum PidIdentWarning Namespace : TimeSeriesAnalysis.Dynamic Assembly : TimeSeriesAnalysis.dll Syntax public enum PidIdentWarning Fields Name Description DataSetVeryShortComparedtoTMax InputSaturation_UcloseToUmax InputSaturation_UcloseToUmin NegativeEstimatedTi Nothing NotPossibleToIdentifyPIDcontroller_BadInputData NotPossibleToIdentifyPIDcontroller_UAppearsUncorrelatedWithY NotPossibleToIdentifyPIDcontroller_YsetIsBad PIDControllerDoesNotAppearToBeInAuto PIDControllerIsInCascadeModeWithFrequentSetpointChanges PIDControllerPossiblyInTracking PoorModelFit RegressionProblemFailedToYieldSolution"
  },
  "api/TimeSeriesAnalysis.Dynamic.PidModel.html": {
    "href": "api/TimeSeriesAnalysis.Dynamic.PidModel.html",
    "title": "Class PidModel | TimeSeriesAnalysis reference documentation",
    "keywords": "Class PidModel Simulatable industrial PID-controller This class is as a wrapper for PidController class, that implements ISimulatableModel . To simulate minimum or maximum select controllers, combine this class with Select blocks. The controller paramters belong to different aspects of the controller like, tuning, scaling, gain-scheduling, feedforward and anti-surge are adjusted have been collected into a number of data-classes, linked below: PidParameters PidAntiSurgeParams PidFeedForward PidGainScheduling PidStatus PidScaling PidTuning Inheritance System.Object ModelBaseClass PidModel Implements ISimulatableModel Inherited Members ModelBaseClass.ID ModelBaseClass.ModelInputIDs ModelBaseClass.additiveInputIDs ModelBaseClass.outputID ModelBaseClass.outputIdentID ModelBaseClass.processModelType ModelBaseClass.comment ModelBaseClass.x ModelBaseClass.y ModelBaseClass.color ModelBaseClass.GetID() ModelBaseClass.SetID(String) ModelBaseClass.SetProcessModelType(ModelType) ModelBaseClass.GetProcessModelType() ModelBaseClass.SetInputIDs(String[], Nullable<Int32>) ModelBaseClass.AddSignalToOutput(String) ModelBaseClass.GetModelInputIDs() ModelBaseClass.GetAdditiveInputIDs() ModelBaseClass.GetBothKindsOfInputIDs() ModelBaseClass.SetOutputID(String) ModelBaseClass.GetOutputID() ModelBaseClass.GetOutputIdentID() System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) Namespace : TimeSeriesAnalysis.Dynamic Assembly : TimeSeriesAnalysis.dll Syntax public class PidModel : ModelBaseClass, ISimulatableModel Constructors PidModel(PidParameters, String) Constructor Declaration public PidModel(PidParameters pidParameters, string ID = \"not_named\") Parameters Type Name Description PidParameters pidParameters object containing the paramters of the controller System.String ID Each controller shoudl be given a unique ID Fields pidParameters Declaration public PidParameters pidParameters Field Value Type Description PidParameters Methods GetLengthOfInputVector() Get number of inputs (between 2 and 4) first input is always ymeas, second input is y_setpoint, optionally, input 3 is track signal and input 4 is gain scheduling variable Declaration public override int GetLengthOfInputVector() Returns Type Description System.Int32 Overrides ModelBaseClass.GetLengthOfInputVector() GetModelParameters() Get the model parameters Declaration public PidParameters GetModelParameters() Returns Type Description PidParameters the parameters object of the model GetOutputSignalType() Return the type of the output signal Declaration public override SignalType GetOutputSignalType() Returns Type Description SignalType Overrides ModelBaseClass.GetOutputSignalType() GetSteadyStateInput(Double, Int32, Double[]) [Method not currently implemented] Declaration public double? GetSteadyStateInput(double y0, int inputIdx = 0, double[] givenInputValues = null) Parameters Type Name Description System.Double y0 System.Int32 inputIdx System.Double [] givenInputValues Returns Type Description System.Nullable < System.Double > GetSteadyStateOutput(Double[]) NOT IMPLEMENTED/NOT APPLICABLE Declaration public double? GetSteadyStateOutput(double[] u0) Parameters Type Name Description System.Double [] u0 Returns Type Description System.Nullable < System.Double > IsModelSimulatable(out String) Declaration public bool IsModelSimulatable(out string explainStr) Parameters Type Name Description System.String explainStr Returns Type Description System.Boolean Iterate(Double[], Double, Double) Iterate the PID controller one step Declaration public double[] Iterate(double[] inputs, double timeBase_s, double badDataID = -9999) Parameters Type Name Description System.Double [] inputs is a vector of length 2, 3 or 4. First value is y_process_abs , second value is y_set_abs , optional third value is uTrackSignal , optional fourth value is gainSchedulingVariable System.Double timeBase_s System.Double badDataID value of inputs that is to be treated as NaN Returns Type Description System.Double [] the output u of the pid-controller. If not enough inputs, it returns NaN SetManualOutput(Double) Set the desired manual output fo controller. This output will only be applied if controller is in MANUAL mode. Declaration public void SetManualOutput(double manualOutput_prc) Parameters Type Name Description System.Double manualOutput_prc SetToAutoMode() Set controller in auto Declaration public void SetToAutoMode() SetToManualMode() Set controller in auto Declaration public void SetToManualMode() ToString() Create a nice human-readable summary of all the important data contained in the model object. This is especially useful for unit-testing and development. Declaration public override string ToString() Returns Type Description System.String Overrides System.Object.ToString() WarmStart(Double, Double, Double) Initalizes the controller internal state(integral term) to be steady at the given process value and output value, useful to avoid bumps when staring controller Declaration public void WarmStart(double y_process_abs, double y_set, double u) Parameters Type Name Description System.Double y_process_abs System.Double y_set System.Double u WarmStart(Double[], Double) Initalizes the controller internal state(integral term) to be steady at the given process value and output value, useful to avoid bumps when staring controller Declaration public void WarmStart(double[] inputs, double output) Parameters Type Name Description System.Double [] inputs System.Double output Implements ISimulatableModel"
  },
  "api/TimeSeriesAnalysis.Dynamic.PidModelInputsIdx.html": {
    "href": "api/TimeSeriesAnalysis.Dynamic.PidModelInputsIdx.html",
    "title": "Enum PidModelInputsIdx | TimeSeriesAnalysis reference documentation",
    "keywords": "Enum PidModelInputsIdx This determines the position in the U-vector given to Iterate for the class PIDModel Namespace : TimeSeriesAnalysis.Dynamic Assembly : TimeSeriesAnalysis.dll Syntax public enum PidModelInputsIdx Fields Name Description FeedForward GainScheduling Tracking Y_meas Y_setpoint"
  },
  "api/TimeSeriesAnalysis.Dynamic.PidParameters.html": {
    "href": "api/TimeSeriesAnalysis.Dynamic.PidParameters.html",
    "title": "Class PidParameters | TimeSeriesAnalysis reference documentation",
    "keywords": "Class PidParameters Parameters of the PIDModel PidModel PidController Inheritance System.Object ModelParametersBaseClass PidParameters Inherited Members ModelParametersBaseClass.Fitting System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) Namespace : TimeSeriesAnalysis.Dynamic Assembly : TimeSeriesAnalysis.dll Syntax public class PidParameters : ModelParametersBaseClass Constructors PidParameters() Declaration public PidParameters() Properties AntiSurgeParams PID anti-surge parameters object. This is optional, set to null if not anti-surge PID Declaration public PidAntiSurgeParams AntiSurgeParams { get; set; } Property Value Type Description PidAntiSurgeParams FeedForward Feed-forward parameters object. This is optional, set to null when feedforward is not in use. Declaration public PidFeedForward FeedForward { get; set; } Property Value Type Description PidFeedForward Filtering PID-filtering object. This is optional Declaration public PidFilterParams Filtering { get; set; } Property Value Type Description PidFilterParams GainScheduling Gain-scheduling object. This is optional, set to null gain-scheduling is not in use. Declaration public PidGainScheduling GainScheduling { get; set; } Property Value Type Description PidGainScheduling Kp Proportional gain of controller Declaration public double Kp { get; set; } Property Value Type Description System.Double NanValue If the PID-controller is to be protected from a specific value that is used to identify bad or missing data, specify here Declaration public double NanValue { get; set; } Property Value Type Description System.Double Scaling PID-scaling object. This is optional, set to null to use unscaled PID. Declaration public PidScaling Scaling { get; set; } Property Value Type Description PidScaling Td_s Derivative term time constant[in seconds], 0 = no derivative term Declaration public double Td_s { get; set; } Property Value Type Description System.Double Ti_s Integral time constant [in seconds], 0 = no integral term Declaration public double Ti_s { get; set; } Property Value Type Description System.Double u0 Output value when e=0, used only for P-only controllers, u = Kp*e + u0 Declaration public double u0 { get; set; } Property Value Type Description System.Double Methods AddWarning(PidIdentWarning) Declaration public void AddWarning(PidIdentWarning warning) Parameters Type Name Description PidIdentWarning warning GetWarnings() Declaration public PidIdentWarning[] GetWarnings() Returns Type Description PidIdentWarning [] ToString() Declaration public override string ToString() Returns Type Description System.String Overrides System.Object.ToString()"
  },
  "api/TimeSeriesAnalysis.Dynamic.PidScaling.html": {
    "href": "api/TimeSeriesAnalysis.Dynamic.PidScaling.html",
    "title": "Class PidScaling | TimeSeriesAnalysis reference documentation",
    "keywords": "Class PidScaling Parameters describing PID-controller parameters for scaling PidModel PidController Inheritance System.Object PidScaling Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : TimeSeriesAnalysis.Dynamic Assembly : TimeSeriesAnalysis.dll Syntax public class PidScaling Constructors PidScaling() Constructor Declaration public PidScaling() PidScaling(Double, Double, Double, Double, Boolean) Constructor Declaration public PidScaling(double y_min, double y_max, double u_min, double u_max, bool isKpScalingKpOn) Parameters Type Name Description System.Double y_min System.Double y_max System.Double u_min System.Double u_max System.Boolean isKpScalingKpOn Fields doesSasPidScaleKp Declaration public bool doesSasPidScaleKp Field Value Type Description System.Boolean isDefault Declaration public bool isDefault Field Value Type Description System.Boolean isEstimated Declaration public bool isEstimated Field Value Type Description System.Boolean u_max Declaration public double u_max Field Value Type Description System.Double u_min Declaration public double u_min Field Value Type Description System.Double y_max Declaration public double y_max Field Value Type Description System.Double y_min Declaration public double y_min Field Value Type Description System.Double Methods GetKpScalingFactor() Get a scaling factor to convert and unscaled Kp Declaration public double GetKpScalingFactor() Returns Type Description System.Double GetUmax() Get the maximum U Declaration public double GetUmax() Returns Type Description System.Double GetUmin() Get the minimum U Declaration public double GetUmin() Returns Type Description System.Double GetUScaleFactor() Get the scaling factor of U Declaration public double GetUScaleFactor() Returns Type Description System.Double GetYmax() Get the maximum Y Declaration public double GetYmax() Returns Type Description System.Double GetYmin() Get the minumum Y Declaration public double GetYmin() Returns Type Description System.Double GetYScaleFactor() Get the scaling factor for Y Declaration public double GetYScaleFactor() Returns Type Description System.Double IsDefault() Ask if scaling is at defautl values Declaration public bool IsDefault() Returns Type Description System.Boolean IsEstimated() Ask if the scaling is estimated from data or given a priori Declaration public bool IsEstimated() Returns Type Description System.Boolean IsKpScalingOn() Ask if scaling of Kp is active Declaration public bool IsKpScalingOn() Returns Type Description System.Boolean ScaleYValue(Double) Get the scaled version of an absolute y Declaration public double ScaleYValue(double y_abs) Parameters Type Name Description System.Double y_abs Returns Type Description System.Double Set(Double, Double, Double, Double, Boolean) Set scaling Declaration public void Set(double y_min, double y_max, double u_min, double u_max, bool isKpScalingKpOn) Parameters Type Name Description System.Double y_min System.Double y_max System.Double u_min System.Double u_max System.Boolean isKpScalingKpOn SetDefault() Set scaling to default Declaration public void SetDefault() SetEstimatedUminUmax(Double, Double) Set the estimated u_min and u_max (if it is not known, but guessed from data) Declaration public void SetEstimatedUminUmax(double u_min, double u_max) Parameters Type Name Description System.Double u_min System.Double u_max SetKpScalingOn(Boolean) Turn scaling on or off Declaration public void SetKpScalingOn(bool isKpScalingKpOn) Parameters Type Name Description System.Boolean isKpScalingKpOn"
  },
  "api/TimeSeriesAnalysis.Dynamic.PidSimulator.html": {
    "href": "api/TimeSeriesAnalysis.Dynamic.PidSimulator.html",
    "title": "Class PidSimulator | TimeSeriesAnalysis reference documentation",
    "keywords": "Class PidSimulator Simulate a PIDmodel PID for a given set of inputs timeseries Inheritance System.Object PidSimulator Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : TimeSeriesAnalysis.Dynamic Assembly : TimeSeriesAnalysis.dll Syntax public class PidSimulator Constructors PidSimulator(PidModel) Constructor Declaration public PidSimulator(PidModel model) Parameters Type Name Description PidModel model Methods Simulate(ref UnitDataSet, Boolean, Boolean, Int32) Declaration public double[] Simulate(ref UnitDataSet processDataSet, bool writeResultToUmeasInsteadOfUsim = false, bool doOverwriteU = false, int uWriteColumnIdx = 0) Parameters Type Name Description UnitDataSet processDataSet System.Boolean writeResultToUmeasInsteadOfUsim System.Boolean doOverwriteU System.Int32 uWriteColumnIdx Returns Type Description System.Double []"
  },
  "api/TimeSeriesAnalysis.Dynamic.PidStatus.html": {
    "href": "api/TimeSeriesAnalysis.Dynamic.PidStatus.html",
    "title": "Enum PidStatus | TimeSeriesAnalysis reference documentation",
    "keywords": "Enum PidStatus Enum to classify the status output of PidController.cs Namespace : TimeSeriesAnalysis.Dynamic Assembly : TimeSeriesAnalysis.dll Syntax public enum PidStatus Fields Name Description AUTO Controller is in automatic mode(u varies) MANUAL Controller in in manual mode (u is constant) TRACKING Controller is in Tracking, i.e. it is in automatic, but its output goes to a select block which has selected another controller"
  },
  "api/TimeSeriesAnalysis.Dynamic.PidTuning.html": {
    "href": "api/TimeSeriesAnalysis.Dynamic.PidTuning.html",
    "title": "Class PidTuning | TimeSeriesAnalysis reference documentation",
    "keywords": "Class PidTuning Parameters describing PID-controller tuning (Kp,Ti,Td) PidModel PidController Inheritance System.Object PidTuning Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : TimeSeriesAnalysis.Dynamic Assembly : TimeSeriesAnalysis.dll Syntax public class PidTuning Constructors PidTuning(Double, Double, Boolean) Initalize tuning of Kp and Ti and if controller is reversed. Declaration public PidTuning(double Kp, double Ti, bool isReversed = false) Parameters Type Name Description System.Double Kp System.Double Ti System.Boolean isReversed PidTuning(Double, Double, Double, Boolean) Initalize tuning,Ti and Td are expected to be in seconds, and if Kp sign is to be reversed Declaration public PidTuning(double Kp, double Ti, double Td = 0, bool isReversed = false) Parameters Type Name Description System.Double Kp System.Double Ti System.Double Td System.Boolean isReversed Methods GetKp() Gets the Kp, including the sign(accounts for pid-controller being set to reverese Kp sign) Declaration public double GetKp() Returns Type Description System.Double GetTd() Gets the Td in seoncds Declaration public double GetTd() Returns Type Description System.Double GetTi() Gets the Ti in seoncds Declaration public double GetTi() Returns Type Description System.Double IsReversed() Returns true if the K sign is to be reversed Declaration public bool IsReversed() Returns Type Description System.Boolean SetReversed() Specifies that Kp is to be reversed (By default Kp is not reversed) Declaration public void SetReversed()"
  },
  "api/TimeSeriesAnalysis.Dynamic.PlantSimulator.html": {
    "href": "api/TimeSeriesAnalysis.Dynamic.PlantSimulator.html",
    "title": "Class PlantSimulator | TimeSeriesAnalysis reference documentation",
    "keywords": "Class PlantSimulator Simulates larger \"plant-models\" that is built up connected sub-models, that each implement ISimulatableModel To set up a simulation, first connect models, and then add external input signals. This class handles information about which model is connected to which, and handles callig sub-models in the correct order with the correct input signals. By default, the model attempts to start in steady-state, intalization handled by ProcessSimulatorInitalizer (this requires no user interaction) The building blocks of plant models are PIDModel , DefaultProcessModel and Select UnitModel PidModel PlantSimulatorInitalizer Select Inheritance System.Object PlantSimulator Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : TimeSeriesAnalysis.Dynamic Assembly : TimeSeriesAnalysis.dll Syntax public class PlantSimulator Constructors PlantSimulator(List<ISimulatableModel>, String, String) Constructor Declaration public PlantSimulator(List<ISimulatableModel> processModelList, string plantName = \"\", string plantDescription = \"\") Parameters Type Name Description System.Collections.Generic.List < ISimulatableModel > processModelList A list of process models, each implementing ISimulatableModel System.String plantName optional name of plant, used when serializing System.String plantDescription optional description of plant Fields comments A list of comments that user may have added to track changes made over time Declaration public List<Comment> comments Field Value Type Description System.Collections.Generic.List < Comment > connections Declaration public ConnectionParser connections Field Value Type Description ConnectionParser externalInputSignalIDs Declaration public List<string> externalInputSignalIDs Field Value Type Description System.Collections.Generic.List < System.String > modelDict Declaration public Dictionary<string, ISimulatableModel> modelDict Field Value Type Description System.Collections.Generic.Dictionary < System.String , ISimulatableModel > Properties date The date of when the model was last saved Declaration public DateTime date { get; set; } Property Value Type Description System.DateTime plantDescription A short user-friendly description of what the plant is and does Declaration public string plantDescription { get; set; } Property Value Type Description System.String plantName User-friendly name that may include white spaces Declaration public string plantName { get; set; } Property Value Type Description System.String Methods AddAndConnectExternalSignal(ISimulatableModel, String, SignalType, Int32) Add an external signal. Preferred implementation, as signal can have any ID without naming convention. Declaration public string AddAndConnectExternalSignal(ISimulatableModel model, string signalID, SignalType type, int index = 0) Parameters Type Name Description ISimulatableModel model System.String signalID SignalType type System.Int32 index Returns Type Description System.String returns signalID or null if something went wrong AddExternalSignal(ISimulatableModel, SignalType, Int32) Informs the PlantSimulator that a specific sub-model has a specifc signal at its input, (use for unit testing only, using a naming convention to name signal) Declaration public string AddExternalSignal(ISimulatableModel model, SignalType type, int index = 0) Parameters Type Name Description ISimulatableModel model SignalType type System.Int32 index the index of the signal, this is only needed if this is an input to a multi-input model Returns Type Description System.String ConnectModels(ISimulatableModel, ISimulatableModel, Nullable<Int32>) Connect the output of the upstream model to the input of the downstream model Declaration public string ConnectModels(ISimulatableModel upstreamModel, ISimulatableModel downstreamModel, int? inputIndex = null) Parameters Type Name Description ISimulatableModel upstreamModel the upstream model, meaning the model whose output will be connected ISimulatableModel downstreamModel the downstream model, meaning the model whose input will be connected System.Nullable < System.Int32 > inputIndex input index of the downstream model to connect to (default is first input) Returns Type Description System.String returns the signal id if all is ok, otherwise null. ConnectModelToOutput(ISimulatableModel, ISimulatableModel) Add a disturbance model to the output a given model Declaration public bool ConnectModelToOutput(ISimulatableModel disturbanceModel, ISimulatableModel model) Parameters Type Name Description ISimulatableModel disturbanceModel ISimulatableModel model Returns Type Description System.Boolean ConnectSignalToInput(String, ISimulatableModel, Int32) Connect an existing signal with a given signalID to a new model Declaration public bool ConnectSignalToInput(string signalID, ISimulatableModel model, int idx) Parameters Type Name Description System.String signalID ISimulatableModel model System.Int32 idx Returns Type Description System.Boolean GetConnections() Get ConnenectionParser object Declaration public ConnectionParser GetConnections() Returns Type Description ConnectionParser GetExternalSignalIDs() Get a TimeSeriesDataSet of all external signals of model Declaration public string[] GetExternalSignalIDs() Returns Type Description System.String [] GetModels() Get dictionary of all models Declaration public Dictionary<string, ISimulatableModel> GetModels() Returns Type Description System.Collections.Generic.Dictionary < System.String , ISimulatableModel > GetUnitDataSetForPID(TimeSeriesDataSet, PidModel) Returns a \"unitDataSet\" for the given pidModel in the plant. This function only works when the unit model connected to the pidModel only has a single input. Declaration public UnitDataSet GetUnitDataSetForPID(TimeSeriesDataSet inputData, PidModel pidModel) Parameters Type Name Description TimeSeriesDataSet inputData PidModel pidModel Returns Type Description UnitDataSet GetUnitDataSetForProcess(TimeSeriesDataSet, UnitModel) Declaration public UnitDataSet GetUnitDataSetForProcess(TimeSeriesDataSet inputData, UnitModel unitModel) Parameters Type Name Description TimeSeriesDataSet inputData UnitModel unitModel Returns Type Description UnitDataSet Serialize(String, String) Creates a file JSON representation of this object Declaration public bool Serialize(string newPlantName = null, string path = null) Parameters Type Name Description System.String newPlantName the desired file name and plant name(can be null, in which case the filename should be given in the path argument) System.String path create file in the given path Returns Type Description System.Boolean SerializeTxt() Creates a JSON text string serialization of this object Declaration public string SerializeTxt() Returns Type Description System.String Simulate(TimeSeriesDataSet, out TimeSeriesDataSet) Perform a dynamic simulation of the model provided, given the specified connections and external signals Declaration public bool Simulate(TimeSeriesDataSet inputData, out TimeSeriesDataSet simData) Parameters Type Name Description TimeSeriesDataSet inputData the external signals for the simulation(also, determines the simulation time span and timebase) TimeSeriesDataSet simData the simulated data set to be outputted(excluding the external signals) Returns Type Description System.Boolean SimulateSingle(TimeSeriesDataSet, String, Boolean, out TimeSeriesDataSet) Simulate a single model(any ISimulatable model), using inputData as inputs, If the model is a unitModel and the inputData inludes both the measured y and measured u, the simData will include an estimate of the additive disturbance. Declaration public bool SimulateSingle(TimeSeriesDataSet inputData, string singleModelName, bool doCalcYwithoutAdditiveTerms, out TimeSeriesDataSet simData) Parameters Type Name Description TimeSeriesDataSet inputData System.String singleModelName System.Boolean doCalcYwithoutAdditiveTerms TimeSeriesDataSet simData Returns Type Description System.Boolean SimulateSingle(TimeSeriesDataSet, String, out TimeSeriesDataSet) Simualte single model to get the output including any additive inputs Declaration public bool SimulateSingle(TimeSeriesDataSet inputData, string singleModelName, out TimeSeriesDataSet simData) Parameters Type Name Description TimeSeriesDataSet inputData System.String singleModelName TimeSeriesDataSet simData Returns Type Description System.Boolean SimulateSingleInternal(TimeSeriesDataSet, String, out TimeSeriesDataSet) Simulate single model to get the internal \"x\" unmeasured output that excludes any additive outputs(like disturbances) Declaration public bool SimulateSingleInternal(TimeSeriesDataSet inputData, string singleModelName, out TimeSeriesDataSet simData) Parameters Type Name Description TimeSeriesDataSet inputData System.String singleModelName TimeSeriesDataSet simData Returns Type Description System.Boolean"
  },
  "api/TimeSeriesAnalysis.Dynamic.PlantSimulatorInitalizer.html": {
    "href": "api/TimeSeriesAnalysis.Dynamic.PlantSimulatorInitalizer.html",
    "title": "Class PlantSimulatorInitalizer | TimeSeriesAnalysis reference documentation",
    "keywords": "Class PlantSimulatorInitalizer Intializes a plant simulator in the first data point Currently, only initalizing to steady-state is supported. By design choice, this class traverses the models by logic to initialize the plant model rather than using mathematical programming/matrix solvers. Inheritance System.Object PlantSimulatorInitalizer Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : TimeSeriesAnalysis.Dynamic Assembly : TimeSeriesAnalysis.dll Syntax public class PlantSimulatorInitalizer Constructors PlantSimulatorInitalizer(PlantSimulator) Constructor Declaration public PlantSimulatorInitalizer(PlantSimulator simulator) Parameters Type Name Description PlantSimulator simulator simulator object that already includes connections,models and signals to be simulated Methods ToSteadyStateAndEstimateDisturbances(ref TimeSeriesDataSet, ref TimeSeriesDataSet, Dictionary<String, List<String>>) Initalize the empty datasets to their steady-state values Declaration public bool ToSteadyStateAndEstimateDisturbances(ref TimeSeriesDataSet inputData, ref TimeSeriesDataSet simData, Dictionary<string, List<string>> compLoopDict) Parameters Type Name Description TimeSeriesDataSet inputData TimeSeriesDataSet simData simulation dataset containing only the external signals. The new simulated variables are added to this variable with initial values. System.Collections.Generic.Dictionary < System.String , System.Collections.Generic.List < System.String >> compLoopDict Returns Type Description System.Boolean"
  },
  "api/TimeSeriesAnalysis.Dynamic.PlantSimulatorSerializer.html": {
    "href": "api/TimeSeriesAnalysis.Dynamic.PlantSimulatorSerializer.html",
    "title": "Class PlantSimulatorSerializer | TimeSeriesAnalysis reference documentation",
    "keywords": "Class PlantSimulatorSerializer Inheritance System.Object PlantSimulatorSerializer Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : TimeSeriesAnalysis.Dynamic Assembly : TimeSeriesAnalysis.dll Syntax public class PlantSimulatorSerializer Methods LoadFromJsonFile(String) Re-construct a PlantSimulator object from the json-code created by this class' .Serialize() Declaration public static PlantSimulator LoadFromJsonFile(string fileName) Parameters Type Name Description System.String fileName Returns Type Description PlantSimulator LoadFromJsonTxt(String) Re-construct a PlantSimulator object from the json-code created by this class' .Serialize() Declaration public static PlantSimulator LoadFromJsonTxt(string serializedPlantSimulatorJson) Parameters Type Name Description System.String serializedPlantSimulatorJson Returns Type Description PlantSimulator"
  },
  "api/TimeSeriesAnalysis.Dynamic.ProcessTimeDelayIdentWarnings.html": {
    "href": "api/TimeSeriesAnalysis.Dynamic.ProcessTimeDelayIdentWarnings.html",
    "title": "Enum ProcessTimeDelayIdentWarnings | TimeSeriesAnalysis reference documentation",
    "keywords": "Enum ProcessTimeDelayIdentWarnings Enum of recognized warning or error states during identification of time delays Namespace : TimeSeriesAnalysis.Dynamic Assembly : TimeSeriesAnalysis.dll Syntax public enum ProcessTimeDelayIdentWarnings Fields Name Description FallbackToLinearStaticModel Warning that estimation had to fall back on the static/linear model because other model runs failed. NonConvexObjectiveFunctionSolutionSpace There are other good time delay estimates based on objective function value that are not near the best value This is an indication that something is wrong. NonConvexRsquaredSolutionSpace There are other good time delay estimates based on Rsquared that are not near the best value This is an indication that something is wrong. Nothing No errors or warnings NoUniqueObjectiveFunctionMinima There are several eqvivalently good time delay estiamtes when judged by objective function value. NoUniqueRsquaredMinima There are several eqvivalently good time delay estiamtes when judged by Rsquared. SomeModelRunsFailedToFindSolution Warning that some of the model runs (i.e. for certain time delays) failed to yield a solution. This could be because there is very little information in the dataset, and if most of the information is at the very start this warning can arise as to test longer and longer time delays, a shorter and shorter portion of the dataset is used(some data at the very start needs to be \"cut off\")"
  },
  "api/TimeSeriesAnalysis.Dynamic.Select.html": {
    "href": "api/TimeSeriesAnalysis.Dynamic.Select.html",
    "title": "Class Select | TimeSeriesAnalysis reference documentation",
    "keywords": "Class Select Simulatable select block This block can function either as \"minimum\" or \"maximum\" selector, mainly inteded for simulating \"min select\" or \"max selct\" pid-control by combining with PidModel Inheritance System.Object ModelBaseClass Select Implements ISimulatableModel Inherited Members ModelBaseClass.ID ModelBaseClass.ModelInputIDs ModelBaseClass.additiveInputIDs ModelBaseClass.outputID ModelBaseClass.outputIdentID ModelBaseClass.processModelType ModelBaseClass.comment ModelBaseClass.x ModelBaseClass.y ModelBaseClass.color ModelBaseClass.GetID() ModelBaseClass.SetID(String) ModelBaseClass.SetProcessModelType(ModelType) ModelBaseClass.GetProcessModelType() ModelBaseClass.SetInputIDs(String[], Nullable<Int32>) ModelBaseClass.AddSignalToOutput(String) ModelBaseClass.GetModelInputIDs() ModelBaseClass.GetAdditiveInputIDs() ModelBaseClass.GetBothKindsOfInputIDs() ModelBaseClass.SetOutputID(String) ModelBaseClass.GetOutputID() ModelBaseClass.GetOutputIdentID() ModelBaseClass.GetLengthOfInputVector() System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : TimeSeriesAnalysis.Dynamic Assembly : TimeSeriesAnalysis.dll Syntax public class Select : ModelBaseClass, ISimulatableModel Constructors Select(SelectType, String) Constructor Declaration public Select(SelectType type, string ID) Parameters Type Name Description SelectType type System.String ID Fields type Declaration public SelectType type Field Value Type Description SelectType Methods GetOutputSignalType() Gives the type of the output signal Declaration public override SignalType GetOutputSignalType() Returns Type Description SignalType Overrides ModelBaseClass.GetOutputSignalType() GetSteadyStateInput(Double, Int32, Double[]) Not implemented Declaration public double? GetSteadyStateInput(double y0, int inputIdx = 0, double[] givenInputValues = null) Parameters Type Name Description System.Double y0 System.Int32 inputIdx System.Double [] givenInputValues Returns Type Description System.Nullable < System.Double > GetSteadyStateOutput(Double[]) Get the steady state value of the model output Declaration public double? GetSteadyStateOutput(double[] u0) Parameters Type Name Description System.Double [] u0 vector of inputs for which the steady state is to be calculated Returns Type Description System.Nullable < System.Double > the steady-state value, if it is not possible to calculate, a null is returned IsModelSimulatable(out String) Declaration public bool IsModelSimulatable(out string explain) Parameters Type Name Description System.String explain Returns Type Description System.Boolean Iterate(Double[], Double, Double) Iterate simulation Declaration public double[] Iterate(double[] inputsU, double timeBase_s, double badDataID = -9999) Parameters Type Name Description System.Double [] inputsU System.Double timeBase_s System.Double badDataID Returns Type Description System.Double [] WarmStart(Double[], Double) Not implemented Declaration public void WarmStart(double[] inputs, double output) Parameters Type Name Description System.Double [] inputs System.Double output Implements ISimulatableModel"
  },
  "api/TimeSeriesAnalysis.Dynamic.SelectType.html": {
    "href": "api/TimeSeriesAnalysis.Dynamic.SelectType.html",
    "title": "Enum SelectType | TimeSeriesAnalysis reference documentation",
    "keywords": "Enum SelectType An enum of the type of Select model Namespace : TimeSeriesAnalysis.Dynamic Assembly : TimeSeriesAnalysis.dll Syntax public enum SelectType Fields Name Description MAX Max-select MIN Min-select NOT_SET This value should not occur"
  },
  "api/TimeSeriesAnalysis.Dynamic.SerializeHelper.html": {
    "href": "api/TimeSeriesAnalysis.Dynamic.SerializeHelper.html",
    "title": "Class SerializeHelper | TimeSeriesAnalysis reference documentation",
    "keywords": "Class SerializeHelper Inheritance System.Object SerializeHelper Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : TimeSeriesAnalysis.Dynamic Assembly : TimeSeriesAnalysis.dll Syntax public static class SerializeHelper Methods Serialize(String, PlantSimulator, TimeSeriesDataSet, TimeSeriesDataSet) Declaration public static void Serialize(string name, PlantSimulator plantSim, TimeSeriesDataSet inputData, TimeSeriesDataSet simData) Parameters Type Name Description System.String name PlantSimulator plantSim TimeSeriesDataSet inputData TimeSeriesDataSet simData"
  },
  "api/TimeSeriesAnalysis.Dynamic.SignalNamer.html": {
    "href": "api/TimeSeriesAnalysis.Dynamic.SignalNamer.html",
    "title": "Class SignalNamer | TimeSeriesAnalysis reference documentation",
    "keywords": "Class SignalNamer Handles naming of individual signals in a process simulation Inheritance System.Object SignalNamer Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : TimeSeriesAnalysis.Dynamic Assembly : TimeSeriesAnalysis.dll Syntax public class SignalNamer Methods EstDisturbance(String) Returns the standardized naming of how to denote the estimated disturbance signal of a pid-loop Declaration public static string EstDisturbance(string unitModelId) Parameters Type Name Description System.String unitModelId Returns Type Description System.String EstDisturbance(ISimulatableModel) Returns the standardized naming of how to denote the estimated disturbance signal of a pid-loop Declaration public static string EstDisturbance(ISimulatableModel unitModel) Parameters Type Name Description ISimulatableModel unitModel Returns Type Description System.String GetSignalName(String, SignalType, Int32) Get a unique signal name for a given signal, based on the model and signal type. Declaration public static string GetSignalName(string modelID, SignalType signalType, int idx = 0) Parameters Type Name Description System.String modelID SignalType signalType System.Int32 idx models can have multiple inputs, in which case an index is needed to uniquely identify it. Returns Type Description System.String a unique string identifier that is used to identify a signal"
  },
  "api/TimeSeriesAnalysis.Dynamic.SignalType.html": {
    "href": "api/TimeSeriesAnalysis.Dynamic.SignalType.html",
    "title": "Enum SignalType | TimeSeriesAnalysis reference documentation",
    "keywords": "Enum SignalType Enum of types of signals that ProcessSimulator must differentiate between Namespace : TimeSeriesAnalysis.Dynamic Assembly : TimeSeriesAnalysis.dll Syntax public enum SignalType Fields Name Description Disturbance_D The disturbance on the output of a \"Process\" External_U An input to a model that is not from a simulated PID-controller NonPIDInternal_U An input to a model that is an output of another process-model Output_Y The output of a \"SubProcess\" PID_U The output/manipulated variable of a PID-controller SelectorOut The output of a select block Setpoint_Yset Setpoint of a PID-controller Unset Unset, should not occur"
  },
  "api/TimeSeriesAnalysis.Dynamic.TimeDelay.html": {
    "href": "api/TimeSeriesAnalysis.Dynamic.TimeDelay.html",
    "title": "Class TimeDelay | TimeSeriesAnalysis reference documentation",
    "keywords": "Class TimeDelay Delays a signal by a specific number of time steps, keeping an internal buffer of delayed values between iterations. This is a reasuble class for providing time-delay functionality to simulatable models. Inheritance System.Object TimeDelay Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : TimeSeriesAnalysis.Dynamic Assembly : TimeSeriesAnalysis.dll Syntax public class TimeDelay Constructors TimeDelay(Double, Double) Initalize Declaration public TimeDelay(double timeBase_s, double timeDelay_s) Parameters Type Name Description System.Double timeBase_s the simulation time interval between each subsequent call to Delay (in seconds) System.Double timeDelay_s the time delay to be simulated(in seconds). Note that the time delay will be rounded up to neares whole number factor of timeBase_s Methods Delay(Double) Delays output by a certain number of time steps Declaration public double Delay(double inputSignal) Parameters Type Name Description System.Double inputSignal input signal to be delayed Returns Type Description System.Double a version of inputSignal that is delayed"
  },
  "api/TimeSeriesAnalysis.Dynamic.UnitDataSet.html": {
    "href": "api/TimeSeriesAnalysis.Dynamic.UnitDataSet.html",
    "title": "Class UnitDataSet | TimeSeriesAnalysis reference documentation",
    "keywords": "Class UnitDataSet The data for a porition of a process, containg only one output and one or multiple inputs that influence it Inheritance System.Object UnitDataSet Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : TimeSeriesAnalysis.Dynamic Assembly : TimeSeriesAnalysis.dll Syntax public class UnitDataSet Constructors UnitDataSet(String) Constructor for data set without inputs - for \"autonomous\" processes such as sinusoids, rand walks or other disturbancs. Declaration public UnitDataSet(string name = null) Parameters Type Name Description System.String name optional internal name of dataset UnitDataSet((Double[], DateTime[]), (Double[], DateTime[]), String) Create a dataset for single-input system from two signals that have separate but overlapping time-series(each given as value-date tuples) Declaration public UnitDataSet((double[], DateTime[]) u, (double[], DateTime[]) y_meas, string name = null) Parameters Type Name Description System.ValueTuple < System.Double [], System.DateTime []> u tuple of values and dates describing u System.ValueTuple < System.Double [], System.DateTime []> y_meas tuple of values and dates describing y System.String name name of dataset UnitDataSet(UnitDataSet) Create a copy of an existing data set Declaration public UnitDataSet(UnitDataSet otherDataSet) Parameters Type Name Description UnitDataSet otherDataSet UnitDataSet(UnitDataSet, Int32) Create a downsampled copy of an existing data set Declaration public UnitDataSet(UnitDataSet originalDataSet, int downsampleFactor) Parameters Type Name Description UnitDataSet originalDataSet System.Int32 downsampleFactor factor by which to downsample the original dataset Fields IndicesToIgnore Indices that are ignored in Y during fitting. Declaration public List<int> IndicesToIgnore Field Value Type Description System.Collections.Generic.List < System.Int32 > Properties BadDataID Some systems for storing data do not support \"NaN\", but instead some other magic value is reserved for indicating that a value is bad or missing. Declaration public double BadDataID { get; set; } Property Value Type Description System.Double D Additve output disturbance D (Y = X+ D) Declaration public double[] D { get; set; } Property Value Type Description System.Double [] ProcessName Name Declaration public string ProcessName { get; } Property Value Type Description System.String Times Timestamps Declaration public DateTime[] Times { get; set; } Property Value Type Description System.DateTime [] U Input U (given) Declaration public double[, ] U { get; set; } Property Value Type Description System.Double [,] U_sim Input U(simulated) - in the case of PID-control Declaration public double[, ] U_sim { get; set; } Property Value Type Description System.Double [,] Warnings list of warings during identification Declaration public List<UnitWarnings> Warnings { get; set; } Property Value Type Description System.Collections.Generic.List < UnitWarnings > Y_meas Output Y (measured) Declaration public double[] Y_meas { get; set; } Property Value Type Description System.Double [] Y_setpoint Setpoint - (if sub-process includes a PID-controller) Declaration public double[] Y_setpoint { get; set; } Property Value Type Description System.Double [] Y_sim Output Y (simulated) Declaration public double[] Y_sim { get; set; } Property Value Type Description System.Double [] Methods CreateTimeStamps(Double, Nullable<DateTime>) Declaration public void CreateTimeStamps(double timeBase_s, DateTime? t0 = null) Parameters Type Name Description System.Double timeBase_s System.Nullable < System.DateTime > t0 DetermineIndicesToIgnore(FittingSpecs) Tags indices to be removed if either of the output is outside the range defined by [Y_min,Y_max], an input is outside [u_min, umax] or if any data matches badDataId Results are stored in \"IndicesToIgnore\", not outputted. Declaration public void DetermineIndicesToIgnore(FittingSpecs fittingSpecs) Parameters Type Name Description FittingSpecs fittingSpecs GetAverageU() Get the average value of each input in the dataset. This is useful when defining model local around a working point. Declaration public double[] GetAverageU() Returns Type Description System.Double [] an array of averages, each corrsponding to one column of U. Returns null if it was not possible to calculate averages GetNumDataPoints() Declaration public int GetNumDataPoints() Returns Type Description System.Int32 GetTimeBase() Gets the time between samples in seconds, returns zero if times are not set Declaration public double GetTimeBase() Returns Type Description System.Double GetTimeSpan() Get the time spanned by the dataset Declaration public TimeSpan GetTimeSpan() Returns Type Description System.TimeSpan The time spanned by the dataset, or null if times are not set SetInputUFitMaxAndMin(Double[], Double[]) Tags indices to be removed if either of the inputs are outside the range defined by [uMinFit,uMaxFit]. uMinFit,uMaxFit may include NaN or BadDataID for values if no max/min applies to the specific input Declaration public void SetInputUFitMaxAndMin(double[] uMinFit, double[] uMaxFit) Parameters Type Name Description System.Double [] uMinFit vector of minimum values for each element in U System.Double [] uMaxFit vector of maximum values for each element in U"
  },
  "api/TimeSeriesAnalysis.Dynamic.UnitdentWarnings.html": {
    "href": "api/TimeSeriesAnalysis.Dynamic.UnitdentWarnings.html",
    "title": "Enum UnitdentWarnings | TimeSeriesAnalysis reference documentation",
    "keywords": "Enum UnitdentWarnings Enum of recognized warning or error states during identification of process model Namespace : TimeSeriesAnalysis.Dynamic Assembly : TimeSeriesAnalysis.dll Syntax public enum UnitdentWarnings Fields Name Description ClosedLoopEst_GlobalSearchFailedToFindLocalMinima If this is a closed loop system where setpoints of PID-controller change, and the \"global search\" at step1 of the ClosedLoopIdentifier failed to find a local minima when trying different gains. This warning likely means that the linear gain can be totally off the mark and may be too low. ConstantInputU One or more inputs were constant and not identifiable, this can affect other parameters as well, and consider removing the input or using a different dataset CorrelatedInputsU Correlated inputs DataSetVeryShortComparedtoTMax The dataset is time span is very short compared to the maximal time-constant given as input to the algorithm DynamicModelEstimationFailed UnitIdentify was able to solve the given estimation problem for the linear/static case, but when adding dynamics, the estimation failed for some reason. NonCausalNegativeTimeConstant A negative time constant was returned, this is \"non-causal\", and could be due to a time-shift between u and y in the dataset. Nothing No errors or warnings NotPossibleToIdentify It was not possible to identify the ReEstimateBiasDisabledDueToNonzeroDisturbance If disturbance is nonzero, then re-estimation of bias is turned off ReEstimateBiasFailed Re-estimating bias method returned null, so the bias from the intial estimation is used, be careful the bias estimate may be off! RegressionProblemFailedToYieldSolution RegressionProblemNaNSolution Some of the parameters returned were NaN, this can happen in the input and output vectors are all constants, such as all-zero TimeConstantEstimateNotConsistent Time constant estimates vary significantly across dataset, indicating that something is wrong TimeConstantEstimateTooBig Estimation returned an enourmous time constant, this is an indication of something is wrong TimeConstantNotIdentifiable Time constant is not identifiable from dataset TimeDelayAtMaximumConstraint The time delay which gave the lowest objective function is the biggest allowed time delay consider increasing this limit or if something is wrong TimeDelayInternalInconsistencyBetweenObjFunAndUncertainty When considering different time delays internally, you expect the \"best\" to have both the lowest objective functino and the lowest paramter uncertainty but for some reason this is not the case"
  },
  "api/TimeSeriesAnalysis.Dynamic.UnitIdentifier.html": {
    "href": "api/TimeSeriesAnalysis.Dynamic.UnitIdentifier.html",
    "title": "Class UnitIdentifier | TimeSeriesAnalysis reference documentation",
    "keywords": "Class UnitIdentifier Identifier of the \"Default\" process model - a dynamic process model with time-constant, time-delay, linear process gain and optional (nonlinear)curvature process gains. This model class is sufficent for real-world linear or weakly nonlinear dynamic systems, yet also introduces the fewest possible parameters to describe the system in an attempt to avoiding over-fitting/over-parametrization The \"default\" process model is identified using a linear-in-parameters paramterization(paramters a,b,c), so that it can be solved by linear regression and identification should thus be both fast and stable. The issue with the parametriation(a,b,c) is that the meaning of each paramter is less inutitive, for instance the time constant depends on a, but linear gain depends on both a and b, while curvature depends on a and c. Looking at the unceratinty of each parameter to determine if the model should be dynamic or static or what the uncertainty of the time constant is, is very hard, and this observation motivates re-paramtrizing the model after identification. When assessing and simulating the model, parmaters are converted into more intuitive paramters \"time constant\", \"linear gains\" and \"curvature gain\" which are a different parametrization. The UnitIdentifier, UnitModel and UnitParamters classes handle this transition seamlessly to the user. Uncertainty is expressed in terms of this more intuitive parametrization, to allow for a more intuitive assessment of the parameters. Another advantage of the paramterization, is that the model internally separates betwen stedy-state and transient state, you can at any instance \"turn off\" dynamics and request the steady-state model output for the current input. This is useful if you have transient data that you want to analyze in the steady-state, as you can then fit the model to all available data-points without having to select what data points you beleive are at steady state, then you can disable dynamic terms to do a static analysis of the dynamic model. Time-delay is an integer parameter, and finding the time-delay alongside continous paramters turns the identification problem into a linear mixed-integer problem. The time delay identification is done by splitting the time-delay estimation from continous parameter identification, turning the solver into a sequential optimization solver. This logic to re-run estimation for multiple time-delays and selecting the best estiamte of time delay is deferred to TimeSeriesAnalysis.Dynamic.UnitTimeDelayIdentifier Since the aim is to identify transients/dynamics, the regression is done on model differences rather than absolute values Inheritance System.Object UnitIdentifier Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : TimeSeriesAnalysis.Dynamic Assembly : TimeSeriesAnalysis.dll Syntax public static class UnitIdentifier Methods Identify(ref UnitDataSet, FittingSpecs, Boolean) Declaration public static UnitModel Identify(ref UnitDataSet dataSet, FittingSpecs fittingSpecs = null, bool doEstimateTimeDelay = true) Parameters Type Name Description UnitDataSet dataSet FittingSpecs fittingSpecs System.Boolean doEstimateTimeDelay Returns Type Description UnitModel IdentifyLinear(ref UnitDataSet, FittingSpecs, Boolean) Identifies the \"Default\" process model that best fits the dataSet given, but disables curvatures Declaration public static UnitModel IdentifyLinear(ref UnitDataSet dataSet, FittingSpecs fittingSpecs, bool doEstimateTimeDelay = true) Parameters Type Name Description UnitDataSet dataSet The dataset containing the ymeas and U that is to be fitted against, a new y_sim is also added FittingSpecs fittingSpecs System.Boolean doEstimateTimeDelay if set to false, estimation of time delays are disabled Returns Type Description UnitModel the identified model parameters and some information about the fit IdentifyLinearAndStatic(ref UnitDataSet, FittingSpecs, Boolean) Identifies the \"Default\" process model that best fits the dataSet given, but disables curvatures and time-constants Declaration public static UnitModel IdentifyLinearAndStatic(ref UnitDataSet dataSet, FittingSpecs fittingSpecs, bool doEstimateTimeDelay = true) Parameters Type Name Description UnitDataSet dataSet The dataset containing the ymeas and U that is to be fitted against, a new y_sim is also added FittingSpecs fittingSpecs System.Boolean doEstimateTimeDelay if set to false, modeling does not identify time-delays Returns Type Description UnitModel the identified model parameters and some information about the fit IdentifyLinearAndStaticDiff(ref UnitDataSet, FittingSpecs, Boolean) Identifies the process model that best fits the dataSet given by minimizing differences y[k]-y[k-1], but disables curvatures and time-constants. Declaration public static UnitModel IdentifyLinearAndStaticDiff(ref UnitDataSet dataSet, FittingSpecs fittingSpecs, bool doEstimateTimeDelay = true) Parameters Type Name Description UnitDataSet dataSet The dataset containing the ymeas and U that is to be fitted against, a new y_sim is also added FittingSpecs fittingSpecs System.Boolean doEstimateTimeDelay if set to false, modeling does not identify time-delays Returns Type Description UnitModel the identified model parameters and some information about the fit IdentifyLinearAndStaticWhileKeepingLinearGainFixed(UnitDataSet, Int32, Double, Double, Double) Freezed one input to a given pre-determined value, but re-identifies other static paramters. This is useful if doing a \"global search\" where varying a single gain. Declaration public static UnitModel IdentifyLinearAndStaticWhileKeepingLinearGainFixed(UnitDataSet dataSet, int inputIdxToFix, double inputProcessGainValueToFix, double u0_fixedInput, double uNorm_fixedInput) Parameters Type Name Description UnitDataSet dataSet System.Int32 inputIdxToFix the index of the value to freeze System.Double inputProcessGainValueToFix the linear gain to freeze the at System.Double u0_fixedInput System.Double uNorm_fixedInput Returns Type Description UnitModel identified model, to check if identification suceeded, check .modelParameters.Fitting.WasAbleToIdentify IdentifyLinearDiff(ref UnitDataSet, FittingSpecs, Boolean) Identifies the \"Default\" process model based on differences y[k]-y[k-1] that best fits the dataSet given, but disables curvatures Declaration public static UnitModel IdentifyLinearDiff(ref UnitDataSet dataSet, FittingSpecs fittingSpecs, bool doEstimateTimeDelay = true) Parameters Type Name Description UnitDataSet dataSet The dataset containing the ymeas and U that is to be fitted against, a new y_sim is also added FittingSpecs fittingSpecs System.Boolean doEstimateTimeDelay if set to false, estimation of time delays are disabled Returns Type Description UnitModel the identified model parameters and some information about the fit IdentifyStatic(ref UnitDataSet, FittingSpecs) Identifies the \"Default\" process model that best fits the dataSet given, but no time-constants Declaration public static UnitModel IdentifyStatic(ref UnitDataSet dataSet, FittingSpecs fittingSpecs = null) Parameters Type Name Description UnitDataSet dataSet The dataset containing the ymeas and U that is to be fitted against, a new element y_sim is also added to this dataset FittingSpecs fittingSpecs Returns Type Description UnitModel the identified model parameters and some information about the fit SimulateAndReEstimateBias(UnitDataSet, UnitParameters) Declaration public static (double? , double[]) SimulateAndReEstimateBias(UnitDataSet dataSet, UnitParameters parameters) Parameters Type Name Description UnitDataSet dataSet UnitParameters parameters Returns Type Description System.ValueTuple < System.Nullable < System.Double >, System.Double []>"
  },
  "api/TimeSeriesAnalysis.Dynamic.UnitModel.html": {
    "href": "api/TimeSeriesAnalysis.Dynamic.UnitModel.html",
    "title": "Class UnitModel | TimeSeriesAnalysis reference documentation",
    "keywords": "Class UnitModel Simulatable \"default\" process model. This is a model that can be either dynamic or static, have one or multiple inputs and can be either linear in inputs or have inputs nonlinearity described by a second-order polynominal. Dynamics can be either 1.order time-constant, time-delay or both. The model also supports \"additive\" signals added to its output(intended for modeling disturbances.) The model is designed to lend itself well to identificaiton from industrial time-series datasets, and is supported by the accompanying identificaiton method UnitIdentifier . This model is also intended to be co-simulated with PidModel by PlantSimulator to study process control feedback loops. It is assumed that for most unit processes in industrial process control systems can be described sufficiently by this model, and thus that larger plants can be modeled by connecting unit models based on this model structure. It would be possible to extend this model to also describe second-order dynamics along the same principles by the intorduction of one additional paramters in future work. See also: UnitParameters Inheritance System.Object ModelBaseClass UnitModel Implements ISimulatableModel Inherited Members ModelBaseClass.ID ModelBaseClass.ModelInputIDs ModelBaseClass.additiveInputIDs ModelBaseClass.outputID ModelBaseClass.outputIdentID ModelBaseClass.processModelType ModelBaseClass.comment ModelBaseClass.x ModelBaseClass.y ModelBaseClass.color ModelBaseClass.GetID() ModelBaseClass.SetID(String) ModelBaseClass.SetProcessModelType(ModelType) ModelBaseClass.GetProcessModelType() ModelBaseClass.SetInputIDs(String[], Nullable<Int32>) ModelBaseClass.AddSignalToOutput(String) ModelBaseClass.GetModelInputIDs() ModelBaseClass.GetAdditiveInputIDs() ModelBaseClass.GetBothKindsOfInputIDs() ModelBaseClass.SetOutputID(String) ModelBaseClass.GetOutputID() ModelBaseClass.GetOutputIdentID() System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) Namespace : TimeSeriesAnalysis.Dynamic Assembly : TimeSeriesAnalysis.dll Syntax public class UnitModel : ModelBaseClass, ISimulatableModel Constructors UnitModel(UnitParameters, String) Constructor Declaration [JsonConstructor] public UnitModel(UnitParameters modelParameters, string ID = \"not_named\") Parameters Type Name Description UnitParameters modelParameters model paramter object System.String ID a unique string that identifies this model in larger process models UnitModel(UnitParameters, UnitDataSet, String) Initalizer of model that for the given dataSet also creates the resulting y_sim Declaration public UnitModel(UnitParameters modelParameters, UnitDataSet dataSet, string ID = \"not_named\") Parameters Type Name Description UnitParameters modelParameters UnitDataSet dataSet System.String ID a unique string that identifies this model in larger process models Fields modelParameters Declaration public UnitParameters modelParameters Field Value Type Description UnitParameters Methods GetFittedDataSet() Declaration public UnitDataSet GetFittedDataSet() Returns Type Description UnitDataSet GetLengthOfInputVector() Returns the number of external inputs U of the model. Note that this model may have an disturbance signal added to the output in addition to the other signals. Declaration public override int GetLengthOfInputVector() Returns Type Description System.Int32 Overrides ModelBaseClass.GetLengthOfInputVector() GetModelParameters() Get the objet of model paramters contained in the model Declaration public UnitParameters GetModelParameters() Returns Type Description UnitParameters Model paramter object GetOutputSignalType() Get the type of output signal Declaration public override SignalType GetOutputSignalType() Returns Type Description SignalType Overrides ModelBaseClass.GetOutputSignalType() GetSteadyStateInput(Double, Int32, Double[]) Calcuate the steady-state input if the output and all-but-one input are known Declaration public double? GetSteadyStateInput(double x0, int inputIdx = 0, double[] givenInputs = null) Parameters Type Name Description System.Double x0 If no additive inputs y=x, otherwise subtract additive inputs from y to get x System.Int32 inputIdx System.Double [] givenInputs Returns Type Description System.Nullable < System.Double > GetSteadyStateOutput(Double[]) Get the steady state output y for a given input(including additive terms) Declaration public double? GetSteadyStateOutput(double[] u0) Parameters Type Name Description System.Double [] u0 Returns Type Description System.Nullable < System.Double > IsModelSimulatable(out String) Declaration public bool IsModelSimulatable(out string explainStr) Parameters Type Name Description System.String explainStr Returns Type Description System.Boolean IsModelStatic() Is the model static or dynamic? Declaration public bool IsModelStatic() Returns Type Description System.Boolean Returns true if the model is static(no time constant or time delay terms),otherwise false. Iterate(Double[], Double, Double) Iterates the process model state one time step, based on the inputs given Declaration public double[] Iterate(double[] inputs, double timeBase_s, double badValueIndicator = -9999) Parameters Type Name Description System.Double [] inputs vector of inputs U. Optionally the output disturbance D can be added as the last value. System.Double timeBase_s System.Double badValueIndicator value in U that is to be treated as NaN Returns Type Description System.Double [] the updated process model state(x) - the output without any output noise or disturbance. NaN is returned if model was not able to be identfied, or if no good values U values yet have been given. If some data points in U inputsU are NaN or equal to badValueIndicator , the last good value is returned SetFittedDataSet(UnitDataSet) Declaration public void SetFittedDataSet(UnitDataSet dataset) Parameters Type Name Description UnitDataSet dataset SetModelParameters(UnitParameters) Update the paramter object of the model Declaration public void SetModelParameters(UnitParameters parameters) Parameters Type Name Description UnitParameters parameters ToString() Create a nice human-readable summary of all the important data contained in the model object. This is especially useful for unit-testing and development. Declaration public override string ToString() Returns Type Description System.String Overrides System.Object.ToString() WarmStart(Double[], Double) Warm-starting Declaration public void WarmStart(double[] inputs = null, double output = 0) Parameters Type Name Description System.Double [] inputs not used, leave as null System.Double output not used, leave as null Implements ISimulatableModel"
  },
  "api/TimeSeriesAnalysis.Dynamic.UnitParameters.html": {
    "href": "api/TimeSeriesAnalysis.Dynamic.UnitParameters.html",
    "title": "Class UnitParameters | TimeSeriesAnalysis reference documentation",
    "keywords": "Class UnitParameters Parameters data class of the UnitModel Inheritance System.Object ModelParametersBaseClass UnitParameters Inherited Members ModelParametersBaseClass.Fitting System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : TimeSeriesAnalysis.Dynamic Assembly : TimeSeriesAnalysis.dll Syntax public class UnitParameters : ModelParametersBaseClass Constructors UnitParameters() Default constructor Declaration public UnitParameters() Fields FittingSpecs Declaration public FittingSpecs FittingSpecs Field Value Type Description FittingSpecs Y_max the maximum allowed output value(if set to NaN, no maximum is applied) Declaration public double Y_max Field Value Type Description System.Double Y_min The minimum allowed output value(if set to NaN, no minimum is applied) Declaration public double Y_min Field Value Type Description System.Double Properties Bias The constant bias that is added so that models and dataset match on average, this value will depend on U0 and other parameters. Declaration public double Bias { get; set; } Property Value Type Description System.Double BiasUnc The 95% uncertainty of the bias Declaration public double? BiasUnc { get; set; } Property Value Type Description System.Nullable < System.Double > Curvatures The nonlinear curvature of the process gain, this paramter is multiplied + Curvatures*((u-u0)/Unorm)^2. If value is null c> then no curvatures are added to the model Declaration public double[] Curvatures { get; set; } Property Value Type Description System.Double [] CurvatureUnc The unceratainties of the curvature term of the process gains Declaration public double[] CurvatureUnc { get; set; } Property Value Type Description System.Double [] LinearGains An array of gains that determine how much in the steady state each input change affects the output(multiplied with (u-u0)) Declaration public double[] LinearGains { get; set; } Property Value Type Description System.Double [] LinearGainUnc An array of 95% uncertatinty in the linear gains (u-u0)) Declaration public double[] LinearGainUnc { get; set; } Property Value Type Description System.Double [] TimeConstant_s A time constant in seconds, the time a 1. order linear system requires to do 63% of a step response. Set to zero to turn off time constant in model. Declaration public double TimeConstant_s { get; set; } Property Value Type Description System.Double TimeConstantUnc_s The uncertinty of the time constant estimate Declaration public double? TimeConstantUnc_s { get; set; } Property Value Type Description System.Nullable < System.Double > TimeDelay_s The time delay in seconds.This number needs to be a multiple of the sampling rate. Set to zero to turn of time delay in model. Declaration public double TimeDelay_s { get; set; } Property Value Type Description System.Double U0 The working point of the model, the value of each U around which the model is localized. If value is null c> then no U0 is used in the model Declaration public double[] U0 { get; set; } Property Value Type Description System.Double [] UNorm A \"normal range\" of U that is used in the nonlinear curvature term ((u-u0)/Unorm)^2. If value is null c> then no Unorm is used in the model Declaration public double[] UNorm { get; set; } Property Value Type Description System.Double [] Methods AddWarning(UnitdentWarnings) Adds a identifiation warning to the object Declaration public void AddWarning(UnitdentWarnings warning) Parameters Type Name Description UnitdentWarnings warning CreateCopy() Declaration public UnitParameters CreateCopy() Returns Type Description UnitParameters GetNumInputs() Get the number of inputs U to the model. Declaration public int GetNumInputs() Returns Type Description System.Int32 GetProcessGains() Get all process gains (including both linear and any nonlinear terms) Declaration public double[] GetProcessGains() Returns Type Description System.Double [] may return null if no process gains given GetProcessGainUncertainties() Get all the process gain uncertainties Declaration public double[] GetProcessGainUncertainties() Returns Type Description System.Double [] GetTotalCombinedProcessGain(Int32) Return the \"total combined\" process gain for a given index at u=u0, a combination of lineargain and curvature gain Note that for nonlinear processes, the process gain is given by a combination of the linear and curvature terms of the model : dy/du(u=u0) Declaration public double GetTotalCombinedProcessGain(int inputIdx) Parameters Type Name Description System.Int32 inputIdx Returns Type Description System.Double GetTotalCombinedProcessGainUncertainty(Int32) Return the process gain uncertatinty for a given input index at u=u0 Note that for nonlinear processes, the process gain is given by a combination of the linear and curvature terms of the model : dy/du(u=u0) Declaration public double GetTotalCombinedProcessGainUncertainty(int inputIdx) Parameters Type Name Description System.Int32 inputIdx Returns Type Description System.Double GetWarningList() Get the list of all warnings given during identification of the model Declaration public List<UnitdentWarnings> GetWarningList() Returns Type Description System.Collections.Generic.List < UnitdentWarnings >"
  },
  "api/TimeSeriesAnalysis.Dynamic.UnitSimulator.html": {
    "href": "api/TimeSeriesAnalysis.Dynamic.UnitSimulator.html",
    "title": "Class UnitSimulator | TimeSeriesAnalysis reference documentation",
    "keywords": "Class UnitSimulator Stand-alone simulation of any ISimulatableModel model. Inheritance System.Object UnitSimulator Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : TimeSeriesAnalysis.Dynamic Assembly : TimeSeriesAnalysis.dll Syntax public class UnitSimulator Constructors UnitSimulator(UnitModel) Constructor Declaration public UnitSimulator(UnitModel model) Parameters Type Name Description UnitModel model Methods CoSimulate(PidModel, ref UnitDataSet, Boolean, Boolean) Declaration public bool CoSimulate(PidModel pid, ref UnitDataSet processDataSet, bool pidActsOnPastStep = true, bool writeResultToYmeasInsteadOfYsim = false) Parameters Type Name Description PidModel pid UnitDataSet processDataSet System.Boolean pidActsOnPastStep System.Boolean writeResultToYmeasInsteadOfYsim Returns Type Description System.Boolean Simulate(ref UnitDataSet, Boolean, Boolean) Simulates the output of the model based on the processDataSet.U provided, by default the output is written back to processDataSet.Y_sim or processDataSet.Y_meas By default this method adds to Y_sim o Y_meas if they already contain values. Declaration public double[] Simulate(ref UnitDataSet processDataSet, bool writeResultToYmeasInsteadOfYsim = false, bool doOverwriteY = false) Parameters Type Name Description UnitDataSet processDataSet dataset containing the inputs U to be simulated System.Boolean writeResultToYmeasInsteadOfYsim if true , output is written to processDataSet.ymeas instead of processDataSet.ysim System.Boolean doOverwriteY (default is false)if true , output overwrites any data in processDataSet.ymeas or processDataSet.ysim Returns Type Description System.Double [] Returns the simulate y if able to simulate,otherwise null SimulateYmeas(ref UnitDataSet, Double) Simulation is written to ymeas instead of ysim. This is useful when creating generic datasets for testing/test driven development. Declaration public bool SimulateYmeas(ref UnitDataSet processDataSet, double noiseAmplitude = 0) Parameters Type Name Description UnitDataSet processDataSet System.Double noiseAmplitude optionally adds noise to the \"measured\" y (for testing purposes) Returns Type Description System.Boolean"
  },
  "api/TimeSeriesAnalysis.Dynamic.UnitWarnings.html": {
    "href": "api/TimeSeriesAnalysis.Dynamic.UnitWarnings.html",
    "title": "Enum UnitWarnings | TimeSeriesAnalysis reference documentation",
    "keywords": "Enum UnitWarnings Enum of recognized warning or error states during identification of process model Namespace : TimeSeriesAnalysis.Dynamic Assembly : TimeSeriesAnalysis.dll Syntax public enum UnitWarnings Fields Name Description FailedToInitializePIDcontroller Failed to initalize the PID-controller Nothing No errors or warnings"
  },
  "api/TimeSeriesAnalysis.FitScore.html": {
    "href": "api/TimeSeriesAnalysis.FitScore.html",
    "title": "Class FitScore | TimeSeriesAnalysis reference documentation",
    "keywords": "Class FitScore Inheritance System.Object FitScore Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : TimeSeriesAnalysis Assembly : TimeSeriesAnalysis.dll Syntax public class FitScore Methods Calc(Double[], Double[]) Calculate a \"fit score\" between two signals. Declaration public static double Calc(double[] meas, double[] sim) Parameters Type Name Description System.Double [] meas System.Double [] sim Returns Type Description System.Double a fit score that is maximum 100 percent, but can also go negative if fit is poor GetPlantWideSimulated(PlantSimulator, TimeSeriesDataSet, TimeSeriesDataSet) Determines a score for how well a simulation fits with inputData. This can be compared over time to see any signs of degredation of the plant over time Declaration public static double GetPlantWideSimulated(PlantSimulator plantSimObj, TimeSeriesDataSet inputData, TimeSeriesDataSet simData) Parameters Type Name Description PlantSimulator plantSimObj TimeSeriesDataSet inputData TimeSeriesDataSet simData Returns Type Description System.Double GetPlantWideStored(PlantSimulator) Get the average stored fit-scores in the \"paramters.Fitting\" object, indicating how well the plant on average described/aligned with the dataset when it was fitted. Declaration public static double GetPlantWideStored(PlantSimulator plantSimObj) Parameters Type Name Description PlantSimulator plantSimObj Returns Type Description System.Double"
  },
  "api/TimeSeriesAnalysis.HighPass.html": {
    "href": "api/TimeSeriesAnalysis.HighPass.html",
    "title": "Class HighPass | TimeSeriesAnalysis reference documentation",
    "keywords": "Class HighPass A high-pass recursive time-series filter based on LowPass . This filter is in a recursive(feedback) IIR form that is simple to implement, has few coefficients, requires litte memory and computation. This filter is causal, meaning that for calculating the filtered value at time k it does not use future values such as k+1 , but this is at the expense of introducing a time-shift/phase-shift. LowPass BandPass MovingAvg Inheritance System.Object HighPass Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : TimeSeriesAnalysis Assembly : TimeSeriesAnalysis.dll Syntax public class HighPass Constructors HighPass(Double, Double) Constructor Declaration public HighPass(double TimeBase_s, double nanValue = -9999) Parameters Type Name Description System.Double TimeBase_s time base/sampling time in seconds of data to be fed filter System.Double nanValue value of input signal to be ignored/treated as NaN Methods Filter(Double, Double, Int32, Boolean) Adds a single data point to the filter Declaration public double Filter(double signal, double FilterTc_s, int order = 1, bool doReset = false) Parameters Type Name Description System.Double signal data point System.Double FilterTc_s filter time constant in seconds System.Int32 order filter order, eitehr 1 or 2 is supported System.Boolean doReset usually false, setting to true causes filter to reset to the value of signal Returns Type Description System.Double Filter(Double[], Double, Int32) Filter an entire time-series in one command Declaration public double[] Filter(double[] signal, double FilterTc_s, int order = 1) Parameters Type Name Description System.Double [] signal the vector of the entire time-series to be filtered System.Double FilterTc_s filter time constant System.Int32 order filter order, either 1 or 2 Returns Type Description System.Double [] a vector of the filtered time-series"
  },
  "api/TimeSeriesAnalysis.html": {
    "href": "api/TimeSeriesAnalysis.html",
    "title": "Namespace TimeSeriesAnalysis | TimeSeriesAnalysis reference documentation",
    "keywords": "Namespace TimeSeriesAnalysis Classes Array2D Non-generic 2D-array methods Array2D<T> Generic array operations that can be done on arrays of any type, for operators specific to numerical arrays(matrices) see Matrix.cs Array2DExtensionMethods Extension methods based on Array2D BandPass Numerical band-pass filter based on LowPass This filter is in a recursive(feedback) IIR form that is simple to implement, has few coefficients, requires litte memory and computation. This filter is causal, meaning that for calculating the filtered value at time k it does not use future values such as k+1 , but this is at the expense of introducing a time-shift/phase-shift. LowPass HighPass MovingAvg CorrelationCalculator CorrelationObject FitScore HighPass A high-pass recursive time-series filter based on LowPass . This filter is in a recursive(feedback) IIR form that is simple to implement, has few coefficients, requires litte memory and computation. This filter is causal, meaning that for calculating the filtered value at time k it does not use future values such as k+1 , but this is at the expense of introducing a time-shift/phase-shift. LowPass BandPass MovingAvg Index Class with utility-methods forr working with indices (vectors of integers) There are some special features of indices: they should never be negative, and indice vectors are often monotonically increasing. LowPass Low-pass filtering of time-series. This filter is in a recursive(feedback) IIR form that is simple to implement, has few coefficients, requires litte memory and computation. This filter is causal, meaning that for calcuating the filtered value at time k it does not use future values such as k+1 , but this is at the expense of introducing a time-shift/phase-shift. HighPass BandPass MovingAvg Matrix Operations for treating 2D-arrays as mathetmatical matrices MovingAvg Moving-average low-pass filter This filter is causal, meaning that for calculating the filtered value at time k it does not use future values such as k+1 , this is at the expense of introducing a time-shift/phase-shift. This is a finite-impulse-response type filter. An alterntive to this filter is LowPass , which is infinite-impulse-repsonse, and also requires less working memory(this filter needs to hold a buffer equal to bufferSize , but LowPass only needs to keep its last value in memory). LowPass will have less phase-shift/time-shift, because it places most weight on the last datapoint, whereas this filter will weight all data points in its buffer equally and thus responds sluggish. The advantage of this filter is that it allows you to control precisely how many past values are weighted. LowPass HighPass BandPass RegressionResults Class that holds the results of a run of Vec.Regress . Shared Globals Should only be used for logging, setting/getting configurations. TimeSeries Treating time series as tuples of corrsponding dates/values TimeSeriesDataSet A class that holds time-series data for any number of tags Time is either treated by giving a timeBase in seconds and a starting time, or by specifying a vector of timestamps. Vec Utility functions and operations for treating arrays as mathetmatical vectors. This class considers doubles, methods that require comparisons cannot be easily ported to generic \"Vec\"/> Vec<T> Class for generic methods on any type T that treat arrays as vectors (sorting,slicing,concatenating). For mathematical methods on vectors of doubles and integers, look into non-generic sister class \"Vec\". VecExtensionMethods Utility functions and operations for treating arrays as mathetmatical vectors Enums RegressionWarnings VectorFindValueType Input to Vec.FindValues which specifies the criteria of the search VectorSortType Input to Vec.Sort that specifies how values are to be sorted"
  },
  "api/TimeSeriesAnalysis.Index.html": {
    "href": "api/TimeSeriesAnalysis.Index.html",
    "title": "Class Index | TimeSeriesAnalysis reference documentation",
    "keywords": "Class Index Class with utility-methods forr working with indices (vectors of integers) There are some special features of indices: they should never be negative, and indice vectors are often monotonically increasing. Inheritance System.Object Index Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : TimeSeriesAnalysis Assembly : TimeSeriesAnalysis.dll Syntax public class Index Methods Add(Int32[], Int32) elementwise addition of val2 to array1 Declaration public static int[] Add(int[] array1, int val2) Parameters Type Name Description System.Int32 [] array1 System.Int32 val2 Returns Type Description System.Int32 [] AppendTrailingIndices(List<Int32>) When filtering out bad data before identification of difference equations that depend both y[k] and y[k-1] it will some times be neccessary, to append the trailing indices Declaration public static List<int> AppendTrailingIndices(List<int> indiceArray) Parameters Type Name Description System.Collections.Generic.List < System.Int32 > indiceArray Returns Type Description System.Collections.Generic.List < System.Int32 > InverseIndices(Int32, List<Int32>) given a list of sorted indeces and a desired vector size N, returns the indices that are not in \"sortedIndices\" i.e. of the \"other vectors Declaration public static List<int> InverseIndices(int N, List<int> sortedIndices) Parameters Type Name Description System.Int32 N System.Collections.Generic.List < System.Int32 > sortedIndices Returns Type Description System.Collections.Generic.List < System.Int32 > MakeIndexArray(Int32, Int32) creates a monotonically increasing integer (11.12.13...) array starting at startValue and ending at endValue Declaration public static int[] MakeIndexArray(int startValue, int endValue) Parameters Type Name Description System.Int32 startValue System.Int32 endValue Returns Type Description System.Int32 [] Max(Int32[], Int32) Returns element-wise maximum of array element and value Declaration public static int[] Max(int[] array, int value) Parameters Type Name Description System.Int32 [] array System.Int32 value Returns Type Description System.Int32 [] Remove(Int32[], List<Int32>) Removes ceratin indices from the array Declaration public static int[] Remove(int[] array, List<int> indicesToRemove) Parameters Type Name Description System.Int32 [] array System.Collections.Generic.List < System.Int32 > indicesToRemove Returns Type Description System.Int32 [] Subtract(Int32[], Int32) subtracts val2 from array2 elements Declaration public static int[] Subtract(int[] array1, int val2) Parameters Type Name Description System.Int32 [] array1 System.Int32 val2 Returns Type Description System.Int32 [] Union(List<Int32>, List<Int32>) returns the union of array1 and array2, a list of elements that are in either vector Declaration public static List<int> Union(List<int> vec1, List<int> vec2) Parameters Type Name Description System.Collections.Generic.List < System.Int32 > vec1 System.Collections.Generic.List < System.Int32 > vec2 Returns Type Description System.Collections.Generic.List < System.Int32 >"
  },
  "api/TimeSeriesAnalysis.LowPass.html": {
    "href": "api/TimeSeriesAnalysis.LowPass.html",
    "title": "Class LowPass | TimeSeriesAnalysis reference documentation",
    "keywords": "Class LowPass Low-pass filtering of time-series. This filter is in a recursive(feedback) IIR form that is simple to implement, has few coefficients, requires litte memory and computation. This filter is causal, meaning that for calcuating the filtered value at time k it does not use future values such as k+1 , but this is at the expense of introducing a time-shift/phase-shift. HighPass BandPass MovingAvg Inheritance System.Object LowPass Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : TimeSeriesAnalysis Assembly : TimeSeriesAnalysis.dll Syntax public class LowPass Constructors LowPass(Double, Double) Constructor Declaration public LowPass(double TimeBase_s, double nanValue = -9999) Parameters Type Name Description System.Double TimeBase_s The time base, the time interval between each time step of the dataset, in seconds System.Double nanValue value that is to be treated as NaN and ignored Methods Filter(Double, Double, Int32, Boolean) Adds a single data point to the filter Declaration public double Filter(double signal, double FilterTc_s, int order = 1, bool doReset = false) Parameters Type Name Description System.Double signal data point System.Double FilterTc_s filter time constant in seconds System.Int32 order filter order, either 1 or 2 is supported System.Boolean doReset usually false, setting to true causes filter to reset to the value of signal Returns Type Description System.Double Filter(Double[], Double, Int32, List<Int32>) Filter an entire time-series in one command Declaration public double[] Filter(double[] signal, double FilterTc_s, int order = 1, List<int> indicesToIgnore = null) Parameters Type Name Description System.Double [] signal the vector of the entire time-series to be filtered System.Double FilterTc_s filter time constant System.Int32 order filter order, either 1 or 2 System.Collections.Generic.List < System.Int32 > indicesToIgnore for these indices the of the signal, the filter should just \"freeze\" the value(can be null) Returns Type Description System.Double [] a vector of the filtered time-series"
  },
  "api/TimeSeriesAnalysis.Matrix.html": {
    "href": "api/TimeSeriesAnalysis.Matrix.html",
    "title": "Class Matrix | TimeSeriesAnalysis reference documentation",
    "keywords": "Class Matrix Operations for treating 2D-arrays as mathetmatical matrices Inheritance System.Object Matrix Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : TimeSeriesAnalysis Assembly : TimeSeriesAnalysis.dll Syntax public static class Matrix Methods AppendRow(Double[,], Double[]) Appends another row onto an existing matrix. Returns null if this was not possible(ie. dimnesions dont agree). Declaration public static double[, ] AppendRow(double[, ] matrix, double[] newRowVec) Parameters Type Name Description System.Double [,] matrix System.Double [] newRowVec Returns Type Description System.Double [,] ComponentMult(Double[,], Double[], Int32) Multipliy either entire matrix or single row(optional third input) by a vector (returns a matrix) Declaration public static double[, ] ComponentMult(double[, ] matrix, double[] vector, int singleMatrixRowToMult = -1) Parameters Type Name Description System.Double [,] matrix System.Double [] vector System.Int32 singleMatrixRowToMult Returns Type Description System.Double [,] Mult(Double[,], Double, Int32) Multipliy either entire matrix or single row(optional third input) by a scalar Declaration public static double[, ] Mult(double[, ] matrix, double scalar, int singleMatrixRowToMult = -1) Parameters Type Name Description System.Double [,] matrix System.Double scalar System.Int32 singleMatrixRowToMult Returns Type Description System.Double [,] Mult(Double[,], Double[]) Multipliy either entire matrix or single row(optional third input) by a vector (returns vector) Declaration public static double[] Mult(double[, ] matrix, double[] vector) Parameters Type Name Description System.Double [,] matrix System.Double [] vector Returns Type Description System.Double [] ReplaceColumn(Double[,], Int32, Double[]) Replace a single column of a matrix Declaration public static double[, ] ReplaceColumn(double[, ] matrix, int colIndex, double[] newColVec) Parameters Type Name Description System.Double [,] matrix System.Int32 colIndex System.Double [] newColVec Returns Type Description System.Double [,] ReplaceRow(Double[,], Int32, Double[]) Replace a single row of a matrix Declaration public static double[, ] ReplaceRow(double[, ] matrix, int rowIndex, double[] newRowVec) Parameters Type Name Description System.Double [,] matrix System.Int32 rowIndex System.Double [] newRowVec Returns Type Description System.Double [,]"
  },
  "api/TimeSeriesAnalysis.MovingAvg.html": {
    "href": "api/TimeSeriesAnalysis.MovingAvg.html",
    "title": "Class MovingAvg | TimeSeriesAnalysis reference documentation",
    "keywords": "Class MovingAvg Moving-average low-pass filter This filter is causal, meaning that for calculating the filtered value at time k it does not use future values such as k+1 , this is at the expense of introducing a time-shift/phase-shift. This is a finite-impulse-response type filter. An alterntive to this filter is LowPass , which is infinite-impulse-repsonse, and also requires less working memory(this filter needs to hold a buffer equal to bufferSize , but LowPass only needs to keep its last value in memory). LowPass will have less phase-shift/time-shift, because it places most weight on the last datapoint, whereas this filter will weight all data points in its buffer equally and thus responds sluggish. The advantage of this filter is that it allows you to control precisely how many past values are weighted. LowPass HighPass BandPass Inheritance System.Object MovingAvg Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : TimeSeriesAnalysis Assembly : TimeSeriesAnalysis.dll Syntax public class MovingAvg Constructors MovingAvg(Int32) Constructor Declaration public MovingAvg(int bufferSize) Parameters Type Name Description System.Int32 bufferSize the number of samples to average, which determines the size of the buffer to create Methods Filter(Double) Add value to the moving-average filter. Declaration public double Filter(double signal) Parameters Type Name Description System.Double signal the scalar value to be added Returns Type Description System.Double the output of the filter, given the new value Filter(Double[]) Run filter over a vector of values Declaration public double[] Filter(double[] signal) Parameters Type Name Description System.Double [] signal vector of values to be filtered Returns Type Description System.Double [] the moving-averge filtered version of values"
  },
  "api/TimeSeriesAnalysis.RegressionResults.html": {
    "href": "api/TimeSeriesAnalysis.RegressionResults.html",
    "title": "Class RegressionResults | TimeSeriesAnalysis reference documentation",
    "keywords": "Class RegressionResults Class that holds the results of a run of Vec.Regress . Inheritance System.Object RegressionResults Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : TimeSeriesAnalysis Assembly : TimeSeriesAnalysis.dll Syntax public class RegressionResults Constructors RegressionResults() Default constructor, sets all values to null or zero. Declaration public RegressionResults() Properties AbleToIdentify True if able to identify, otherwise false Declaration public bool AbleToIdentify { get; set; } Property Value Type Description System.Boolean Bias The bias term of the linear regression Declaration public double Bias { get; set; } Property Value Type Description System.Double Gains The gains of the linear regression Declaration public double[] Gains { get; set; } Property Value Type Description System.Double [] NfittingBadDataPoints Number of bad data point ignored in the fitting data set Declaration public int NfittingBadDataPoints { get; set; } Property Value Type Description System.Int32 NfittingTotalDataPoints Total number of data points in the fitting data set Declaration public int NfittingTotalDataPoints { get; set; } Property Value Type Description System.Int32 ObjectiveFunctionValue The value of the objective function after regression Declaration public double ObjectiveFunctionValue { get; set; } Property Value Type Description System.Double Param All regression parameters, first the gains, then the bias term. Declaration public double[] Param { get; set; } Property Value Type Description System.Double [] Param95prcConfidence The 95 percent confidence of parameters The confidence interval will be Param +/- Param95prcConfidence Declaration public double[] Param95prcConfidence { get; set; } Property Value Type Description System.Double [] RegressionWarnings Regression warnings Declaration public List<RegressionWarnings> RegressionWarnings { get; set; } Property Value Type Description System.Collections.Generic.List < RegressionWarnings > Rsq R2-root-means-squared between Y and Y_modelled for the tuning dataset(a value between 0 and 100, higher is better) Declaration public double Rsq { get; set; } Property Value Type Description System.Double VarCovarMatrix The variance/covariance matrix of the regression run Declaration public double[][] VarCovarMatrix { get; set; } Property Value Type Description System.Double [][] Y_modelled The modelled output Declaration public double[] Y_modelled { get; set; } Property Value Type Description System.Double []"
  },
  "api/TimeSeriesAnalysis.RegressionWarnings.html": {
    "href": "api/TimeSeriesAnalysis.RegressionWarnings.html",
    "title": "Enum RegressionWarnings | TimeSeriesAnalysis reference documentation",
    "keywords": "Enum RegressionWarnings Namespace : TimeSeriesAnalysis Assembly : TimeSeriesAnalysis.dll Syntax public enum RegressionWarnings Fields Name Description InputMatrixHasConstantInput InputMatrixIsRankDeficient NONE"
  },
  "api/TimeSeriesAnalysis.Shared.html": {
    "href": "api/TimeSeriesAnalysis.Shared.html",
    "title": "Class Shared | TimeSeriesAnalysis reference documentation",
    "keywords": "Class Shared Globals Should only be used for logging, setting/getting configurations. Inheritance System.Object Shared Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : TimeSeriesAnalysis Assembly : TimeSeriesAnalysis.dll Syntax public class Shared Methods DisablePlots() Disables all plotting Declaration public static void DisablePlots() EnablePlots() Enables all plotting Declaration public static void EnablePlots() GetParserObj() Returns the ParserFeedback object, which can be used to add loglines for info,warnings or errors Declaration public static ParserFeedback GetParserObj() Returns Type Description ParserFeedback the Parserfeedback object Examples Example usage: Shared.GetParserObj().AddWarning(\"This is a warning that can be shown on the console, written to file, or both\"); IsPlottingEnabled() Queries if plotting is enabled or not Declaration public static bool IsPlottingEnabled() Returns Type Description System.Boolean"
  },
  "api/TimeSeriesAnalysis.Test.SysID.GainSchedIdentifyTests.html": {
    "href": "api/TimeSeriesAnalysis.Test.SysID.GainSchedIdentifyTests.html",
    "title": "Class GainSchedIdentifyTests | TimeSeriesAnalysis reference documentation",
    "keywords": "Class GainSchedIdentifyTests Inheritance System.Object GainSchedIdentifyTests Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : TimeSeriesAnalysis.Test.SysID Assembly : TimeSeriesAnalysis.Tests.dll Syntax [TestFixture] public class GainSchedIdentifyTests Methods GainAndThreshold_GainsNotLargerThanTheBiggestPossibleGain() Declaration [TestCase(new object[]{})] public void GainAndThreshold_GainsNotLargerThanTheBiggestPossibleGain() GainAndThreshold_LinearGainThresholdAtReasonablePlace(Int32, Double) Declaration [TestCase(7, 4)] public void GainAndThreshold_LinearGainThresholdAtReasonablePlace(int ver, double gain_sched_threshold) Parameters Type Name Description System.Int32 ver System.Double gain_sched_threshold GainAndThreshold_ThresholdsWithinUminAndUmax(Int32, Double) Declaration [TestCase(1, 1.5)] public void GainAndThreshold_ThresholdsWithinUminAndUmax(int ver, double gain_sched_threshold) Parameters Type Name Description System.Int32 ver System.Double gain_sched_threshold GainAndThreshold_TwoGains_TimeConstantsAndThresholdFoundOk(Double, Double) Declaration [TestCase(3, 10)] public void GainAndThreshold_TwoGains_TimeConstantsAndThresholdFoundOk(double TimeConstant1_s, double TimeConstant2_s) Parameters Type Name Description System.Double TimeConstant1_s System.Double TimeConstant2_s GainEstOnly_CorrectGainsReturned(Int32, Int32) Declaration [TestCase(1, 0, Description = \"Two steps for every threshold(five thresholds)\")] [TestCase(2, 0, Description = \"Two steps for every threshold(five thresholds), ref model is constant gain\")] [TestCase(12, 1, Description = \"One steps between every threshold(ten thresholds, harder), ref model is constant gain\")] public void GainEstOnly_CorrectGainsReturned(int ver, int expectedNumWarnings) Parameters Type Name Description System.Int32 ver System.Int32 expectedNumWarnings"
  },
  "api/TimeSeriesAnalysis.Test.SysID.html": {
    "href": "api/TimeSeriesAnalysis.Test.SysID.html",
    "title": "Namespace TimeSeriesAnalysis.Test.SysID | TimeSeriesAnalysis reference documentation",
    "keywords": "Namespace TimeSeriesAnalysis.Test.SysID Classes GainSchedIdentifyTests"
  },
  "api/TimeSeriesAnalysis.TimeSeries.html": {
    "href": "api/TimeSeriesAnalysis.TimeSeries.html",
    "title": "Class TimeSeries | TimeSeriesAnalysis reference documentation",
    "keywords": "Class TimeSeries Treating time series as tuples of corrsponding dates/values Inheritance System.Object TimeSeries Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : TimeSeriesAnalysis Assembly : TimeSeriesAnalysis.dll Syntax public class TimeSeries Methods Concat((Double[], DateTime[]), (Double[], DateTime[])) Creates a new timeseries that is var1 and var2 concatenated together Declaration public static (double[], DateTime[]) Concat((double[], DateTime[]) var1, (double[], DateTime[]) var2) Parameters Type Name Description System.ValueTuple < System.Double [], System.DateTime []> var1 System.ValueTuple < System.Double [], System.DateTime []> var2 Returns Type Description System.ValueTuple < System.Double [], System.DateTime []> GetClosestIndexToDate((Double[], DateTime[]), DateTime) Gt the index of the time-series that is closest to a given date Declaration public static int GetClosestIndexToDate((double[], DateTime[]) input, DateTime date) Parameters Type Name Description System.ValueTuple < System.Double [], System.DateTime []> input time-series tuple System.DateTime date the Returns Type Description System.Int32 GetGradient((Double[], DateTime[]), Int32, Int32[]) Get the gradient of a time-series Declaration public static RegressionResults GetGradient((double[], DateTime[]) valueDateTuple, int sampleTime_sec = 1, int[] indicesToIgnore = null) Parameters Type Name Description System.ValueTuple < System.Double [], System.DateTime []> valueDateTuple a value/datetime array tuple System.Int32 sampleTime_sec sample time in which to present the result System.Int32 [] indicesToIgnore indices to ignore Returns Type Description RegressionResults The gradient is the gain of the returned object GetSubsetOfDays((Double[], DateTime[]), Int32, Int32) Clip out a subset of the given time-series with a given number of days. By default it gives the last N days, but optionally Declaration public static (double[], DateTime[]) GetSubsetOfDays((double[], DateTime[]) input, int nSpanDays, int nDaysBack = 0) Parameters Type Name Description System.ValueTuple < System.Double [], System.DateTime []> input the original time-series to be clipped System.Int32 nSpanDays the desired length of the returend dataset System.Int32 nDaysBack the number of days to push the end of the returned dataset back(default is zero, in which case method gets last nSpanDays) Returns Type Description System.ValueTuple < System.Double [], System.DateTime []> Reverse((Double[], DateTime[])) Reverses the order of the time-series Declaration public static (double[], DateTime[]) Reverse((double[], DateTime[]) input) Parameters Type Name Description System.ValueTuple < System.Double [], System.DateTime []> input Returns Type Description System.ValueTuple < System.Double [], System.DateTime []> SubSet((Double[], DateTime[]), DateTime) Get a subset starting at a specific date Declaration public static (double[], DateTime[]) SubSet((double[], DateTime[]) input, DateTime startDate) Parameters Type Name Description System.ValueTuple < System.Double [], System.DateTime []> input System.DateTime startDate Returns Type Description System.ValueTuple < System.Double [], System.DateTime []> SubSet((Double[], DateTime[]), Int32, Int32) Get a subset of a given value/datetime tuple, given start and end indices Declaration public static (double[], DateTime[]) SubSet((double[], DateTime[]) input, int startInd, int endInd) Parameters Type Name Description System.ValueTuple < System.Double [], System.DateTime []> input System.Int32 startInd System.Int32 endInd Returns Type Description System.ValueTuple < System.Double [], System.DateTime []>"
  },
  "api/TimeSeriesAnalysis.TimeSeriesDataSet.html": {
    "href": "api/TimeSeriesAnalysis.TimeSeriesDataSet.html",
    "title": "Class TimeSeriesDataSet | TimeSeriesAnalysis reference documentation",
    "keywords": "Class TimeSeriesDataSet A class that holds time-series data for any number of tags Time is either treated by giving a timeBase in seconds and a starting time, or by specifying a vector of timestamps. Inheritance System.Object TimeSeriesDataSet Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : TimeSeriesAnalysis Assembly : TimeSeriesAnalysis.dll Syntax public class TimeSeriesDataSet Constructors TimeSeriesDataSet() Declaration [JsonConstructor] public TimeSeriesDataSet() TimeSeriesDataSet(TimeSeriesDataSet) Constructor Declaration public TimeSeriesDataSet(TimeSeriesDataSet inputDataSet) Parameters Type Name Description TimeSeriesDataSet inputDataSet Methods Add(String, Double[]) Add an entire time-series to the dataset Declaration public bool Add(string signalName, double[] values) Parameters Type Name Description System.String signalName System.Double [] values Returns Type Description System.Boolean AddConstant(String, Double) Add a constant value to the time-series to the dataset Declaration public bool AddConstant(string signalName, double value) Parameters Type Name Description System.String signalName System.Double value Returns Type Description System.Boolean AddDataPoint(String, Int32, Double) Add a single data point Declaration public bool AddDataPoint(string signalID, int idx, double value) Parameters Type Name Description System.String signalID System.Int32 idx System.Double value Returns Type Description System.Boolean returns false if signal does not already exist or if index is beyond dataset size AddNoiseToSignal(String, Double, Nullable<Int32>) Adds noise to a given signal in the datset. (This is mainly intended for testing identification algorithms against simulated data.) Declaration public bool AddNoiseToSignal(string signalName, double noiseAmplitude, int? seed = null) Parameters Type Name Description System.String signalName System.Double noiseAmplitude System.Nullable < System.Int32 > seed Returns Type Description System.Boolean AddSet(TimeSeriesDataSet) Adds all signals in a given set to this set Declaration public bool AddSet(TimeSeriesDataSet inputDataSet) Parameters Type Name Description TimeSeriesDataSet inputDataSet Returns Type Description System.Boolean Combine(TimeSeriesDataSet) Combine this data set with the inputDataset into a new set Declaration public TimeSeriesDataSet Combine(TimeSeriesDataSet inputDataSet) Parameters Type Name Description TimeSeriesDataSet inputDataSet Returns Type Description TimeSeriesDataSet the newly created dataset ContainsSignal(String) Determine if a specific signal is in the dataset Declaration public bool ContainsSignal(string signalID) Parameters Type Name Description System.String signalID Returns Type Description System.Boolean CreateDownsampledCopy(Int32) Returns a copy of the dataset that is downsampled by the given factor Declaration public TimeSeriesDataSet CreateDownsampledCopy(int downsampleFactor) Parameters Type Name Description System.Int32 downsampleFactor value greater than 1 indicating that every nth value of the orignal data will be transferred Returns Type Description TimeSeriesDataSet CreateTimestamps(Double, Nullable<DateTime>) Creates internal timestamps from a given start time and timebase, must be called after filling the values Declaration public void CreateTimestamps(double timeBase_s, DateTime? t0 = null) Parameters Type Name Description System.Double timeBase_s the time between samples in the dataset, in total seconds System.Nullable < System.DateTime > t0 start time, can be null, which can be usedful for testing GetAsMatrix(List<Int32>) Get all signals in the dataset as a matrix Declaration public (double[, ], string[]) GetAsMatrix(List<int> indicesToIgnore = null) Parameters Type Name Description System.Collections.Generic.List < System.Int32 > indicesToIgnore Returns Type Description System.ValueTuple < System.Double [,], System.String []> the signals as a 2d-matrix, and the an array of strings with corresponding signal names GetData(String[], Int32) Get Data for multiple signals at a specific time index Declaration public double[] GetData(string[] signalNames, int timeIdx) Parameters Type Name Description System.String [] signalNames System.Int32 timeIdx Returns Type Description System.Double [] May return null if an error occured GetIndicesToIgnore() Get a list of the indices in the dataset that are flagged to be ignored in identification Declaration public List<int> GetIndicesToIgnore() Returns Type Description System.Collections.Generic.List < System.Int32 > GetLength() Get the length in samples of the data set Declaration public int? GetLength() Returns Type Description System.Nullable < System.Int32 > GetSignalNames() Get the names of all the singals, wheter constant or varying Declaration public string[] GetSignalNames() Returns Type Description System.String [] GetTimeBase() Get the timebase, the time between two samples in the dataset Declaration public double GetTimeBase() Returns Type Description System.Double The timebase in seconds GetTimeStamps() Get a vector of the timestamps of the data-set Declaration public DateTime[] GetTimeStamps() Returns Type Description System.DateTime [] GetValue(String, Int32) Get Data for multiple signals at a specific time index Declaration public double? GetValue(string signalName, int timeIdx) Parameters Type Name Description System.String signalName System.Int32 timeIdx Returns Type Description System.Nullable < System.Double > May return null if an error occured GetValues(String) Get the values of a specific signal Declaration public double[] GetValues(string signalName) Parameters Type Name Description System.String signalName Returns Type Description System.Double [] null if signal not found GetValues(String, SignalType, Int32) Get the values of a specific signal Declaration public double[] GetValues(string processID, SignalType signalType, int index = 0) Parameters Type Name Description System.String processID SignalType signalType System.Int32 index Returns Type Description System.Double [] GetValuesAtTime(String[], Int32) Get one or more signals from the dataset at a given time Declaration public double[] GetValuesAtTime(string[] signalIds, int timeIndex) Parameters Type Name Description System.String [] signalIds System.Int32 timeIndex Returns Type Description System.Double [] InitNewSignal(String, Double, Int32, Double) Define a new signal, specifying only its inital value Declaration public void InitNewSignal(string signalName, double initalValue, int N, double nonYetSimulatedValue = NaN) Parameters Type Name Description System.String signalName System.Double initalValue the value of time zero System.Int32 N number of time stamps System.Double nonYetSimulatedValue what value to fill in for future undefined times, default:nan LoadFromCsv(String, Char, String) Reads data form a csv-file (such as that created by ToCSV()) Declaration public bool LoadFromCsv(string csvFileName, char separator = ';', string dateTimeFormat = \"yyyy-MM-dd HH:mm:ss\") Parameters Type Name Description System.String csvFileName csv file name System.Char separator default separator System.String dateTimeFormat format string of the time-series vector to be read Returns Type Description System.Boolean LoadFromCsv(CsvContent, Char, String) Loads the CsvContent(which can be read from a file) into a TimeSeriesDataSet object Declaration public bool LoadFromCsv(CsvContent csvContent, char separator = ';', string dateTimeFormat = \"yyyy-MM-dd HH:mm:ss\") Parameters Type Name Description CsvContent csvContent System.Char separator System.String dateTimeFormat Returns Type Description System.Boolean Remove(String) Removes a signal from the dataset Declaration public bool Remove(string signalName) Parameters Type Name Description System.String signalName Returns Type Description System.Boolean SetIndicesToIgnore(List<Int32>) The given indices will be skipped in any subsequent simulation of the dataset Declaration public void SetIndicesToIgnore(List<int> indicesToIgnore) Parameters Type Name Description System.Collections.Generic.List < System.Int32 > indicesToIgnore SetTimeStamps(List<DateTime>) Explicitly sets the timestamps of the time-series (possibly overriding any timeBase_s that was given during init) If times is null, then the method creates timestamps based on timeBase_s and t0. Declaration public void SetTimeStamps(List<DateTime> times) Parameters Type Name Description System.Collections.Generic.List < System.DateTime > times ToCsv(String, String, Int32) Exports the time-series data set to a csv-file Times are encoded as \"yyyy-MM-dd HH:mm:ss\" and be loaded with CSV.LoadFromFile() afterwards Declaration public bool ToCsv(string fileName, string csvSeparator = \";\", int nSignificantDigits = 5) Parameters Type Name Description System.String fileName The CSV-file name System.String csvSeparator the separator to use in the csv-file(despite the name, the most common is perhaps \";\" which Excel will recognize automatically) System.Int32 nSignificantDigits the number of singificant digits to include for each variable Returns Type Description System.Boolean ToCsvText(String, Int32) Create a comma-separated-variable(CSV) string of the dataset Declaration public string ToCsvText(string csvSeparator = \";\", int nSignificantDigits = 5) Parameters Type Name Description System.String csvSeparator symbol used to separate columns in the string System.Int32 nSignificantDigits number of significant digits per value Returns Type Description System.String The CSV-string ToDict() Create a dictionary of all dataset values. Constants are padded out to be of N length. Declaration public Dictionary<string, double[]> ToDict() Returns Type Description System.Collections.Generic.Dictionary < System.String , System.Double []> Returns the dataset as a dictionary"
  },
  "api/TimeSeriesAnalysis.Utility.CSV.html": {
    "href": "api/TimeSeriesAnalysis.Utility.CSV.html",
    "title": "Class CSV | TimeSeriesAnalysis reference documentation",
    "keywords": "Class CSV IO Utility class for loading time-series data from a plain text comma-separated variable(CSV) file Inheritance System.Object CSV Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : TimeSeriesAnalysis.Utility Assembly : TimeSeriesAnalysis.dll Syntax public class CSV Methods LoadDataFromCSV(String, Char, out Double[,], out String[], out String[,]) Load time-series data from a CSV-file, low-level version for further processing Declaration public static bool LoadDataFromCSV(string filename, char separator, out double[, ] doubleData, out string[] variableNames, out string[, ] stringData) Parameters Type Name Description System.String filename path of file to be loaded System.Char separator separator character used to separate data in file System.Double [,] doubleData (output) the returned 2D array where each column is the data for one variable(NaNs if not able to parse as number) System.String [] variableNames (output) an array of the variable names in doubleData System.String [,] stringData (output)the raw data of the entire csv-file in a 2D array, only needed if parsing of other two variables has failed, and useful for retireving timestamps Returns Type Description System.Boolean LoadDataFromCSV(String, out Double[,], out String[], out String[,]) Load time-series data from a CSV-file into variables for further processing (using the default \";\" separator) Declaration public static bool LoadDataFromCSV(string filename, out double[, ] doubleData, out string[] variableNames, out string[, ] stringData) Parameters Type Name Description System.String filename path of file to be loaded System.Double [,] doubleData (output) the returned 2D array where each column is the data for one variable System.String [] variableNames (output) an array of the variable names in doubleData System.String [,] stringData (output)the raw data of the entire csv-file in a 2D array, only needed if parsing of other two variables has failed, and useful for retireving timestamps Returns Type Description System.Boolean LoadDataFromCsvAsTimeSeries(String, Char, out DateTime[], out Dictionary<String, Double[]>, String) Loads data from a CSV-file, including parsing the times(first column) Declaration public static bool LoadDataFromCsvAsTimeSeries(string filename, char separator, out DateTime[] dateTimes, out Dictionary<string, double[]> variables, string dateTimeFormat = \"yyyy-MM-dd HH:mm:ss\") Parameters Type Name Description System.String filename System.Char separator System.DateTime [] dateTimes System.Collections.Generic.Dictionary < System.String , System.Double []> variables System.String dateTimeFormat Returns Type Description System.Boolean LoadDataFromCsvContentAsTimeSeries(CsvContent, Char, out DateTime[], out Dictionary<String, Double[]>, String) Version of LoadDataFromCSV that accepts a CSVcontent containting the contents of a CSV-file as input Declaration public static bool LoadDataFromCsvContentAsTimeSeries(CsvContent csvString, char separator, out DateTime[] dateTimes, out Dictionary<string, double[]> variables, string dateTimeFormat = \"yyyy-MM-dd HH:mm:ss\") Parameters Type Name Description CsvContent csvString System.Char separator System.DateTime [] dateTimes System.Collections.Generic.Dictionary < System.String , System.Double []> variables System.String dateTimeFormat Returns Type Description System.Boolean LoadStringsFromCSV(String, out String[,]) Return just string data from a CSV(useful if data contains no numerical data) Declaration public static bool LoadStringsFromCSV(string filename, out string[, ] stringData) Parameters Type Name Description System.String filename System.String [,] stringData Returns Type Description System.Boolean RobustParseDouble(String, out Double) Loading string data into a double value. Declaration public static bool RobustParseDouble(string str, out double value) Parameters Type Name Description System.String str the string to be parsed System.Double value (output) is the value of the parsed double(if successfully parsed) Returns Type Description System.Boolean The method returns true if succesful, otherwise it returns false."
  },
  "api/TimeSeriesAnalysis.Utility.CsvContent.html": {
    "href": "api/TimeSeriesAnalysis.Utility.CsvContent.html",
    "title": "Class CsvContent | TimeSeriesAnalysis reference documentation",
    "keywords": "Class CsvContent A class that contains the text content of a csv-file. This class is introduced as a convenience to avoid confusing filenames and csv-content string in overloaded methods. Inheritance System.Object CsvContent Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : TimeSeriesAnalysis.Utility Assembly : TimeSeriesAnalysis.dll Syntax public class CsvContent Constructors CsvContent(String) Declaration public CsvContent(string csvTxt) Parameters Type Name Description System.String csvTxt Properties CsvTxt Declaration public string CsvTxt { get; } Property Value Type Description System.String"
  },
  "api/TimeSeriesAnalysis.Utility.html": {
    "href": "api/TimeSeriesAnalysis.Utility.html",
    "title": "Namespace TimeSeriesAnalysis.Utility | TimeSeriesAnalysis reference documentation",
    "keywords": "Namespace TimeSeriesAnalysis.Utility Classes CSV IO Utility class for loading time-series data from a plain text comma-separated variable(CSV) file CsvContent A class that contains the text content of a csv-file. This class is introduced as a convenience to avoid confusing filenames and csv-content string in overloaded methods. ParserFeedback Utility class is responsible for collecting feedback lines, such as warnings,error or info text to either the console window, visual-studio output/debug window, to a file structure or all. The class makes it easy to switch between displaying output to a console while debugging while to outputting to file when code moves to a server. Suitable for collecting debugging info from services that run many cases repeatedly. log levels: INFO,WARN,ERROR,FATAL (no debug messages here) Plot Static methods for plotting one or more time-series across one or more y-axes and one or more subplots by opening up Chrome calling a set of JavaScript plotting methods based on plotly.js Time-series are written as CSV-files to a specific folder on disk plotDataPath , before starting a chrome-window that loads a specific \"localhost\" plotlyURL that reads said CSV-files and initates an in-browser plot using plotly.js. For this method to work you need to be running a web server such as IIS that serves up a \"localhost\" plotlyURL as described in the documentation. If you sometimes need to disable plots (for instance if plotting code is included in unit tests) see Plot4Test Plot4Test Version of Plot class where plots code can be Enabled()/Disabled() programatically. This allows you to keep all your \"Plot\" calls in your unit tests and turn them on as needed to debug a single test, while avoid being overwhelmed with plots if for instance re-running all unit tests. PlotXY SigmaXml SignificantDigits Utility class to round double variables to a given nubmer of signficant digits. StringToFileWriter IO Utility class to write to file that implements IDisposable interface. Suggest to use this objects of this class within the using keyword so that file-resources are automatically freed in case your code is terminated before it has completed. TimeSeriesCreator Class for static methods create different types of time-series for testing. UnixTime Utility class to work with unix time stamps XYTable Structs ParserFeedbackLogLine Struct for each log message of ParserFeedback Enums ParserfeedbackMessageLevel Enum to set the log level of ParserFeedback XYlineType"
  },
  "api/TimeSeriesAnalysis.Utility.ParserFeedback.html": {
    "href": "api/TimeSeriesAnalysis.Utility.ParserFeedback.html",
    "title": "Class ParserFeedback | TimeSeriesAnalysis reference documentation",
    "keywords": "Class ParserFeedback Utility class is responsible for collecting feedback lines, such as warnings,error or info text to either the console window, visual-studio output/debug window, to a file structure or all. The class makes it easy to switch between displaying output to a console while debugging while to outputting to file when code moves to a server. Suitable for collecting debugging info from services that run many cases repeatedly. log levels: INFO,WARN,ERROR,FATAL (no debug messages here) Inheritance System.Object ParserFeedback Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : TimeSeriesAnalysis.Utility Assembly : TimeSeriesAnalysis.dll Syntax public class ParserFeedback Constructors ParserFeedback(Boolean) Constructor Declaration public ParserFeedback(bool doOutputAlsoToConsole = false) Parameters Type Name Description System.Boolean doOutputAlsoToConsole Methods AddError(String) Add an error message Declaration public void AddError(string message) Parameters Type Name Description System.String message AddFatalError(String) Adds a fatal error Declaration public void AddFatalError(string message) Parameters Type Name Description System.String message AddInfo(String) Adds an info message Declaration public void AddInfo(string message) Parameters Type Name Description System.String message AddWarning(String) Adds a warning Declaration public void AddWarning(string message) Parameters Type Name Description System.String message Close() Flushes all messages to file and closes file handlers. Declaration public void Close() CloseCaseLogFile() Close a log file belong to a perticular case Declaration public void CloseCaseLogFile() CreateCaseLogFile(String, Int32) Creates a new empty log file for a specific case name. Calling this function before StoreMessage will cause all messages to be copied to it. Declaration public void CreateCaseLogFile(string caseName, int caseNum) Parameters Type Name Description System.String caseName System.Int32 caseNum CreateCommonHTMLfile() Creates a html file, where is \"case\" is presented in an iframe- useful for quickly viewing many cases Needs SetCaseArray to be called first Declaration public void CreateCommonHTMLfile() CreateCommonLogFile(String) Creates a new empty log file and, resets counters etc. This is a \"common\" file if no cases are specificed Declaration public void CreateCommonLogFile(string loggDir) Parameters Type Name Description System.String loggDir EnableConsoleOutput(Boolean) Enable (or disable) console output - i.e. writing messages directly to screen (useful for debugging, but leave off if running on a server) Declaration public void EnableConsoleOutput(bool doEnable = true) Parameters Type Name Description System.Boolean doEnable EnableDebugOutput(Boolean) Enables or disables the output to Visual Studio debug window and to console out Declaration public void EnableDebugOutput(bool doEnable = true) Parameters Type Name Description System.Boolean doEnable GetFirstErrorOrWarning() Intended for unit tests, get the first error or warning message Declaration public string GetFirstErrorOrWarning() Returns Type Description System.String GetListOfAllLogLinesAtOrAboveLevel(ParserfeedbackMessageLevel) Returns all log lines at or above a specified level Declaration public List<string> GetListOfAllLogLinesAtOrAboveLevel(ParserfeedbackMessageLevel desiredLevel = ParserfeedbackMessageLevel.warn) Parameters Type Name Description ParserfeedbackMessageLevel desiredLevel Returns Type Description System.Collections.Generic.List < System.String > GetListOfAllLogLinesAtOrBelowLevel(ParserfeedbackMessageLevel) Returns all log lines at or belowe a specified level Declaration public List<string> GetListOfAllLogLinesAtOrBelowLevel(ParserfeedbackMessageLevel desiredLevel = ParserfeedbackMessageLevel.warn) Parameters Type Name Description ParserfeedbackMessageLevel desiredLevel Returns Type Description System.Collections.Generic.List < System.String > GetListOfAllLogLinesOfLevel(ParserfeedbackMessageLevel) Returns all log lines of a specified level Declaration public List<string> GetListOfAllLogLinesOfLevel(ParserfeedbackMessageLevel desiredLevel) Parameters Type Name Description ParserfeedbackMessageLevel desiredLevel Returns Type Description System.Collections.Generic.List < System.String > GetLogFilename() Returns the name of the current log file Declaration public string GetLogFilename() Returns Type Description System.String GetLogFilePath() Returns the path to which log files are written Declaration public string GetLogFilePath() Returns Type Description System.String IsNumberOfErrorsAndWarningsZero() For testing, this is a way to check that no errors or warnings have been given. Declaration public bool IsNumberOfErrorsAndWarningsZero() Returns Type Description System.Boolean ResetCounters() Reset all error and warning counters Declaration public void ResetCounters() SetCaseArray(String[]) If output is to be divided into multiple log files, set the names of each \"case\" Declaration public void SetCaseArray(string[] caseArray) Parameters Type Name Description System.String [] caseArray"
  },
  "api/TimeSeriesAnalysis.Utility.ParserFeedbackLogLine.html": {
    "href": "api/TimeSeriesAnalysis.Utility.ParserFeedbackLogLine.html",
    "title": "Struct ParserFeedbackLogLine | TimeSeriesAnalysis reference documentation",
    "keywords": "Struct ParserFeedbackLogLine Struct for each log message of ParserFeedback Inherited Members System.ValueType.Equals(System.Object) System.ValueType.GetHashCode() System.ValueType.ToString() System.Object.Equals(System.Object, System.Object) System.Object.GetType() System.Object.ReferenceEquals(System.Object, System.Object) Namespace : TimeSeriesAnalysis.Utility Assembly : TimeSeriesAnalysis.dll Syntax public struct ParserFeedbackLogLine Fields message Message Text Declaration public string message Field Value Type Description System.String messageLevel The level of the message Declaration public ParserfeedbackMessageLevel messageLevel Field Value Type Description ParserfeedbackMessageLevel time Time of message Declaration public DateTime time Field Value Type Description System.DateTime"
  },
  "api/TimeSeriesAnalysis.Utility.ParserfeedbackMessageLevel.html": {
    "href": "api/TimeSeriesAnalysis.Utility.ParserfeedbackMessageLevel.html",
    "title": "Enum ParserfeedbackMessageLevel | TimeSeriesAnalysis reference documentation",
    "keywords": "Enum ParserfeedbackMessageLevel Enum to set the log level of ParserFeedback Namespace : TimeSeriesAnalysis.Utility Assembly : TimeSeriesAnalysis.dll Syntax public enum ParserfeedbackMessageLevel Fields Name Description error Show error messages and above fatal Show only fatal error messages info Show information messages and above warn Show warning messages and above"
  },
  "api/TimeSeriesAnalysis.Utility.Plot.html": {
    "href": "api/TimeSeriesAnalysis.Utility.Plot.html",
    "title": "Class Plot | TimeSeriesAnalysis reference documentation",
    "keywords": "Class Plot Static methods for plotting one or more time-series across one or more y-axes and one or more subplots by opening up Chrome calling a set of JavaScript plotting methods based on plotly.js Time-series are written as CSV-files to a specific folder on disk plotDataPath , before starting a chrome-window that loads a specific \"localhost\" plotlyURL that reads said CSV-files and initates an in-browser plot using plotly.js. For this method to work you need to be running a web server such as IIS that serves up a \"localhost\" plotlyURL as described in the documentation. If you sometimes need to disable plots (for instance if plotting code is included in unit tests) see Plot4Test Inheritance System.Object Plot Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : TimeSeriesAnalysis.Utility Assembly : TimeSeriesAnalysis.dll Syntax public class Plot Methods FromList(List<Double[]>, List<String>, DateTime[], String, String, Boolean) Plot all variables in a list of doubles, that all have the same timestamps given by dataTimes Declaration public static string FromList(List<double[]> dataList, List<string> plotNames, DateTime[] dataTimes, string comment = null, string caseName = \"\", bool doStartChrome = true) Parameters Type Name Description System.Collections.Generic.List < System.Double []> dataList System.Collections.Generic.List < System.String > plotNames System.DateTime [] dataTimes common timestamps System.String comment System.String caseName System.Boolean doStartChrome Returns Type Description System.String FromList(List<Double[]>, List<String>, Double, String, DateTime, String, Boolean) Plot values in a list of vectors dataList , when all vectors start at t0 and have a stedy sampling rate Declaration public static string FromList(List<double[]> dataList, List<string> plotNames, double dT_s, string comment = null, DateTime t0 = default(DateTime), string caseName = \"\", bool doStartChrome = true) Parameters Type Name Description System.Collections.Generic.List < System.Double []> dataList List of doubles, one entry for each time-series to be plotted System.Collections.Generic.List < System.String > plotNames List of string of unique names to describe each plot, prefixed by either \"y1=\"(top left),\"y2=\"(top right),\"y3=\"(bottom left) or \"y4=\"(bottom right) to denote what y-axis to plot the variable on System.Double dT_s the time between data samples in seconds System.String comment a comment that is shown in the plot System.DateTime t0 the DateTime of the first data point System.String caseName give each plot a casename if creating multiple plots with the re-occurring variable names System.Boolean doStartChrome By setting doStartChrome to false, you can skip opening up chrome, the link to figure will instead be returned Returns Type Description System.String The url of the resulting plot is returned FromList(List<(Double[], DateTime[])>, List<String>, String, String, Boolean) Plot data from a list of value-date tuples (each time-series can have unique time-vector with unique sampling) Declaration public static string FromList(List<(double[], DateTime[])> dataDateTupleList, List<string> plotNames, string comment = null, string caseName = \"\", bool doStartChrome = true) Parameters Type Name Description System.Collections.Generic.List < System.ValueTuple < System.Double [], System.DateTime []>> dataDateTupleList System.Collections.Generic.List < System.String > plotNames System.String comment System.String caseName System.Boolean doStartChrome Returns Type Description System.String"
  },
  "api/TimeSeriesAnalysis.Utility.Plot4Test.html": {
    "href": "api/TimeSeriesAnalysis.Utility.Plot4Test.html",
    "title": "Class Plot4Test | TimeSeriesAnalysis reference documentation",
    "keywords": "Class Plot4Test Version of Plot class where plots code can be Enabled()/Disabled() programatically. This allows you to keep all your \"Plot\" calls in your unit tests and turn them on as needed to debug a single test, while avoid being overwhelmed with plots if for instance re-running all unit tests. Inheritance System.Object Plot4Test Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : TimeSeriesAnalysis.Utility Assembly : TimeSeriesAnalysis.dll Syntax public class Plot4Test Constructors Plot4Test(Boolean, Int32) Determine wheter plots are to be enabled or disabled on. To further prevent thousands of plots from accidentally being created by this object a maximum number of plots is set, override as needed. Declaration public Plot4Test(bool enableByDefault = true, int maxNplots = 6) Parameters Type Name Description System.Boolean enableByDefault System.Int32 maxNplots Methods Disable() Disable all subsequent calls to plot using the same instance of this class. Declaration public void Disable() Enable() Enable all subsequent calls to plot using the same instance of this class. Declaration public void Enable() FromList(List<Double[]>, List<String>, Int32, String, DateTime, String, Boolean) Wrapper for Plot.FromList that Declaration public string FromList(List<double[]> dataList, List<string> plotNames, int dT_s, string comment = null, DateTime t0 = default(DateTime), string caseName = \"\", bool doStartChrome = true) Parameters Type Name Description System.Collections.Generic.List < System.Double []> dataList System.Collections.Generic.List < System.String > plotNames System.Int32 dT_s System.String comment System.DateTime t0 System.String caseName System.Boolean doStartChrome Returns Type Description System.String GetNumberOfPlotsMade() Gets the number of plots that have been written Declaration public int GetNumberOfPlotsMade() Returns Type Description System.Int32"
  },
  "api/TimeSeriesAnalysis.Utility.PlotXY.html": {
    "href": "api/TimeSeriesAnalysis.Utility.PlotXY.html",
    "title": "Class PlotXY | TimeSeriesAnalysis reference documentation",
    "keywords": "Class PlotXY Inheritance System.Object PlotXY Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : TimeSeriesAnalysis.Utility Assembly : TimeSeriesAnalysis.dll Syntax public class PlotXY Methods FromTable(XYTable, String, String, Boolean) Declaration public static string FromTable(XYTable table, string caseName, string comment = null, bool doStartChrome = true) Parameters Type Name Description XYTable table System.String caseName System.String comment System.Boolean doStartChrome Returns Type Description System.String FromTables(List<XYTable>, String, String, Boolean) Declaration public static string FromTables(List<XYTable> tables, string caseName, string comment = null, bool doStartChrome = true) Parameters Type Name Description System.Collections.Generic.List < XYTable > tables System.String caseName System.String comment System.Boolean doStartChrome Returns Type Description System.String"
  },
  "api/TimeSeriesAnalysis.Utility.SigmaXml.html": {
    "href": "api/TimeSeriesAnalysis.Utility.SigmaXml.html",
    "title": "Class SigmaXml | TimeSeriesAnalysis reference documentation",
    "keywords": "Class SigmaXml Inheritance System.Object SigmaXml Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : TimeSeriesAnalysis.Utility Assembly : TimeSeriesAnalysis.dll Syntax public class SigmaXml Methods LoadFromFile(String) Load the sigma \"cache\" file format, often named \"cache.js\". This file is json file, but is converted to a xml-file by replacing the header, and is read from javascript in json format and is also read from c# in the xml-converted format. The data has both a \"cache\" and an \"eventdata\" portion, but this driver reads only the cache format where the time-series data is usually stored. Declaration public static (TimeSeriesDataSet, int) LoadFromFile(string xmlFileName) Parameters Type Name Description System.String xmlFileName Returns Type Description System.ValueTuple < TimeSeriesDataSet , System.Int32 >"
  },
  "api/TimeSeriesAnalysis.Utility.SignificantDigits.html": {
    "href": "api/TimeSeriesAnalysis.Utility.SignificantDigits.html",
    "title": "Class SignificantDigits | TimeSeriesAnalysis reference documentation",
    "keywords": "Class SignificantDigits Utility class to round double variables to a given nubmer of signficant digits. Inheritance System.Object SignificantDigits Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : TimeSeriesAnalysis.Utility Assembly : TimeSeriesAnalysis.dll Syntax public static class SignificantDigits Methods Format(Double, Int32) Rounds scalar down to number of significant digits (26->20 if digits=1 for instance) Declaration public static double Format(double number, int digits) Parameters Type Name Description System.Double number System.Int32 digits Returns Type Description System.Double Format(Double, Int32, out Int32) Rounds down to number of significant digits (26->20 if digits=1 for instance) Declaration public static double Format(double number, int digits, out int exponent) Parameters Type Name Description System.Double number System.Int32 digits System.Int32 exponent Returns Type Description System.Double Format(Double[], Int32) Rounds array down to number of significant digits (26->20 if digits=1 for instance) Declaration public static double[] Format(double[] numbers, int digits) Parameters Type Name Description System.Double [] numbers System.Int32 digits Returns Type Description System.Double [] GetSciFormat(Double, out Double, out Int32) Returns number in scientific format with coefficient and exponential paramters Declaration public static void GetSciFormat(double number, out double coeff, out int exp) Parameters Type Name Description System.Double number System.Double coeff System.Int32 exp SciToDouble(Double, Int32) Converts a scientific number on the format coeff*10^exp to a double Declaration public static double SciToDouble(double coeff, int exp) Parameters Type Name Description System.Double coeff coefficient System.Int32 exp exponent Returns Type Description System.Double converted double"
  },
  "api/TimeSeriesAnalysis.Utility.StringToFileWriter.html": {
    "href": "api/TimeSeriesAnalysis.Utility.StringToFileWriter.html",
    "title": "Class StringToFileWriter | TimeSeriesAnalysis reference documentation",
    "keywords": "Class StringToFileWriter IO Utility class to write to file that implements IDisposable interface. Suggest to use this objects of this class within the using keyword so that file-resources are automatically freed in case your code is terminated before it has completed. Inheritance System.Object StringToFileWriter Implements System.IDisposable Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : TimeSeriesAnalysis.Utility Assembly : TimeSeriesAnalysis.dll Syntax public class StringToFileWriter : IDisposable Constructors StringToFileWriter(String) Constructor with local encodign Declaration public StringToFileWriter(string filename) Parameters Type Name Description System.String filename StringToFileWriter(String, Encoding) Constructor with specific encoding Declaration public StringToFileWriter(string filename, Encoding encoding) Parameters Type Name Description System.String filename file to be creates System.Text.Encoding encoding text encoding format Methods Close() Close file handles Declaration public bool Close() Returns Type Description System.Boolean CreateDirectoryStructure(String) creates directory on path if it does not exist Declaration public void CreateDirectoryStructure(string FilePath) Parameters Type Name Description System.String FilePath Dispose() Disposes Declaration public void Dispose() Dispose(Boolean) Dispose Declaration protected virtual void Dispose(bool disposing) Parameters Type Name Description System.Boolean disposing Write(String) Write a single line of text Declaration public void Write(string text) Parameters Type Name Description System.String text Implements System.IDisposable"
  },
  "api/TimeSeriesAnalysis.Utility.TimeSeriesCreator.html": {
    "href": "api/TimeSeriesAnalysis.Utility.TimeSeriesCreator.html",
    "title": "Class TimeSeriesCreator | TimeSeriesAnalysis reference documentation",
    "keywords": "Class TimeSeriesCreator Class for static methods create different types of time-series for testing. Inheritance System.Object TimeSeriesCreator Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : TimeSeriesAnalysis.Utility Assembly : TimeSeriesAnalysis.dll Syntax public static class TimeSeriesCreator Methods Constant(Double, Int32) Creates a vector of a constant value Declaration public static double[] Constant(double value, int N) Parameters Type Name Description System.Double value constant value of time-series System.Int32 N number of data points of time-series Returns Type Description System.Double [] CreateDateStampArray(DateTime, Int32, Int32) Create an array of DateTimes starting at t0 of length N and with sampling interval dT_s Declaration public static DateTime[] CreateDateStampArray(DateTime t0, int dT_s, int N) Parameters Type Name Description System.DateTime t0 first datetime in the array to be created System.Int32 dT_s sampling internval System.Int32 N number of desired data points Returns Type Description System.DateTime [] Noise(Int32, Double, Nullable<Int32>) Declaration public static double[] Noise(int N, double noiseAmplitude, int? seed = null) Parameters Type Name Description System.Int32 N System.Double noiseAmplitude System.Nullable < System.Int32 > seed Returns Type Description System.Double [] RandomWalk(Int32, Double, Double, Nullable<Int32>) Declaration public static double[] RandomWalk(int N, double stepAmplitude, double startval = 0, int? seed = null) Parameters Type Name Description System.Int32 N System.Double stepAmplitude System.Double startval System.Nullable < System.Int32 > seed Returns Type Description System.Double [] Sinus(Double, Double, Int32, Int32) Create an array representing a sinus Declaration public static double[] Sinus(double amplitude, double sinusPeriod_s, int dT_s, int N) Parameters Type Name Description System.Double amplitude amplitud of sinus System.Double sinusPeriod_s time for a complete 360 degree period of the sinus in seconds System.Int32 dT_s the timebase System.Int32 N number of desired data point in return array Returns Type Description System.Double [] an array continaing the specified sinus Step(Int32, Int32, Double, Double) Create a step change vector of a given length N starting at value val1 and ending at val2 , step occuring at index stepStartIdx Declaration public static double[] Step(int stepStartIdx, int N, double val1, double val2) Parameters Type Name Description System.Int32 stepStartIdx index of step System.Int32 N total time series length System.Double val1 value before step System.Double val2 value after step Returns Type Description System.Double [] created vector, or null if inputs make no sense ThreeSteps(Int32, Int32, Int32, Int32, Double, Double, Double, Double) Create a time-series with three step changes Declaration public static double[] ThreeSteps(int step1StartIdx, int step2StartIdx, int step3StartIdx, int N, double val1, double val2, double val3, double val4) Parameters Type Name Description System.Int32 step1StartIdx System.Int32 step2StartIdx System.Int32 step3StartIdx System.Int32 N System.Double val1 System.Double val2 System.Double val3 System.Double val4 Returns Type Description System.Double [] TwoSteps(Int32, Int32, Int32, Double, Double, Double) Create a time-series with two step changes Declaration public static double[] TwoSteps(int step1StartIdx, int step2StartIdx, int N, double val1, double val2, double val3) Parameters Type Name Description System.Int32 step1StartIdx index of first step change System.Int32 step2StartIdx index of second step change System.Int32 N System.Double val1 value before steps System.Double val2 value of first step System.Double val3 value of second step Returns Type Description System.Double []"
  },
  "api/TimeSeriesAnalysis.Utility.UnixTime.html": {
    "href": "api/TimeSeriesAnalysis.Utility.UnixTime.html",
    "title": "Class UnixTime | TimeSeriesAnalysis reference documentation",
    "keywords": "Class UnixTime Utility class to work with unix time stamps Inheritance System.Object UnixTime Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : TimeSeriesAnalysis.Utility Assembly : TimeSeriesAnalysis.dll Syntax public class UnixTime Methods ConvertFromUnixTimestamp(Double) Converts a unix timestamp into a DateTime Declaration public static DateTime ConvertFromUnixTimestamp(double timestamp) Parameters Type Name Description System.Double timestamp the double time stamp to be converted Returns Type Description System.DateTime a converted DateTime object ConvertToUnixTimestamp(DateTime) Converts a DateTime into a unix timestamp Declaration public static double ConvertToUnixTimestamp(DateTime date) Parameters Type Name Description System.DateTime date Returns Type Description System.Double A unix time stamp double GetNowUnixTime() Returns the Unix time of the current UTC-time. Declaration public static double GetNowUnixTime() Returns Type Description System.Double"
  },
  "api/TimeSeriesAnalysis.Utility.XYlineType.html": {
    "href": "api/TimeSeriesAnalysis.Utility.XYlineType.html",
    "title": "Enum XYlineType | TimeSeriesAnalysis reference documentation",
    "keywords": "Enum XYlineType Namespace : TimeSeriesAnalysis.Utility Assembly : TimeSeriesAnalysis.dll Syntax public enum XYlineType Fields Name Description line noMarkers withMarkers"
  },
  "api/TimeSeriesAnalysis.Utility.XYTable.html": {
    "href": "api/TimeSeriesAnalysis.Utility.XYTable.html",
    "title": "Class XYTable | TimeSeriesAnalysis reference documentation",
    "keywords": "Class XYTable Inheritance System.Object XYTable Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : TimeSeriesAnalysis.Utility Assembly : TimeSeriesAnalysis.dll Syntax public class XYTable Constructors XYTable(String, List<String>, XYlineType) Declaration public XYTable(string tableName, List<string> columnNames, XYlineType type = XYlineType.withMarkers) Parameters Type Name Description System.String tableName System.Collections.Generic.List < System.String > columnNames XYlineType type Methods AddRow(Double[], String) Declaration public void AddRow(double[] rowValues, string rowName = \"\") Parameters Type Name Description System.Double [] rowValues System.String rowName GetLineType() Declaration public XYlineType GetLineType() Returns Type Description XYlineType GetName() Declaration public string GetName() Returns Type Description System.String ToCSV(String, String) Declaration public void ToCSV(string fileName, string CSVseparator = \",\") Parameters Type Name Description System.String fileName System.String CSVseparator"
  },
  "api/TimeSeriesAnalysis.Vec.html": {
    "href": "api/TimeSeriesAnalysis.Vec.html",
    "title": "Class Vec | TimeSeriesAnalysis reference documentation",
    "keywords": "Class Vec Utility functions and operations for treating arrays as mathetmatical vectors. This class considers doubles, methods that require comparisons cannot be easily ported to generic \"Vec\"/> Inheritance System.Object Vec Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : TimeSeriesAnalysis Assembly : TimeSeriesAnalysis.dll Syntax public class Vec Constructors Vec(Double, Double) Constructor Declaration public Vec(double nanValue = -9999, double valuteToReturnElementIsNaN = NaN) Parameters Type Name Description System.Double nanValue inputs values matching this value are treated as \"NaN\" and are excluded from all calculations System.Double valuteToReturnElementIsNaN value to return in elementwise calculations to indiate Nan output Methods Abs(Double[]) returns an array where each value is the absolute value of array1 Declaration public double[] Abs(double[] array1) Parameters Type Name Description System.Double [] array1 Returns Type Description System.Double [] Add(Double[], Double) elementwise addition of val2 to array1 Declaration public double[] Add(double[] array1, double val2) Parameters Type Name Description System.Double [] array1 System.Double val2 Returns Type Description System.Double [] Add(Double[], Double[]) returns an array which is the elementwise addition of array1 and array2 Declaration public double[] Add(double[] array1, double[] array2) Parameters Type Name Description System.Double [] array1 System.Double [] array2 Returns Type Description System.Double [] ContainsBadData(Double[]) Returns true f array contains a \"-9999\" or NaN indicating missing data Declaration public bool ContainsBadData(double[] x) Parameters Type Name Description System.Double [] x Returns Type Description System.Boolean Cov(Double[], Double[], Boolean) returns the co-variance of two arrays(interpreted as \"vectors\") Declaration public double Cov(double[] array1, double[] array2, bool doNormalize = false) Parameters Type Name Description System.Double [] array1 System.Double [] array2 System.Boolean doNormalize Returns Type Description System.Double Deserialize(String) de-serializes a single vector/array (written by serialize) Declaration public static double[] Deserialize(string fileName) Parameters Type Name Description System.String fileName Returns Type Description System.Double [] Diff(Double[], List<Int32>) Return an array of the differences between the neighboring items in array but ignores indices in the array that are in \"indicesToIgnore\" Declaration public double[] Diff(double[] vec, List<int> indicesToIgnore = null) Parameters Type Name Description System.Double [] vec System.Collections.Generic.List < System.Int32 > indicesToIgnore Returns Type Description System.Double [] Div(Double[], Double) Divides an vector by a scalar value Declaration public double[] Div(double[] vector, double scalar) Parameters Type Name Description System.Double [] vector System.Double scalar Returns Type Description System.Double [] an vector of values representing the array didived by a scalar. In case of NaN inputs or divide-by-zero NaN elements are returned. Div(Double[], Double[]) Divides two vectors of equal length Declaration public double[] Div(double[] vector1, double[] vector2) Parameters Type Name Description System.Double [] vector1 System.Double [] vector2 Returns Type Description System.Double [] an vector of values representing the array didived by a scalar. In case of NaN inputs or divide-by-zero NaN elements are returned FindValues(Double[], Double, VectorFindValueType, List<Int32>) return the indices of elements in the array that have certain relation to value given type (bigger,smaller,equal etc.) Also capable of finding NaN values Declaration public List<int> FindValues(double[] vec, double value, VectorFindValueType type, List<int> indicesToIgnore = null) Parameters Type Name Description System.Double [] vec System.Double value VectorFindValueType type System.Collections.Generic.List < System.Int32 > indicesToIgnore if given, these indices are ignored when doing the operation Returns Type Description System.Collections.Generic.List < System.Int32 > GetGradient(Double[], DateTime[], Int32, Int32[]) Gets the gradient of a time-series Works by running a regression with time as the \"X\" variable Declaration public static RegressionResults GetGradient(double[] values, DateTime[] dates, int sampleTime_sec = 1, int[] indicesToIgnore = null) Parameters Type Name Description System.Double [] values values for which the graident is sought System.DateTime [] dates dates corrsponding to the values System.Int32 sampleTime_sec in what unit of time (given in seconds)the gradient shall be persented System.Int32 [] indicesToIgnore optional array of indices that are to be ignored during regression Returns Type Description RegressionResults the gradient will be the \"Gain\" of the returned object (in units per second by default) GetValues(Double[], List<Int32>) Returns all the values of vec, except for those corresponding with indices in indicesToIngore Declaration public double[] GetValues(double[] vec, List<int> indicesToIgnore) Parameters Type Name Description System.Double [] vec System.Collections.Generic.List < System.Int32 > indicesToIgnore Returns Type Description System.Double [] IsAllNaN(Double[]) Returns true if all elements in array are \"-9999\" or Double.NaN, or is null Declaration public bool IsAllNaN(double[] array) Parameters Type Name Description System.Double [] array Returns Type Description System.Boolean IsAllValue(Double[], Double) Returns true if all elements in array are the specific value Declaration public static bool IsAllValue(double[] array, double value = 0) Parameters Type Name Description System.Double [] array System.Double value Returns Type Description System.Boolean Max(Double[]) Returns maximum value of array Declaration public double Max(double[] array) Parameters Type Name Description System.Double [] array Returns Type Description System.Double Max(Double[], List<Int32>) Returns maximum value of array, ignoring the given indices Declaration public double Max(double[] array, List<int> indicesToIgnore) Parameters Type Name Description System.Double [] array System.Collections.Generic.List < System.Int32 > indicesToIgnore Returns Type Description System.Double Max(Double[], Double) Returns element-wise maximum of array element and value Declaration public double[] Max(double[] array, double value) Parameters Type Name Description System.Double [] array System.Double value Returns Type Description System.Double [] Max(Double[], Double[]) Returns maximum value of two array as new array Declaration public double[] Max(double[] array1, double[] array2) Parameters Type Name Description System.Double [] array1 System.Double [] array2 Returns Type Description System.Double [] Max(Double[], out Int32) Returns maximum value of array and index of maximum value Declaration public double Max(double[] array, out int ind) Parameters Type Name Description System.Double [] array System.Int32 ind Returns Type Description System.Double Mean(Double[]) returns the mean value of array1 Declaration public double? Mean(double[] array1) Parameters Type Name Description System.Double [] array1 Returns Type Description System.Nullable < System.Double > Min(Double[]) Minimum value of array Declaration public double Min(double[] array) Parameters Type Name Description System.Double [] array Returns Type Description System.Double Min(Double[], List<Int32>) Returns minimum value of array, ignoring certain indices Declaration public double Min(double[] array, List<int> indicesToIgnore) Parameters Type Name Description System.Double [] array System.Collections.Generic.List < System.Int32 > indicesToIgnore Returns Type Description System.Double Min(Double[], Double) Returns element-wise minimum of array element and value Declaration public double[] Min(double[] array, double value) Parameters Type Name Description System.Double [] array System.Double value Returns Type Description System.Double [] Min(Double[], Double[]) Returns minimum value of two array as new array Declaration public static double[] Min(double[] array1, double[] array2) Parameters Type Name Description System.Double [] array1 System.Double [] array2 Returns Type Description System.Double [] Min(Double[], out Int32) Returns minimum value of array and index of maximum value Declaration public double Min(double[] array, out int ind) Parameters Type Name Description System.Double [] array System.Int32 ind Returns Type Description System.Double Multiply(Double[], Double) elementwise multipliation of val2 to array1 Declaration public double[] Multiply(double[] array1, double val2) Parameters Type Name Description System.Double [] array1 System.Double val2 Returns Type Description System.Double [] Multiply(Double[], Double[]) elementwise multiplication of array1 and array2, assuming they are same size Declaration public double[] Multiply(double[] array1, double[] array2) Parameters Type Name Description System.Double [] array1 System.Double [] array2 Returns Type Description System.Double [] NonCausalSmooth(Double[], Int32) smooths the array without phase-shifting by using both past and future values (i.e. so called non-causal smoothing) Declaration public double[] NonCausalSmooth(double[] array1, int kernel = 1) Parameters Type Name Description System.Double [] array1 System.Int32 kernel Returns Type Description System.Double [] Pow(Double[], Double) Calculates the power of an array Declaration public double[] Pow(double[] array, double factor) Parameters Type Name Description System.Double [] array System.Double factor Returns Type Description System.Double [] Rand(Int32, Double, Double, Nullable<Int32>) Create a vector of random numbers Declaration public static double[] Rand(int N, double minValue = 0, double maxValue = 1, int? seed = null) Parameters Type Name Description System.Int32 N the number of samples of the returned array System.Double minValue lower end of random number range System.Double maxValue higher end of random number range System.Nullable < System.Int32 > seed optionally, give in a seed number, this makes random sequence repeatable Returns Type Description System.Double [] an array of size N of random numbers between minValue and maxValue Range(Double[]) Returns range of an array, the difference between minimum and maximum Declaration public double Range(double[] array) Parameters Type Name Description System.Double [] array Returns Type Description System.Double Regress(Double[], Double[,], Int32[]) Robust linear regression Declaration public RegressionResults Regress(double[] Y, double[, ] X, int[] yIndToIgnore = null) Parameters Type Name Description System.Double [] Y vector of responve variable values (to be modelled) System.Double [,] X 2D matrix of of mainpulated values/independent values/regressors used to explain Y System.Int32 [] yIndToIgnore (optional) a list of the indices of values in Y to ignore in regression. By default it is null Returns Type Description RegressionResults an object of the RegressionResult class with the paramters, as well as some statistics on the fit and uncertainty thereof. RegressRegularized(Double[], Double[][], Int32[], List<Int32>) Robust linear regression, regularizd To avoid paramters taking on exteremly high values in the case of little excitation in the inputs, two mitigating actions are implemented by the solver, to be \"robust\" a \"robust\" Signular Value Decomposition(SVD)-based solver is used a regularization term is added to the objective function that will bring paramters to zero if (Y,X) does not contain any information to force the parameter away from zero Declaration public RegressionResults RegressRegularized(double[] Y, double[][] X, int[] yIndToIgnore = null, List<int> XindicesToRegularize = null) Parameters Type Name Description System.Double [] Y vector of outptu variable values to be modelled System.Double [][] X jagged 2D matrix of of mainpulated values/independent values/regressors used to explain Y System.Int32 [] yIndToIgnore (optional) a list of the indices of values in Y to ignore in regression. By default it is null System.Collections.Generic.List < System.Int32 > XindicesToRegularize (optional) only the indices in this list are to be regularized to zero Returns Type Description RegressionResults an object of the RegressionResult class with the paramters, as well as some statistics on the fit and uncertainty thereof. RegressUnRegularized(Double[], Double[][], Int32[]) Regression that does not attempt to regualarize inputs toward zero Declaration public RegressionResults RegressUnRegularized(double[] Y, double[][] X, int[] yIndToIgnore = null) Parameters Type Name Description System.Double [] Y System.Double [][] X System.Int32 [] yIndToIgnore Returns Type Description RegressionResults ReplaceIndWithValue(Double[], List<Int32>, Double) Replace certain values in an array with a new value. Declaration public static double[] ReplaceIndWithValue(double[] array, List<int> indList, double valueToReplaceWith) Parameters Type Name Description System.Double [] array the array to be replaces System.Collections.Generic.List < System.Int32 > indList list of all the indices of all data points in array to be replaced System.Double valueToReplaceWith the new value to use in place of old values. Returns Type Description System.Double [] A copy of the original array with the values repalced as specified ReplaceValuesAbove(Double[], Double, Double) Replace values below a threshold in an array with a new value Declaration public static double[] ReplaceValuesAbove(double[] array, double threshold, double valueToReplaceWith) Parameters Type Name Description System.Double [] array System.Double threshold System.Double valueToReplaceWith Returns Type Description System.Double [] ReplaceValuesAboveOrBelow(Double[], Double, Double, Double) Replace values above a higher threshold or below a lower threshold with a new value Declaration public static double[] ReplaceValuesAboveOrBelow(double[] array, double lowerThreshold, double higherThreshold, double valueToReplaceWith) Parameters Type Name Description System.Double [] array System.Double lowerThreshold System.Double higherThreshold System.Double valueToReplaceWith Returns Type Description System.Double [] ReplaceValuesBelow(Double[], Double, Double) Replace all values above a certain threshold in array with a new value Declaration public static double[] ReplaceValuesBelow(double[] array, double threshold, double valueToReplaceWith) Parameters Type Name Description System.Double [] array System.Double threshold System.Double valueToReplaceWith Returns Type Description System.Double [] RSquared(Double[], Double[], List<Int32>, Int32) R-squared R-squared (R2) is a statistical measure that represents the proportion of the variance for a dependent variable that's explained by an independent variable or variables in a regression model. Whereas correlation explains the strength of the relationship between an independent and dependent variable, R-squared explains to what extent the variance of one variable explains the variance of the second variable. So, if the R2 of a model is 0.50 , then approximately half of the observed variation can be explained by the model's inputs. Declaration public double RSquared(double[] vector1, double[] vector2, List<int> indToIgnoreExt = null, int ymodOffset = -1) Parameters Type Name Description System.Double [] vector1 first vector System.Double [] vector2 second vector System.Collections.Generic.List < System.Int32 > indToIgnoreExt optionally: indices to be ignored(for instance bad values) System.Int32 ymodOffset Returns Type Description System.Double R2 squared, a value between -1 and 1 . If an error occured, Double.PositiveInfinity is returned SelfSumOfAbsErr(Double[]) sum of absolute error of the vector compared to itself Declaration public double SelfSumOfAbsErr(double[] vec) Parameters Type Name Description System.Double [] vec Returns Type Description System.Double SelfSumOfSquareErr(Double[]) sum of square error of the vector compared to itself Declaration public double SelfSumOfSquareErr(double[] vec) Parameters Type Name Description System.Double [] vec Returns Type Description System.Double Serialize(Double[], String) serializes a single vector/array to a file for persistent storage to a human-readable text format Vector data can then be retreived by companion method Deserialize Declaration public static bool Serialize(double[] vector, string fileName) Parameters Type Name Description System.Double [] vector vector to be written to afile System.String fileName the file name (or path) of the file to which the vector is to serialized to Returns Type Description System.Boolean Subtract(Double[], Double) elementwise subtraction of val2 from array1 Declaration public double[] Subtract(double[] array1, double val2) Parameters Type Name Description System.Double [] array1 System.Double val2 Returns Type Description System.Double [] Subtract(Double[], Double[]) elementwise subtraction of array1 and array2, assuming they are same size Declaration public double[] Subtract(double[] array1, double[] array2) Parameters Type Name Description System.Double [] array1 System.Double [] array2 Returns Type Description System.Double [] Sum(Double[]) returns the sum of array1 Declaration public double? Sum(double[] array1) Parameters Type Name Description System.Double [] array1 Returns Type Description System.Nullable < System.Double > SumOfAbsErr(Double[], Double[], Int32) The sum of absolute errors (|a1-a2|) between array1 and array2 Declaration public double SumOfAbsErr(double[] array1, double[] array2, int indexOffset = -1) Parameters Type Name Description System.Double [] array1 System.Double [] array2 System.Int32 indexOffset Returns Type Description System.Double SumOfSquareErr(Double[], Double, Boolean) sum of square error of the vector compared to a constant. by defautl the return value is normalized by dividing by, this normalization can be turned off Declaration public static double SumOfSquareErr(double[] vec, double constant, bool doNormalization = true) Parameters Type Name Description System.Double [] vec System.Double constant System.Boolean doNormalization Returns Type Description System.Double SumOfSquareErr(Double[], Double[], Int32, Boolean, List<Int32>) The sum of square errors (a1-a2)^2 between array1 and array2 . Declaration public double SumOfSquareErr(double[] array1, double[] array2, int ymodOffset = -1, bool divByN = true, List<int> indToIgnore = null) Parameters Type Name Description System.Double [] array1 System.Double [] array2 System.Int32 ymodOffset System.Boolean divByN if true, the result is normalized by the number of good values System.Collections.Generic.List < System.Int32 > indToIgnore optionally a list of indices of array1 to ignore Returns Type Description System.Double ToString(Double[], Int32, String) Create a compact string of vector with a certain number of significant digits and a chosen divider Declaration public static string ToString(double[] array, int nSignificantDigits, string dividerStr = \";\") Parameters Type Name Description System.Double [] array System.Int32 nSignificantDigits System.String dividerStr Returns Type Description System.String Var(Double[], Boolean) returns the variance of the array (always apositive number) Declaration public double Var(double[] array1, bool doNormalize = false) Parameters Type Name Description System.Double [] array1 System.Boolean doNormalize Returns Type Description System.Double"
  },
  "api/TimeSeriesAnalysis.Vec-1.html": {
    "href": "api/TimeSeriesAnalysis.Vec-1.html",
    "title": "Class Vec<T> | TimeSeriesAnalysis reference documentation",
    "keywords": "Class Vec<T> Class for generic methods on any type T that treat arrays as vectors (sorting,slicing,concatenating). For mathematical methods on vectors of doubles and integers, look into non-generic sister class \"Vec\". Inheritance System.Object Vec<T> Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : TimeSeriesAnalysis Assembly : TimeSeriesAnalysis.dll Syntax public static class Vec<T> Type Parameters Name Description T type, such as double, int or DateTime Methods Concat(T[], T) concatenates the value y to the end of array x Declaration public static T[] Concat(T[] x, T y) Parameters Type Name Description T[] x T y Returns Type Description T[] Concat(T[], T[]) concatenates arrays x and y into a new larger array Declaration public static T[] Concat(T[] x, T[] y) Parameters Type Name Description T[] x T[] y Returns Type Description T[] Downsample(T[], Int32) Downsample a vector by a given factor(selet only every Nth value) Declaration public static T[] Downsample(T[] vec, int factor) Parameters Type Name Description T[] vec System.Int32 factor Returns Type Description T[] Fill(T, Int32) creates an array of size N where every element has value value Declaration public static T[] Fill(T value, int N) Parameters Type Name Description T value System.Int32 N Returns Type Description T[] GetIndicesOfValue(T, List<T>) Get the indice of value val values that are present in vec Declaration public static List<int> GetIndicesOfValue(T val, List<T> vec) Parameters Type Name Description T val System.Collections.Generic.List <T> vec Returns Type Description System.Collections.Generic.List < System.Int32 > GetIndicesOfValues(List<T>, List<T>) Get the indices of vec1 values that are present in vec2 Declaration public static List<int> GetIndicesOfValues(List<T> vec1, List<T> vec2) Parameters Type Name Description System.Collections.Generic.List <T> vec1 The results are related to the positions in this vector System.Collections.Generic.List <T> vec2 vec1 is compared to this vector Returns Type Description System.Collections.Generic.List < System.Int32 > GetValuesAtIndices(T[], List<Int32>) returns an array of the values that are in array at the indices given by indices list, or null if input is null Declaration public static T[] GetValuesAtIndices(T[] array, List<int> indices) Parameters Type Name Description T[] array System.Collections.Generic.List < System.Int32 > indices Returns Type Description T[] GetValuesExcludingIndices(T[], List<Int32>) returns an array of the values that are in array excluding those with indices given by indices list Declaration public static T[] GetValuesExcludingIndices(T[] array, List<int> indices) Parameters Type Name Description T[] array System.Collections.Generic.List < System.Int32 > indices Returns Type Description T[] Intersect(List<T>, List<T>) returns the intersection of array1 and array2, a list of elements that are in both vectors Declaration public static List<T> Intersect(List<T> vec1, List<T> vec2) Parameters Type Name Description System.Collections.Generic.List <T> vec1 System.Collections.Generic.List <T> vec2 Returns Type Description System.Collections.Generic.List <T> Intersect(List<List<T>>) returns the intersection of a number of arrays Declaration public static List<T> Intersect(List<List<T>> lists) Parameters Type Name Description System.Collections.Generic.List < System.Collections.Generic.List <T>> lists Returns Type Description System.Collections.Generic.List <T> IsConstant(T[]) returns the intersection of a number of arrays Declaration public static bool IsConstant(T[] vec) Parameters Type Name Description T[] vec Returns Type Description System.Boolean ReplaceIndWithValuesPrior(Double[], List<Int32>) replaces all the vaules in array with indices in indList with the last good value prior to that index. Declaration public static double[] ReplaceIndWithValuesPrior(double[] array, List<int> indList) Parameters Type Name Description System.Double [] array System.Collections.Generic.List < System.Int32 > indList Returns Type Description System.Double [] Sort(T[], VectorSortType) Sort a vector Declaration public static T[] Sort(T[] vec, VectorSortType sortType) Parameters Type Name Description T[] vec vector to be sorted VectorSortType sortType the type of sorting Returns Type Description T[] indices of vec in sorted order Sort(T[], VectorSortType, out Int32[]) Sort the vector Declaration public static T[] Sort(T[] vec, VectorSortType sortType, out int[] idx) Parameters Type Name Description T[] vec VectorSortType sortType System.Int32 [] idx Returns Type Description T[] SubArray(T[], Int32, Int32) Returns the portion of array1 starting and indStart, and ending at indEnd(or at the end if third paramter is omitted) Declaration public static T[] SubArray(T[] array1, int indStart, int indEnd = -9999) Parameters Type Name Description T[] array1 array to get subarray from System.Int32 indStart starting index System.Int32 indEnd ending index(or to the end if omitted) Returns Type Description T[] null if indStart and indEnd are the same, otherwise the subarray"
  },
  "api/TimeSeriesAnalysis.VecExtensionMethods.html": {
    "href": "api/TimeSeriesAnalysis.VecExtensionMethods.html",
    "title": "Class VecExtensionMethods | TimeSeriesAnalysis reference documentation",
    "keywords": "Class VecExtensionMethods Utility functions and operations for treating arrays as mathetmatical vectors Inheritance System.Object VecExtensionMethods Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : TimeSeriesAnalysis Assembly : TimeSeriesAnalysis.dll Syntax public static class VecExtensionMethods Methods Add(Double[], Double, Double) Add a scalar to vector Declaration public static double[] Add(this double[] array, double scalar, double nanValue = -9999) Parameters Type Name Description System.Double [] array System.Double scalar System.Double nanValue Returns Type Description System.Double [] Mult(Double[], Double, Double) Multiply vector by a scalar Declaration public static double[] Mult(this double[] array, double scalar, double nanValue = -9999) Parameters Type Name Description System.Double [] array System.Double scalar System.Double nanValue Returns Type Description System.Double [] Sub(Double[], Double[], Double) Elementwise subtraction of two arrays of same size Declaration public static double[] Sub(this double[] array1, double[] array2, double nanValue = -9999) Parameters Type Name Description System.Double [] array1 System.Double [] array2 System.Double nanValue Returns Type Description System.Double [] SubArray(Double[], Int32, Int32) Returns the portion of array1 starting and indStart, and ending at indEnd(or at the end if third paramter is omitted) Declaration public static double[] SubArray(this double[] array1, int indStart, int indEnd = -9999) Parameters Type Name Description System.Double [] array1 array to get subarray from System.Int32 indStart starting index System.Int32 indEnd ending index(or to the end if omitted) Returns Type Description System.Double [] null if indStart and indEnd are the same, otherwise the subarray ToString(Double[], Int32, String) Create a compact string of vector with a certain number of significant digits and a chosen divider Declaration public static string ToString(this double[] array, int nSignificantDigits, string dividerStr = \";\") Parameters Type Name Description System.Double [] array System.Int32 nSignificantDigits System.String dividerStr Returns Type Description System.String"
  },
  "api/TimeSeriesAnalysis.VectorFindValueType.html": {
    "href": "api/TimeSeriesAnalysis.VectorFindValueType.html",
    "title": "Enum VectorFindValueType | TimeSeriesAnalysis reference documentation",
    "keywords": "Enum VectorFindValueType Input to Vec.FindValues which specifies the criteria of the search Namespace : TimeSeriesAnalysis Assembly : TimeSeriesAnalysis.dll Syntax public enum VectorFindValueType Fields Name Description BiggerOrEqual \">=\" : Find values which are bigger than or equal BiggerThan \">\" : Find values which are bigger than Equal \"==\": Find values which are equal NaN Find values that are Double.NaN NotEqual Find values that are NOT equal to a given value NotNaN Find values that are NOT Double.NaN SmallerOrEqual Find values which are smaller than or equal SmallerThan Find values which are smaller than"
  },
  "api/TimeSeriesAnalysis.VectorSortType.html": {
    "href": "api/TimeSeriesAnalysis.VectorSortType.html",
    "title": "Enum VectorSortType | TimeSeriesAnalysis reference documentation",
    "keywords": "Enum VectorSortType Input to Vec.Sort that specifies how values are to be sorted Namespace : TimeSeriesAnalysis Assembly : TimeSeriesAnalysis.dll Syntax public enum VectorSortType Fields Name Description Ascending Sort in ascending order (smallest first) Descending Sort in descending order (biggest first)"
  },
  "articles/accord.html": {
    "href": "articles/accord.html",
    "title": "Accord.NET | TimeSeriesAnalysis reference documentation",
    "keywords": "Accord.NET This library is built on top of the excellent Accord.NET framework . Accord.NET is licensed under the \"GNU Lesser Public License v2.1\". It can be used in commercial applications \"as long as you are only linking unmodified .dll files and mention in your software and relevant source material that you are using this framework\" - like I am doing right here. The main author of Accord.NET has also stated that \"any files in the project that have only my name on the headers are now available under the MIT license.\" . He has also stated \"If anyone would like, feel free to grab the framework and tear it apart, grab the parts that worked better for you and fork it!\" Thanks to the developers of Accord.NET for a great framework! Development of Accord.NET has stopped at version 3.8.0, but I see this as no reason to worry, as the methods that are used are very stable - actually, you would not expect a mathematics library to need to continue development indefinitely. In versions 1.x of TimeSeriesAnalysis , Accord.NET is only used inside Vec.Regress , and so removing the dependency to Accord.NET would only require this one method to be ported. Accord.NET has implemented classification , clustering , kernel methods and hypothesis testing that may become useful in future work within data-mining and building larger scale models toward version 2.x . Note It is also possible to bulid on top of ML.NET in development toward version 2.0."
  },
  "articles/c_sharp.html": {
    "href": "articles/c_sharp.html",
    "title": "Setting up and running unit tests | TimeSeriesAnalysis reference documentation",
    "keywords": "Setting up and running unit tests Note Unit tests are an important part of the documenting this class library, as they give examples of how to run the public interface of the library, and document the expected output. Thus, unit tests are worth studying even for users who do not intend to write or modify unit tests. Unit tests are implemented using NUnit 3. In Visual Studio you should be able to browse the unit tests in the window Tests>>Test Explorer . In the Test Explorer window, pressing Run All tests should cause all tests to turn green . In some cases, it may be that the tests appear grayed or or with a blue exclamation point beside them. That indicate an issue with the installation of the Nunit3TestAdapter package through NuGet, which is required for integration NUnit with Visual Studio. Note If you want to submit a pull request for new functionality, writing a new a unit test is required. Note Note that some tests related to plotting are Explicit , and will need be run one-by-one. This has been done this way as this tests require manual inspection, and to avoid drowning the user in plots when re-running unit tests. Nuget package upload how-to You do not need to follow this section, as these workflow is now integrated in a GitHub action that runs on every commit. This section is kept as documentation of how this was set up. This is .NET framework 4.7.2 class library published to github packages, by means of the following tutorial: https://github.community/t/publish-net-framework-nuget-package/3077/2 and here: https://docs.microsoft.com/en-us/nuget/create-packages/creating-a-package-msbuild Note that the steps here are somewhat different to most online tutorials which target .NET Core and use the \"dotnet\" CLI instead of \"nuget\" CLI. For future reference, this is the steps followed: make sure the classes you want to give access to are public. the description that will be shown in nuget when downloading is pulled from in the .csproj file beneath . Consider adding it. Also add the the url to the repository and some other info such as shown below: <RepositoryUrl>https://github.com/equinor/TimeSeriesAnalysis</RepositoryUrl> <RepositoryType>git</RepositoryType> <GeneratePackageOnBuild>true</GeneratePackageOnBuild> <PackageOutputPath>bin\\debug\\</PackageOutputPath> <Version>1.0.0</Version> <Authors>Steinar Elgster</Authors> <description>todo</description> recommend adding in information to the AssemblyInfo.cs before starting. a personal access token xxxxxxx needs to be generated for your user in github,and needs access to \"read:packages\", \"write:packages\" and \"repo\".organization access (authorize with SSO ) and then press \"authorize\" create a nuget.config file that defines \"github\" as a nuget destination: <configuration> <packageSources> <clear /> <add key=\"github\" value=\"https://nuget.pkg.github.com/equinor/index.json\" /> <add key=\"nuget\" value=\"https://api.nuget.org/v3/index.json\" /> </packageSources> <packageSourceCredentials> <github> <add key=\"Username\" value=\"yourgithubuser\" /> <add key=\"ClearTextPassword\" value=xxxxxxx\" /> </github> </packageSourceCredentials> </configuration> pacakges.nuget needs to be moved into project file *.csproj as items instead NuGet.Build.Tasks.Pack need to be added as a pacakage to project need to download nuget.exe and use it to push generated .nupkg file then to publish put the following two commands in a publish.bat file: nuget setapikey xxxxxxxx -source \"github\" nuget push bin\\Debug\\*.nupkg -source \"github\" -SkipDuplicate pause check that the script concludes with \"Your package was pushed\" and no error messages in yellow or red. notice that you need to iterate the version number in your .csproj file every time you push a new version of the package. Warning Make sure that you do not check-in the nuget.config file you create, as it contains a secret token. Add nuget.config to your git ignore file."
  },
  "articles/dependencies.html": {
    "href": "articles/dependencies.html",
    "title": "Dependencies | TimeSeriesAnalysis reference documentation",
    "keywords": "Dependencies By principle this library will only add dependency to external libraries that are under permissive open-source licenses that allow commercial use ."
  },
  "articles/dynsim.html": {
    "href": "articles/dynsim.html",
    "title": "Dynamic simulation | TimeSeriesAnalysis reference documentation",
    "keywords": "Dynamic simulation The building block of the dynamic simulation are referred to as subprocesses where subsystem has has a scalar output Y a scalar disturbance input D (not directly manipulated) a scalar or vector of manipulated variables U . A standard PID-control loop can be implemented as a subsystem: or it can simply be a single-input or multiple input to single output process model without feedback: . The aim of the dynamic simulation is to support dynamic simulation of entire process sections. A process is in general any set of subprocesses The point of co-simulating set of subprocesses is that they may be connected for instance subprocesses connected in series subprocesses that are connected in process-feedback loops subprocesses that are controlled by PID-controllers, and combinations of the above"
  },
  "articles/ex_filtering.html": {
    "href": "articles/ex_filtering.html",
    "title": "Example 3 : Filtering | TimeSeriesAnalysis reference documentation",
    "keywords": "Example 3 : Filtering TimeSeriesAnalysis includes basic recursive filtering through the classes LowPass , HighPass and BandPass . To illustrate their capabilities, we create an artificial dataset which is made of two sinusoids sinus1 and sinus2 of different amplitudes and frequencies. Sinuses are implemented in a TimeSeriesCreator.Sinus . Now, we want to define a LowPass and HighPass filter that can separate out the high-frequency and low-frequency sinuses, and this is mainly a matter of choosing appropriate filter time constants of either filter. sinus1 has an period of 400 seconds, and thus goes from maximum to minimum amplitude in about ~200 seconds. Remembering that a first-order system by rule-of-thumb will take about 5 time-constants to implement 99% of a change, motivates a time constant of 200/5=40 seconds for the low-pass filter. By a similar logic,as sinus2 has a period of 25 seconds will go from maximum to minimum amplitude in about 12 seconds, thus motivating a filter time-constant of about ~3 seconds. The example code(runnable through the Test Explorer ): int timeBase_s = 1; int nStepsDuration = 2000; var sinus1 = TimeSeriesCreator.Sinus(10, 400, timeBase_s, nStepsDuration); var sinus2 = TimeSeriesCreator.Sinus( 1, 25, timeBase_s, nStepsDuration); var y_sim = (new Vec()).Add(sinus1,sinus2); var lpFilter = new LowPass(timeBase_s); var lpFiltered = lpFilter.Filter(y_sim, 40,1); var hpFilter = new HighPass(timeBase_s); var hpFiltered = hpFilter.Filter(y_sim, 3,1); Shared.EnablePlots(); Plot.FromList(new List<double[]> { y_sim, lpFiltered, hpFiltered }, new List<string> { \"y1=y\",\"y3=y_lowpass\",\"y3=y_highpass\" }, timeBase_s); Shared.DisablePlots(); Running the above code results in the below plot. In the top plot y that is two sinusoids overlayed. The below plot shows the high pass- and low pass-filtered versions of y and by the naked eye you can see that the filters have approximately managed to capture and separate out the two components. Note If you look closely, you will notice that y_highpass and y_lowpass sinusoids are delayed slightly in comparison to y , and also that the amplitudes of the two signals do not completely match the originals. This is due to the phase-shift and attenuation causes by the recursive filters, and is good to be aware of. It would be possible to get even smoother filtered signals by increasing the filter order from 1 to 2 for either filter, but the penalty would be increased phase-shift."
  },
  "articles/ex_filtering_python.html": {
    "href": "articles/ex_filtering_python.html",
    "title": "Example 3 : Filtering | TimeSeriesAnalysis reference documentation",
    "keywords": "Example 3 : Filtering import sys import clr import matplotlib.pyplot as plt assembly_path = r\"C:\\Appl\\PythonNETtest\\tsabuild\" sys.path.append(assembly_path) clr.AddReference(\"System\") clr.AddReference(\"System.Collections\") clr.AddReference(\"TimeSeriesAnalysis\") from TimeSeriesAnalysis import Vec, HighPass, LowPass from TimeSeriesAnalysis.Utility import TimeSeriesCreator timeBase_s = 1 nStepsDuration = 2000 sinus1 = TimeSeriesCreator.Sinus(10, 400, timeBase_s, nStepsDuration) sinus2 = TimeSeriesCreator.Sinus(1, 25, timeBase_s, nStepsDuration) y_sim = Vec().Add(sinus1, sinus2) lpFilter = LowPass(timeBase_s) lpFiltered = lpFilter.Filter(y_sim, 40.0, 1) hpFilter = HighPass(timeBase_s) hpFiltered = hpFilter.Filter(y_sim, 3.0, 1) fig, (ax1, ax2) = plt.subplots(2, 1, sharex=True) fig.suptitle(\"Example 3: Filtering\") # Plot generated dataset ax1.plot(list(y_sim), label=\"y_sim\", color=\"C0\") ax1.grid() ax1.legend(loc=\"upper right\") # Plot filtered dataset ax2.plot(list(lpFiltered), label=\"y_lowpass\", color=\"C1\") ax2.plot(list(hpFiltered), label=\"y_highpass\", color=\"C2\") ax2.grid() ax2.legend(loc=\"upper right\") plt.show()"
  },
  "articles/ex_hello_world.html": {
    "href": "articles/ex_hello_world.html",
    "title": "Example 1 : A simple \"hello world\" | TimeSeriesAnalysis reference documentation",
    "keywords": "Example 1 : A simple \"hello world\" Consider the example ex1_hello_world in Examples.cs : Shared.GetParserObj().EnableConsoleOutput(); int timeBase_s = 1; double filterTc_s = 10; double[] input = TimeSeriesCreator.Step(11, 60, 0, 1); LowPass lp = new LowPass(timeBase_s); var output = lp.Filter(input, filterTc_s); Shared.EnablePlots(); Plot.FromList(new List<double[]> { input, output}, new List<string> { \"y1=V1_input\",\"y1=V2_output\"}, timeBase_s, \"ex1_hello_world\", new DateTime(2020, 1, 1, 0, 0, 0)); Shared.DisablePlots(); Which when run should creates the following plot. The line int dT_s = 1; specifies the sampling time , i.e. the number of seconds between each sample in the time-series, and both LowPass and Plot require this information to correctly interpret the time-series. The time-constant of the filter, expressed in seconds, is set by the line double filterTc_s = 10; . The concept of the time-constant is very central in the domain of filters, control and dynamic systems. A time constant by a loose definition the time it takes for a linear system to reach 67% of its next steady-state. In this example, a step change in input at time t=10s, has reached output=0.67 sometime between t=[21s,22s]. Another useful rule of thumb, is that a a linear system has reached to within 99% of it new steady-state by five times the time constant , so in this case output exceeds 0.99 by t=59s . The next line creates an array of doubles that describes the input to the filter. By means of Vec.Concat and Vec.Fill , this input is initialized to first 11 samples of of the value 0, followed by 50 samples of the value one, a step-change , another important concept in the analysis of dynamic systems. double[] input = Vec<double>.Concat(Vec<double>.Fill(0, 11),Vec<double>.Fill(1, 50)); The input array is filtered by a low-pass filter and, the resulting output is the second time-series vector considered in this example. LowPass lp = new LowPass(dT_s); var output = lp.Filter(input, filterTc_s); The final action in this example is to plot the two time-series together: Plot.FromList(new List<double[]> { input, output}, new List<string> { \"y1=input\",\"y1=output\"}, dT_s, \"ex1_hello_world\", new DateTime(2020, 1, 1, 0, 0, 0)); The first input to this method is the variables to plot as a List of doubles: new List<double[]> { input, output} . The Plot.FromList command can in principle handle any number of inputs in this manner. The second variable determines what axes the variable is to be plotted on and what names to give each time-series trend in the legend . The prefix y1= indicates that the variable is to be plotted on the left axes of the first subplot. The string \"ex1_hello_world\" is displayed as the plot title, and new DateTime(2020, 1, 1, 0, 0, 0) determines that the plot is to start at midnight on on the first day of 2020. Note Try changing new List<string> { \"y1=input\",\"y1=output\"} to new List<string> { \"y1=input\",\"y2=output\"} and notice how output is now plotted on the right axes. Then try new List<string> { \"y1=input\",\"y3=output\"} and notice output is now plotted on a second subplot below the input . Note This is an example of transient data, as the variable output is in a transient state for a significant part of the dataset. Note Try dragging and zooming the plot, and using the scooter to reading the exact time and value off the output variable in each time step in the transient. Notice that the plot.ly library provides an interactive menu of to the top right of the screen. Note The path for this example is http://localhost/plotly/index.html#y1=V1_input;y1=V2_output;comment=ex1_hello_world;casename:ex1_hello_world If for whatever reason chrome does not start automatically on your computer, you can still open the plot manually if you have set up a local web server and paths correctly. Plot.FromList also outputs the url after the pound(\"#\"), so in this case changing the final line to var url = Plot.FromList... would set the variable url to y1=V1_input;y1=V2_output;comment=ex1_hello_world;casename:ex1_hello_world ."
  },
  "articles/ex_hello_world_python.html": {
    "href": "articles/ex_hello_world_python.html",
    "title": "Example 1 : A simple \"hello world\" | TimeSeriesAnalysis reference documentation",
    "keywords": "Example 1 : A simple \"hello world\" import sys import clr import matplotlib.pyplot as plt assembly_path = r\"C:\\Appl\\TimeSeriesAnalysisBuild\" sys.path.append(assembly_path) clr.AddReference(\"TimeSeriesAnalysis\") clr.AddReference(\"System.Collections\") clr.AddReference(\"System\") from TimeSeriesAnalysis import LowPass from TimeSeriesAnalysis.Utility import TimeSeriesCreator timeBase_s = 1 filterTc_s = 10.0 input = TimeSeriesCreator.Step(11, 60, 0, 1) lp = LowPass(timeBase_s) output = lp.Filter(input, filterTc_s) plt.plot(list(input), label=\"input\") plt.plot(list(output), label=\"output\") plt.grid() plt.legend(loc=\"right\") plt.title(\"Example 1: Hello World\") plt.show()"
  },
  "articles/ex_linreg.html": {
    "href": "articles/ex_linreg.html",
    "title": "Example 2 : Linear regression example | TimeSeriesAnalysis reference documentation",
    "keywords": "Example 2 : Linear regression example In this example, a synthetic dataset is created with the help of helper methods from TimeSeriesAnalysis , then Vec.Regress is used to do linear regression on the dataset to determine the parameters which best describe the relationship between inputs u1,u2,u3 and output y . Vec.Rand is used to add noise to the dataset, Vec.Mult is used to multiply vector and scalars The code: double[] true_gains = {1,2,3}; double true_bias = 5; double noiseAmplitude = 0.1; double[] u1 = TimeSeriesCreator.Step(11, 61, 0, 1); double[] u2 = TimeSeriesCreator.Step(31, 61, 1, 2); double[] u3 = TimeSeriesCreator.Step(21, 61, 1,-1); double[] y = new double[u1.Length]; double[] noise = (new Vec()).Multiply(Vec.Rand(u1.Length, -1,1,0),noiseAmplitude); for (int k = 0; k < u1.Length; k++) { y[k] = true_gains[0] * u1[k] + true_gains[1] * u2[k] + true_gains[2] * u3[k] + true_bias + noise[k]; } Plot.FromList(new List<double[]> { y, u1, u2, u3 }, new List<string> { \"y1=y1\", \"y3=u1\", \"y3=u2\", \"y3=u3\" }, 1); double[][] U = new double[][] { u1, u2, u3 }; var results = (new Vec()).RegressUnRegularized(y, U); TestContext.WriteLine(Vec.ToString(results.Param, 3)); TestContext.WriteLine(SignificantDigits.Format(results.Rsq, 3)); Shared.EnablePlots(); Plot.FromList(new List<double[]>() { y, results.Y_modelled }, new List<string>() { \"y1=y_meas\", \"y1=y_mod\" }, 1); Shared.DisablePlots(); The dataset : Note The above is an example of how to plot time-series on multiple y-axes, which is extremely useful to visualize input/output relationships. The resulting modeled y_modelled compared to y : The estimated parameters (rounded to three significant digits) returned are: [1.02;2.01;3.02;5.01] which is very close to the true values: [1;2;3;5] Note The returned vector of parameters will be slightly dependent on the seed number given to Vec.Rand() , but if the inputs U have enough excitation , the significance should be minimal. The returned Rsquare is 99,9 , indicating that in this case the model describes variations in the dataset very well, as should be expected in this case, as we have generated the dataset from a linear model that has the same structure as that used by Vec.Regress with the same inputs, and all three inputs vary enough and interdependently of each other."
  },
  "articles/ex_linreg_python.html": {
    "href": "articles/ex_linreg_python.html",
    "title": "Example 2 : Linear regression example | TimeSeriesAnalysis reference documentation",
    "keywords": "Example 2 : Linear regression example import sys import clr import matplotlib.pyplot as plt assembly_path = r\"C:\\Appl\\TimeSeriesAnalysisBuild\" sys.path.append(assembly_path) clr.AddReference(\"TimeSeriesAnalysis\") clr.AddReference(\"System.Collections\") from System import Array, DateTime, Double, String from System.Collections.Generic import List from TimeSeriesAnalysis import Vec from TimeSeriesAnalysis.Utility import Plot, TimeSeriesCreator true_gains = [1, 2, 3] true_bias = 5 noise_amplitude = 0.1 timeBase_s = 1 vec_sum = Vec().Add([1, 2], [3, 4]) u1 = TimeSeriesCreator.Step(11, 61, 0, 1) u2 = TimeSeriesCreator.Step(31, 61, 1, 2) u3 = TimeSeriesCreator.Step(21, 61, 1, -1) y = [] noise = Vec().Multiply(Vec.Rand(u1.Length, -1, 1, 0), noise_amplitude) for k in range(u1.Length): y.append( true_gains[0] * u1[k] + true_gains[1] * u2[k] + true_gains[2] * u3[k] + true_bias + noise[k] ) U = Array[Array[Double]]([u1, u2, u3]) results = Vec().Regress(y, U) fig, (ax1, ax2) = plt.subplots(2, 1, sharex=True) fig.suptitle(\"Example 2: Model fitting\") ax1.plot(list(y), label=\"y1\") ax1.plot(list(u1), label=\"u1\") ax1.plot(list(u2), label=\"u2\") ax1.plot(list(u3), label=\"u3\") ax1.grid() ax1.legend(loc=\"upper right\") ax1.set_title(\"Dataset\") ax2.plot(list(y), label=\"y_meas\") ax2.plot(list(results.Y_modelled), label=\"y_mod\") ax2.grid() ax2.legend(loc=\"upper right\") ax2.set_title(\"Resulting model\") plt.show()"
  },
  "articles/ex_pid.html": {
    "href": "articles/ex_pid.html",
    "title": "Example 5 : Simulating a single PID-controller | TimeSeriesAnalysis reference documentation",
    "keywords": "Example 5 : Simulating a single PID-controller In this example, a step disturbance influences a linear subprocess that is controlled by a PID-controller toward a constant setpoint of y=50 , like depicted in the below figure: SubProcessSimulator.CoSimulateProcessAndPID co-simulates a single PID-controller/processes combination such as this. UnitParameters modelParameters = new UnitParameters { TimeConstant_s = 10, LinearGains = new double[] { 1, 2 }, TimeDelay_s = 0, Bias = 5 }; UnitModel processModel = new UnitModel(modelParameters, \"SubProcess1\"); var pidParameters = new PidParameters() { Kp = 0.5, Ti_s = 20 }; var pidModel = new PidModel(pidParameters, \"PID1\"); var sim = new PlantSimulator( new List<ISimulatableModel> { processModel, pidModel }); sim.ConnectModels(processModel, pidModel); sim.ConnectModels(pidModel, processModel, (int)INDEX.FIRST); // create synthetic input data (normally you would get this data from the real-world) double timeBase_s = 1; int N = 500; var inputData = new TimeSeriesDataSet(); inputData.Add(sim.AddExternalSignal(pidModel, SignalType.Setpoint_Yset), TimeSeriesCreator.Constant(50, N)); inputData.Add(sim.AddExternalSignal(processModel, SignalType.External_U, (int)INDEX.SECOND), TimeSeriesCreator.Step(N / 2, N, 0, 1)); inputData.CreateTimestamps(timeBase_s); // simulate model over the var isOk = sim.Simulate(inputData, out var simData); // plot result Shared.EnablePlots(); Plot.FromList(new List<double[]> { simData.GetValues(processModel.GetID(),SignalType.Output_Y), inputData.GetValues(processModel.GetID(),SignalType.External_U,(int)INDEX.SECOND), simData.GetValues(pidModel.GetID(),SignalType.PID_U) }, new List<string> { \"y1=y_sim\", \"y2=u_external\", \"y3=u_pid\" }, timeBase_s, \"ex5_results\"); Shared.DisablePlots(); The resulting dynamic simulation: Note that the PID-controller is able to bring the subprocess back to the setpoint despite the disturbance. The initial fast response of the proportional term Kp is seen in the plot of u_pid , followed by the gradual influence of the integral term Ti_s , as is expected. Note SubProcessSimulator ensures that the PID/model combination starts in steady-state , so there is no bump or transient in the start of the dataset. Note Normally in industrial settings, PID-controllers are scaled, scaling information can be included by the inputting a PIDscaling to the PIDModelParameters object on initialization. Note CoSimulateProcessAndPID is only intended for simple single-input/single-output pid/model systems. For more general simulation, use ProcessSimulator class."
  },
  "articles/ex_pid_python.html": {
    "href": "articles/ex_pid_python.html",
    "title": "Example 5 : Simulating a single PID-controller | TimeSeriesAnalysis reference documentation",
    "keywords": "Example 5 : Simulating a single PID-controller import sys import clr import matplotlib.pyplot as plt assembly_path = r\"C:\\Appl\\TimeSeriesAnalysisBuild\" sys.path.append(assembly_path) clr.AddReference(\"System\") clr.AddReference(\"System.Collections\") clr.AddReference(\"TimeSeriesAnalysis\") from TimeSeriesAnalysis.Dynamic import ( UnitModel, UnitParameters, PidModel, PidParameters, UnitDataSet, UnitSimulator, ) from TimeSeriesAnalysis.Utility import TimeSeriesCreator timeBase_s = 1.0 N = 500 modelParameters = DefaultProcessModelParameters() modelParameters.WasAbleToIdentify = True modelParameters.TimeConstant_s = 10.0 modelParameters.ProcessGains = [1.0] modelParameters.TimeDelay = 0.0 modelParameters.Bias = 5.0 processModel = UnitModel(modelParameters, timeBase_s) pidParameters = PidParameters() pidParameters.Kp = 0.5 pidParameters.Ti_s = 20.0 pid = PidModel(pidParameters, timeBase_s) dataSet = UnitDataSet(timeBase_s, N) dataSet.D = TimeSeriesCreator.Step(N / 4, N, 0, 1) dataSet.Y_setpoint = TimeSeriesCreator.Step(0, N, 50, 50) simulator = UnitSimulator(processModel) isOK, dataSet = simulator.CoSimulateProcessAndPID(pid, dataSet) fig, (ax1, ax2) = plt.subplots(2, 1, sharex=True) fig.suptitle(\"Example 5: PID-controller\") ax12 = ax1.twinx() l1 = ax1.plot(list(dataSet.Y_sim), label=\"y_sim\", color=\"C0\")[0] l12 = ax12.plot(list(dataSet.D), label=\"disturbance\", color=\"Black\")[0] l2 = ax2.plot(list(dataSet.U_sim), label=\"u_pid\", color=\"C1\")[0] ax1.grid() ax2.grid() ax1.legend([l1, l12, l2], [\"y_sim\", \"disturbance\", \"u_pid\"]) plt.show()"
  },
  "articles/ex_processsim.html": {
    "href": "articles/ex_processsim.html",
    "title": "Example 6 :Larger-scale dynamic process simulation | TimeSeriesAnalysis reference documentation",
    "keywords": "Example 6 :Larger-scale dynamic process simulation The last example illustrated one very simple \"process\" consisting of a single PID-controller and a single-input/single-output process model, which could be simulated using CoSimulateProcessAndPID . Most systems of interest are more complicated, as each each model may have more than one input, and there may be several different PID-controllers and several subprocess-models interacting. Simulation of these kinds of systems is done using the class PlantSimulator . To keep things familiar this example extends on the previous. The subprocess-model is extended to two inputs , one external input signal is added in addition to the pid-signal input as shown below: The second output is given a gain of 2 by adding a second process gain to modelParamters : ProcessGains = new double[] { 1,2 }, Then the process simulator class is initialized, it needs a list of all models classes that will be simulated: var sim = new PlantSimulator (timeBase_s, new List<ISimulatableModel> { pidModel, processModel }); Then the two models pidModel and processModel need to be given two connections to make the feedback loop: sim.ConnectModels(processModel,pidModel); sim.ConnectModels(pidModel, processModel, (int)INDEX.FIRST); Notice that since processModel now has two inputs, we need to specify which input the pidModel connects to. If you like, you can use the enum INDEX to produce more readable code, or just specify the integer directly. Similarly to the previous example, a disturbance with a step of amplitude 1 is added 1/4th of the way through the dataset is added to the process model: sim.AddSignal(processModel, SignalType.Distubance_D,TimeSeriesCreator.Step(N/4,N,0,1)); and a constant setpoint of 50 is applied to the process model: sim.AddSignal(pidModel, SignalType.Setpoint_Yset, TimeSeriesCreator.Constant(50, N)); Note SubProcessSimulator.CoSimulateProcessAndPID co-simulates a single PID-controller/processes combination such as this, if you set the below signal to zero, for instance by setting the value TimeSeriesCreator.Step(0,N) then the simulation in this example will replicate the previous simulation in the previous example exactly . Then to extend the example, add a step change from 0 to 1 in the external input: sim.AddSignal(processModel, SignalType.External_U, TimeSeriesCreator.Step(N / 2, N, 0, 1), (int)INDEX.SECOND); making sure to apply this signal to the second input of the processModel . After all connections are made and signals added, then simulation is done using var isOk = sim.Simulate(out TimeSeriesDataSet simData); This method outputs an object of the type TimeSeriesDataSet that stores all the time-series of the simulation, both the signals added above and the simulated values, which can be accessed through convenient getters. For example the simulated output of processModel can be extracted from simData like this: simData.GetValues(processModel.GetID(),SignalType.Output_Y_sim) Notice how AddSignal applies a SignalType to each signal, this is then used internally in Simulate , but is also used to make it easier to extract and interpret signals after the simulation. The entire code: public void Ex6_feedback_loop_setpoint_and_disturbance_change() { // define two unit-model and a \"PlantSimulator\" where the two are connected UnitParameters modelParameters = new UnitParameters { TimeConstant_s = 10, LinearGains = new double[] { 1,2 }, TimeDelay_s = 0, Bias = 5 }; UnitModel processModel = new UnitModel(modelParameters, \"SubProcess1\"); var pidParameters = new PidParameters() { Kp = 0.5, Ti_s = 20 }; var pidModel = new PidModel(pidParameters, \"PID1\"); var sim = new PlantSimulator ( new List<ISimulatableModel> { processModel,pidModel }); sim.ConnectModels(processModel,pidModel); sim.ConnectModels(pidModel,processModel,(int)INDEX.FIRST); // create synthetic input data (normally you would get this data from the real-world) double timeBase_s = 1; int N = 500; var inputData = new TimeSeriesDataSet(); inputData.Add(sim.AddExternalSignal(processModel,SignalType.Disturbance_D), TimeSeriesCreator.Step(N/4,N,0,1)); inputData.Add(sim.AddExternalSignal(pidModel,SignalType.Setpoint_Yset), TimeSeriesCreator.Constant(50,N)); inputData.Add(sim.AddExternalSignal(processModel,SignalType.External_U, (int)INDEX.SECOND), TimeSeriesCreator.Step(N/2,N,0,1)); inputData.CreateTimestamps(timeBase_s); // simulate model over the var isOk = sim.Simulate(inputData,out var simData); // plot result Shared.EnablePlots(); Plot.FromList(new List<double[]> { simData.GetValues(processModel.GetID(),SignalType.Output_Y), inputData.GetValues(processModel.GetID(),SignalType.Disturbance_D), inputData.GetValues(processModel.GetID(),SignalType.External_U,(int)INDEX.SECOND), simData.GetValues(pidModel.GetID(),SignalType.PID_U) }, new List<string> { \"y1=y_sim\", \"y2=disturbance\", \"y2=u_external\",\"y3=u_pid\" }, timeBase_s, \"ex6_results\"); Shared.DisablePlots(); // optional: serialize //sim.Serialize(\"example6\"); //inputData.ToCsv(\"example6.csv\"); } The resulting dynamic simulation: The effect of the disturbance step entering 1/4th of the way through the dataset and then being rejected is seen, and is in fact exactly like in the previous example, but now a step change in the input is also seen half-way through the dataset. Note This example illustrates the work-flow that supports large-scale simulations, but the process example considered is still quite small. For examples of large-scale simulations, refer to the section on dynamic simulation."
  },
  "articles/ex_processsim_python.html": {
    "href": "articles/ex_processsim_python.html",
    "title": "Example 6 :Larger-scale dynamic process simulation | TimeSeriesAnalysis reference documentation",
    "keywords": "Example 6 :Larger-scale dynamic process simulation import sys import clr import matplotlib.pyplot as plt assembly_path = r\"C:\\Appl\\TimeSeriesAnalysisBuild\" sys.path.append(assembly_path) clr.AddReference(\"System\") clr.AddReference(\"System.Collections\") clr.AddReference(\"TimeSeriesAnalysis\") from System.Collections.Generic import List from TimeSeriesAnalysis.Dynamic import ( UnitModel, UnitParameters, ISimulatableModel, PidModel, PidParameters, PlantSimulator, SignalType, TimeSeriesDataSet, ) from TimeSeriesAnalysis.Utility import TimeSeriesCreator timeBase_s = 1.0 N = 500 modelParameters = DefaultProcessModelParameters() modelParameters.WasAbleToIdentify = True modelParameters.TimeConstant_s = 10.0 modelParameters.ProcessGains = [1.0, 2.0] modelParameters.TimeDelay = 0.0 modelParameters.Bias = 5.0 process = UnitModel(modelParameters, timeBase_s, ID=\"SubProcess1\") pidParameters = PidParameters() pidParameters.Kp = 0.5 pidParameters.Ti_s = 20.0 pid = PidModel(pidParameters, timeBase_s, ID=\"PID1\") sim_models = List[ISimulatableModel]() sim_models.Add(pid) sim_models.Add(process) plantSimulator = PlantSimulator(timeBase_s, sim_models) plantSimulator.ConnectModels(process, pid) plantSimulator.ConnectModels(pid, process, 0) plantSimulator.AddSignal(process, SignalType.Distubance_D, TimeSeriesCreator.Step(N/4, N, 0, 1)) plantSimulator.AddSignal(pid, SignalType.Setpoint_Yset, TimeSeriesCreator.Step(0, N, 50, 50)) plantSimulator.AddSignal(process, SignalType.External_U, TimeSeriesCreator.Step(N/2, N, 0, 1), 1) simData = TimeSeriesDataSet(int(timeBase_s)) isOK, simDataUpdated = plantSimulator.Simulate(simData) fig, (ax1, ax2) = plt.subplots(2, 1, sharex=True) fig.suptitle(\"Example 6: Larger-scale dynamic process simulation\") ax12 = ax1.twinx() l1 = ax1.plot(list(simDataUpdated.GetValues(process.GetID(), SignalType.Output_Y_sim)), label=\"y_sim\", color=\"C0\")[0] l121 = ax12.plot(list(simDataUpdated.GetValues(process.GetID(), SignalType.Distubance_D)), label=\"disturbance\", color=\"C1\")[0] l122 = ax12.plot(list(simDataUpdated.GetValues(process.GetID(), SignalType.External_U, 1)), label=\"u_external\", color=\"Black\")[0] l2 = ax2.plot(list(simDataUpdated.GetValues(pid.GetID(), SignalType.PID_U)), label=\"u_pid\", color=\"C2\")[0] ax1.grid() ax2.grid() ax1.legend([l1, l121, l122, l2], [\"y_sim\", \"disturbance\", \"u_external\", \"u_pid\"]) plt.show()"
  },
  "articles/ex_sysid.html": {
    "href": "articles/ex_sysid.html",
    "title": "Example 4 : Fitting a dynamic model to transient data | TimeSeriesAnalysis reference documentation",
    "keywords": "Example 4 : Fitting a dynamic model to transient data In this example, it is shown how to use the built-in dynamic identification algorithm to find a dynamic model to describe a measured time-series depending on multiple inputs. This example considers an \"open-loop\" subprocess as shown below: . A synthetic dataset with two inputs u1 and u2 is created using ProcessSimulator and the DefaultProcessModel (the output y_meas depends linearly on the two inputs), and noise is added to the data. The advantage of a synthetic dataset is that we know the true underlying parameters, which is very useful for testing and validating methods. In this case the \"true\" time-delay of 5 seconds, time-constant of 15 seconds and process gains {1,2} are chosen. The aim of this example is to see how closely the DefaultProcessModelIdentifier is able to estimate these values. The code to create the dataset, do the identification and create the plots is shown below: Shared.EnablePlots(); // create unit model and plant simulator var parameters = new UnitParameters { TimeConstant_s = 5, LinearGains = new double[] {1,2}, TimeDelay_s = 2, Bias = 5 }; var processModel = new UnitModel(parameters,\"processModel\"); var sim = new PlantSimulator(new List<ISimulatableModel> { processModel }); // create \"synthetic\" dataset and add the synthetic signals to plant simulator int timeBase_s = 1; double[] u1 = TimeSeriesCreator.Step(3, 100, 1, 2); double[] u2 = TimeSeriesCreator.Step(30, 100, 2, 1); // var inputData = new TimeSeriesDataSet(); inputData.Add(sim.AddExternalSignal(processModel, SignalType.External_U, (int)INDEX.FIRST), u1); inputData.Add(sim.AddExternalSignal(processModel, SignalType.External_U, (int)INDEX.SECOND), u2); inputData.CreateTimestamps(timeBase_s); // simulate the plant var isOK = sim.Simulate(inputData, out var simData); Assert.IsTrue(isOK); // create a \"unit data set\" and try to estimate the paramters of processModel from the data alone var unitDataSet = new UnitDataSet(); unitDataSet.U = Array2D<double>.CreateFromList(new List<double[]> { u1, u2 }); unitDataSet.CreateTimeStamps(timeBase_s); unitDataSet.Y_meas = simData.GetValues(processModel.GetID(), SignalType.Output_Y); // plot results of simulation // Plot.FromList(new List<double[]> { simData.GetValues(processModel.GetID(), SignalType.Output_Y), u1, u2 }, // new List<string> { \"y1=y_meas\", \"y3=u1\", \"y3=u2\" }, timeBase_s, \"ex4_data\"); var identifiedModel = UnitIdentifier.Identify(ref unitDataSet, new FittingSpecs()); // compare measured y and y from the identifiedModel. Plot.FromList(new List<double[]> { identifiedModel.GetFittedDataSet().Y_meas, identifiedModel.GetFittedDataSet().Y_sim }, new List<string> { \"y1=y_meas\", \"y1=y_sim\"}, timeBase_s, \"ex4_results\"); Console.WriteLine(identifiedModel.ToString()); // compare dynamic to static identification var regResults = (new Vec()).Regress(unitDataSet.Y_meas, unitDataSet.U); Plot.FromList(new List<double[]> { identifiedModel.GetFittedDataSet().Y_meas, identifiedModel.GetFittedDataSet().Y_sim,regResults.Y_modelled }, new List<string> { \"y1=y_meas\", \"y1=y_dynamic\",\"y1=y_static\" }, timeBase_s, \"ex4_static_vs_dynamic\"); Shared.DisablePlots(); Console.WriteLine(\"static model gains:\" + Vec.ToString(regResults.Gains,3)); The first plot shows the dataset, showing inputs u1 , u2 and output y : Notice of the time-delay and time-constant are clearly visible in this dataset . The resulting fit between model and dataset is shown below. The two time-series are virtually identical, except that the modeled output does not have any noise. The resulting console output gives more detail on the parameters found: DefaultProcessModel ------------------------- ABLE to identify TimeConstant : 14,1 sec TimeDelay : 5 sec ProcessGains : [0.958;1.96] ProcessCurvatures : null Bias : 8,87 u0 : [0.796;1.54] ------------------------- fitting objective : 0,3136 fitting R2: 84,27 fitting : no error or warnings Notice how the process gains [0.958;1.96] are fairly close to the true [1;2] , the time constant 14,1 sec is fairly close to the true 15 sec and the time delay is spot-on at 5 sec . R-squared (\"R2\") is ~84 out of 100 maximum, and this indicates a relatively good match of the model. R-squared could have been increased, and the even better estimates could have been obtained for a longer dataset, and by either including more steps in the data, or by fully allowing the first step response to reach steady-state before continuing with the second step. Reducing the noise also improves estimates and increases R2, but of course that is not an option in real-life. Comparsion: static versus dynamic model As an instructional example, the dynamic model above is compared to what is found by normal linear regression on this dataset. Linear regression is accomplished by Vec.Regress using the code below: // compare dynamic to static identification var regResults = Vec.Regress(dataSet.Y_meas, U); Plot.FromList(new List<double[]> { identifiedModel.FittedDataSet.Y_meas, identifiedModel.FittedDataSet.Y_sim,regResults.Y_modelled }, new List<string> { \"y1=y_meas\", \"y1=y_dynamic\",\"y1=y_static\" }, timeBase_s, \"ex4_static_vs_dynamic\"); Console.WriteLine(\"static model gains:\" + Vec.ToString(regResults.Gains,3)); The resulting plot, which compares the dynamic and static models is shown below: The model gains of the static model is [0.69;1.29] , which is not quite as close as the estimate [0.958;1.96] of the dynamic identification to the true values: [1;2] . Note This example illustrates an extremely important but slightly subtle lesson about the utility of dynamic identification: If your data is dynamic/transient, using dynamic identification will result in better estimates, also for stationary terms . This means that even if you are only interested in the static gains of a system, you would benefit from estimating gains using dynamic identification if your data has visible transients."
  },
  "articles/ex_sysid_python.html": {
    "href": "articles/ex_sysid_python.html",
    "title": "Example 4 : Fitting a dynamic model to transient data | TimeSeriesAnalysis reference documentation",
    "keywords": "Example 4 : Fitting a dynamic model to transient data import sys import clr import matplotlib.pyplot as plt assembly_path = r\"C:\\Appl\\PythonNETtest\\tsabuild\" sys.path.append(assembly_path) clr.AddReference(\"System\") clr.AddReference(\"System.Collections\") clr.AddReference(\"TimeSeriesAnalysis\") from System import Array, Double from System.Collections.Generic import List from TimeSeriesAnalysis import Array2D, Vec from TimeSeriesAnalysis.Dynamic import ( UnitModel, UnitIdentifier, UnitParameters, UnitDataSet, UnitSimulator, ) from TimeSeriesAnalysis.Utility import TimeSeriesCreator timeBase_s = 1.0 noiseAmplitude = 0.05 parameters = DefaultProcessModelParameters() parameters.WasAbleToIdentify = True parameters.TimeConstant_s = 15.0 parameters.ProcessGains = [1.0, 2.0] parameters.TimeDelay = 5.0 parameters.Bias = 5.0 model = UnitModel(parameters, timeBase_s, ID=\"not_named\") model.modelParameters = parameters model.timeBase_s = timeBase_s model.ID = \"not_named\" u1 = TimeSeriesCreator.Step(40, 200, 0, 1) u2 = TimeSeriesCreator.Step(105, 200, 2, 1) u_list = List[Array[Double]](range(2)) u_list.Add(u1) u_list.Add(u2) U = Array2D[Double].FromList(u_list) dataSet = UnitDataSet(timeBase_s, U) simulator = UnitSimulator(model) simulator.SimulateYmeas(dataSet, noiseAmplitude) modelId = UnitIdentifier() identifiedModel, subprosDataSet = modelId.Identify(dataSet) regResults = Vec().Regress(dataSet.Y_meas, U) # Plot generated dataset fig, (ax1, ax2, ax3, ax4) = plt.subplots(4, 1, sharex=True) ax1.plot(list(dataSet.Y_meas), label=\"y_sim\", color=\"Black\") ax1.grid() ax1.legend(loc=\"upper right\") ax1.set_title(\"ex4_data\") ax2.plot(list(u1), label=\"u1\") ax2.plot(list(u2), label=\"u2\") ax2.grid() ax2.legend(loc=\"upper right\") # Plot fitted model ax3.plot(list(identifiedModel.FittedDataSet.Y_meas), label=\"y_meas\") ax3.plot(list(identifiedModel.FittedDataSet.Y_sim), label=\"y_sim\") ax3.grid() ax3.legend(loc=\"upper right\") ax3.set_title(\"ex4_results\") # Compared to static model found by linear regression ax4.plot(list(identifiedModel.FittedDataSet.Y_meas), label=\"y_meas\") ax4.plot(list(identifiedModel.FittedDataSet.Y_sim), label=\"y_sim\") ax4.plot(list(regResults.Y_modelled), label=\"y_static\") ax4.grid() ax4.legend(loc=\"upper right\") ax4.set_title(\"ex4_static_vs_dynamic\") plt.suptitle(\"Example 4: Model fitting\") plt.show()"
  },
  "articles/example_linreg.html": {
    "href": "articles/example_linreg.html",
    "title": "Example : realistic linear regression | TimeSeriesAnalysis reference documentation",
    "keywords": "Example : realistic linear regression This example uses a ficticious csv-file example.csv, that has column headers \"Time\",\"Var1\",\"Var2\",\"Var3\",\"Var4,\"Var5\",Var6\",\"Var7\". \"Var1\" is to be modelled by Var2 - Var6 as regressors, while Var7 is to be multiplied to Var2 - Var6 . The data contains some instances of -9999 which indicates bad data, and this is removed in preprocessing. A low-pass filter is used to imitate a time-constant in the system by smoothing the model inputs. Only the data starting after a specific t0 is to be used in the regression, so a subset of the raw data in the csv-file is given to regression. This example illustrates that by using the TimeSeriesAnalysis package, the complexity of the code required to do practical exploratory time-series analysis is comparable to what is normally accomplished by parsed languages such as Matlab, R or Python. using System; using System.Collections.Generic; using System.Linq; using TimeSeriesAnalysis; namespace SubseaPALL { class run { public static void Main() { CSV.loadDataFromCSV(@\"C:\\Appl\\ex1\\Data\\example.csv\", out double[,] data, out string[] variableNames,out string[,] stringData); int tInd = Array.IndexOf(variableNames, \"Time\"); DateTime[] dateTimes = stringData.GetColumnParsedAsDateTime(tInd, \"yyyy-MM-dd HH:mm:ss\"); TimeSpan span = dateTimes[1].Subtract(dateTimes[0]); int dT_s = (int)span.TotalSeconds; int t0Ind = 9476;// first instance DateTime t0 = dateTimes.ElementAt(t0Ind); int yInd = Array.IndexOf(variableNames, \"var1\"); //V1: use choke openings as inputs int u1Ind, u2Ind, u3Ind, u4Ind, u5Ind; u1Ind = Array.IndexOf(variableNames, \"var2\"); u2Ind = Array.IndexOf(variableNames, \"var3\"); u3Ind = Array.IndexOf(variableNames, \"var4\"); u4Ind = Array.IndexOf(variableNames, \"var5\"); u5Ind = Array.IndexOf(variableNames, \"var6\"); int u6ind = Array.IndexOf(variableNames, \"var7\"); int[] uIndArray = new int[] { u1Ind, u2Ind, u3Ind, u4Ind, u5Ind }; double[] y_raw = data.GetColumn(yInd); double[,] u_raw = data.GetColumns(uIndArray) ; double[] u6_raw = data.GetColumn(u6ind); // clip out desired chunk of data double[] y = y_raw.GetRowsAfterIndex(t0Ind); double[,] u = u_raw.GetRowsAfterIndex(t0Ind); double[] z_topside = u6_raw.GetRowsAfterIndex(t0Ind); // preprocessing - remove bad values List<int> yIndToIgnoreRaw = new List<int>(); for (int colInd = 0; colInd < u.GetNColumns(); colInd++) { List<int> badValInd = Vec.FindValues(u.GetColumn(colInd), -9999, FindValues.NaN); yIndToIgnoreRaw.AddRange(badValInd); } yIndToIgnoreRaw.AddRange(Vec.FindValues(y, -9999, FindValues.NaN)); yIndToIgnoreRaw.AddRange(Vec.FindValues(z_topside, -9999, FindValues.NaN)); List<int> yIndToIgnore =(List<int>)yIndToIgnoreRaw.Distinct().ToList(); // do scaling, input trickery and then regress u = u.Transpose(); double[] y_plot = Vec.ReplaceIndWithValuesPrior(y, yIndToIgnore);// -9999 destroys plot double[] u1_plot = Vec.ReplaceIndWithValuesPrior(u.GetRow(0), yIndToIgnore);// -9999 destroys plot double[] u2_plot = Vec.ReplaceIndWithValuesPrior(u.GetRow(1), yIndToIgnore);// -9999 destroys plot double[] u3_plot = Vec.ReplaceIndWithValuesPrior(u.GetRow(2), yIndToIgnore);// -9999 destroys plot double[] u4_plot = Vec.ReplaceIndWithValuesPrior(u.GetRow(3), yIndToIgnore);// -9999 destroys plot double[] u5_plot = Vec.ReplaceIndWithValuesPrior(u.GetRow(4), yIndToIgnore);// -9999 destroys plot double[] u6_plot = Vec.ReplaceIndWithValuesPrior(z_topside, yIndToIgnore);// -9999 destroys plot // temperature does not change much based on changes in the upper half of the range valve-opening rate, as flow rates also // do not change that much (valve flow vs. choke opening is nonlinear) double z_Max = 60; double z_MaxTopside = 80; u = Matrix.ReplaceRow(u,0, Vec.Min(u.GetRow(0), z_Max)); u = Matrix.ReplaceRow(u,1, Vec.Min(u.GetRow(1), z_Max)); u = Matrix.ReplaceRow(u,2, Vec.Min(u.GetRow(2), z_Max)); u = Matrix.ReplaceRow(u,3, Vec.Min(u.GetRow(3), z_Max)); u = Matrix.ReplaceRow(u,4, Vec.Min(u.GetRow(4), z_Max)); u = Matrix.Mult(u, 0.01); z_topside = Vec.Mult(Vec.Min(z_topside, z_MaxTopside), 0.01); z_topside = Vec.Mult(z_topside, 0.01); u = Matrix.Mult(u, z_topside); // lowpass filtering of inputs double TimeConstant_s = 1800;//73.24 LowPass filter = new LowPass(TimeConstant_s); u = Matrix.ReplaceRow(u, 0, filter.Filter(u.GetRow(0), TimeConstant_s)); u = Matrix.ReplaceRow(u, 1, filter.Filter(u.GetRow(1), TimeConstant_s)); u = Matrix.ReplaceRow(u, 2, filter.Filter(u.GetRow(2), TimeConstant_s)); u = Matrix.ReplaceRow(u, 3, filter.Filter(u.GetRow(3), TimeConstant_s)); u = Matrix.ReplaceRow(u, 4, filter.Filter(u.GetRow(4), TimeConstant_s)); if (u == null) { Console.WriteLine(\"u is null, something went wrong\"); return; } var uJaggedArray = u.Convert2DtoJagged(); double[] parameters = Vec.Regress(y, uJaggedArray, yIndToIgnore.ToArray(), out _, out double[] y_mod,out double Rsq); double[] e = Vec.Sub(y_plot, y_mod); //present results if (y_mod == null) { Console.WriteLine(\"something went wrong, regress returned null\"); } else { Plot.Six(u1_plot, u2_plot, u3_plot, u4_plot, u5_plot,u6_plot, dT_s,\"z_D1\", \"z_D2\", \"z_D3\", \"z_D4\",\"z_D5\",\"z_topside\",true,false,null,t0); Plot.Two(y_plot, y_mod, dT_s, \"T_Dtopside(meas)\", \"T_Dtopside(mod)\",true,false,\"Rsq\"+Rsq.ToString(\"#.##\"),t0); Plot.One(e,dT_s,\"avvik\",null, t0); } } } }"
  },
  "articles/examples.html": {
    "href": "articles/examples.html",
    "title": "Code examples | TimeSeriesAnalysis reference documentation",
    "keywords": "Code examples All examples are implemented in Examples.cs . Upon building the project, you can run and examine the examples from the Test Explorer as you would any unit test by right click>Run Test ."
  },
  "articles/getting_started.html": {
    "href": "articles/getting_started.html",
    "title": "| TimeSeriesAnalysis reference documentation",
    "keywords": "Perhaps the easiest way to get started is to work in C# in Visual Studio: find the package on NuGet and download into your application import the name spaces : import TimeSeriesAnalysis start calling methods from the API. To run, other dependencies like Accord.NET are downloaded automatically by NuGet. Note that you can also download pre-built release which includes all the files you need, these can then be loaded up from Matlab or Python if that is your preference,as is explained in separate articles."
  },
  "articles/glossary.html": {
    "href": "articles/glossary.html",
    "title": "Glossary | TimeSeriesAnalysis reference documentation",
    "keywords": "Glossary Grey-box models \"Such a model set, whose parameters are basically viewed as vehicles for adjusting the fit to the data and do not reflect phyiscal considerations in the system, is called black box. Model sets with adjustable paramters with physical interpretation may, accordingly, be called gray boxes\" . (*Lennart Ljung, System Identificaton,theory for the user 2nd ed.) Time base Time-base in this context is another expression for sampling time which is the inverse of the sampling rate . So a sampling frequency of 10 Hz , would mean a sampling time/time base of 0.1s . Linear versus non-linear systems A linear system refers to a system that can be described by a linear differential equation, i.e. its states are linear in the dependent variables u . A nonlinear is system is any system that is not linear. Example: If x is the system state, then dx/dt = b * u is linear while x = b * u + c * u^2 is non-linear State of a system So the state of a system is the values of a set of variables that together define the current condition of the system uniequly. Often in system identfication the system state is referred to as x . Note that the output y is not neccesarily the same as the state. If the system is described by the differential equation, then the state x is the solution of this equation set. Steady-state versus transient Steady-state in a differential equation is the condition that the differential terms are zero, so that the system remains at rest. Static versus dynamic A model is termed static if any changes in inputs fully propagete immediately the outputs. So a static model is a model with no transients , and thus has no time-constant or time-delay terms. Working point and local models Any nonlinear system can be approximated as linear around a working point . So a local model in this context is a model that is intended to mainly approximate the actual system close to a given value u0 of the manipulated variables. Depending on the degree of non-linearity, the working range aroundt the working point that the model is useful for will vary. Tuning dataset versus validation dataset The tuning dataset , also referred to as the fitted dataset is the actual set of data that the model was fitted against. It is common practice in system identifiation to evaluate models not on the fit to the tuning set but on a fresh set of data , and this fresh data set used for evaluation is referred to as the validation dataset ."
  },
  "articles/index.html": {
    "href": "articles/index.html",
    "title": "TimeSeriesAnalysis | TimeSeriesAnalysis reference documentation",
    "keywords": "TimeSeriesAnalysis Source code https://github.com/equinor/timeseriesanalysis Releases https://github.com/equinor/TimeSeriesAnalysis/releases Documentation https://equinor.github.io/TimeSeriesAnalysis At a glance An open-source library of methods to identify,simulate and control industrial process plants, built on .NET Standard 2.0. The most significant contributions of the library are: am (open-loop) unit model and -identification algorithm that can describe both stationary and dynamic, linear and weakly nonlinear processes, and an algorithm to automatically choose the best model for a given input. a closed-loop identification algorithm that can estimate processes and disturbances from closed loop time-series. a PID-controller identification algorithm that can estimate gain and integral time by observing the output of a controller., a state-of-the-art advanced industrial PID-controller model implemented as a unit-model , and a dynamic plant simulator that is able to simulate connected combinations of unit models (\"plant models\"), each unit-model may be an identified PID-controller or an identified model. The main value proposition of the library is that it collects many years combined industrial and academic experience into one a package of tools that are all integrated/compatible with each other , it aims to acts as a reference implementation for vendors and researchers, it aims to be suitable for industrial implementation , code-base should be robust and well-tested, all edge-cases should be handled gracefully, and it opens the possibility to automate modeling and simulation of plant models. This enables advanced analytics or data-mining , which by most definitions are automated or semi-automated. Note The primary use-case for this library is for industrial automation , thus the emphasis on modeling PID-controllers and on time-series models that are able to describe the dynamics of typical industrial plants. The methods themselves are general and it is feasible to apply these methods to other types of datasets. The intention is to be able to easily code \"plant simulators\" by connecting \"grey box\" unit models. The intention is to make the process of identifying unit models, connecting models and simulating as easy as possible, and to automate wherever possible. Because the code is written as a .NET Standard class library, it is equally possible to run the library in the cloud on a Linux instance, to call the library for development on your desktop through Python or Matlab, or to integrate the library into \"edge\" computing in industrial control. Motivation - \"grey-box\" rather than \"black box\" Note A grey-box model is built to have parameters fitted to time-series data (like black-box models), but at the same time each parameter has an intuitive phyiscal interpretation (like a white-box model). Grey-box models are a \"best of both worlds\" compromise between \"white box\" models (where paramters are set using prior knowlege) and \"black-box\" models (where parameters are determiend by fitting and have no direct physical interpretation.) The aim is to make models that can represent large and complex plants, yet where the meaning of each parameter in each unit models is still intuitive, representing some intuitive physical property like for instance \"gain\" , \"time delay\" or \"time constant\" . Grey-box models have two very interesting properties: parameters of automatically identified models can be inspected by users to gain insight , and also users can add insight by changing parameters where needed. Grey-box modeling will have an advantage in cases where it is fitted to real-world data that has some information but perhaps has some information missing because some inputs do not vary enough independelty. This situation is the norm when attempting to use real-world time-series data sets rather than using data of designed experiments. Since parameters have a phyiscal interpretation, it is possible to fill in gaps in the model using a priori knowledge. Advanced analytics The above concepts are related to the term \"advanced analytics\". Advanced analytics is defined as : \" the autonomous or semi-autonomous examination of data or content using sophisticated techniques and tools, typically beyond those of traditional business intelligence (BI), to discover deeper insights, make predictions, or generate recommendations.\" Note that advanced analytics by definition requires automated or semi-automated analysis to generate recommendations, thus it needs to be \"data-driven\" . A success criterion for any data driven method will be its reliability , so that despite little manual configuration and assistance, methods should consistently provide dependable high-quality output. To create reliable and dependable software, complete control of the entire software stack is advantageous as: solutions are easier to integrate and deploy (be it on-premise, on your local computer, integrated into vendor software, or running in the cloud), and the quality, behavior and performance of each component can be inspected and, if need be, improved,i.e. there are no code \"black boxes\". An advantage of an open software stack is that it can create industrial collaboration, and industrial/academic collaboration that can hopefully raise the quality of software by pooling resources."
  },
  "articles/intro.html": {
    "href": "articles/intro.html",
    "title": "Introduction | TimeSeriesAnalysis reference documentation",
    "keywords": "Introduction In this folder you will find detailed worked-though articles including code samples."
  },
  "articles/license.html": {
    "href": "articles/license.html",
    "title": "| TimeSeriesAnalysis reference documentation",
    "keywords": "Apache License Version 2.0, January 2004 http://www.apache.org/licenses/ TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION Definitions. \"License\" shall mean the terms and conditions for use, reproduction, and distribution as defined by Sections 1 through 9 of this document. \"Licensor\" shall mean the copyright owner or entity authorized by the copyright owner that is granting the License. \"Legal Entity\" shall mean the union of the acting entity and all other entities that control, are controlled by, or are under common control with that entity. For the purposes of this definition, \"control\" means (i) the power, direct or indirect, to cause the direction or management of such entity, whether by contract or otherwise, or (ii) ownership of fifty percent (50%) or more of the outstanding shares, or (iii) beneficial ownership of such entity. \"You\" (or \"Your\") shall mean an individual or Legal Entity exercising permissions granted by this License. \"Source\" form shall mean the preferred form for making modifications, including but not limited to software source code, documentation source, and configuration files. \"Object\" form shall mean any form resulting from mechanical transformation or translation of a Source form, including but not limited to compiled object code, generated documentation, and conversions to other media types. \"Work\" shall mean the work of authorship, whether in Source or Object form, made available under the License, as indicated by a copyright notice that is included in or attached to the work (an example is provided in the Appendix below). \"Derivative Works\" shall mean any work, whether in Source or Object form, that is based on (or derived from) the Work and for which the editorial revisions, annotations, elaborations, or other modifications represent, as a whole, an original work of authorship. For the purposes of this License, Derivative Works shall not include works that remain separable from, or merely link (or bind by name) to the interfaces of, the Work and Derivative Works thereof. \"Contribution\" shall mean any work of authorship, including the original version of the Work and any modifications or additions to that Work or Derivative Works thereof, that is intentionally submitted to Licensor for inclusion in the Work by the copyright owner or by an individual or Legal Entity authorized to submit on behalf of the copyright owner. For the purposes of this definition, \"submitted\" means any form of electronic, verbal, or written communication sent to the Licensor or its representatives, including but not limited to communication on electronic mailing lists, source code control systems, and issue tracking systems that are managed by, or on behalf of, the Licensor for the purpose of discussing and improving the Work, but excluding communication that is conspicuously marked or otherwise designated in writing by the copyright owner as \"Not a Contribution.\" \"Contributor\" shall mean Licensor and any individual or Legal Entity on behalf of whom a Contribution has been received by Licensor and subsequently incorporated within the Work. Grant of Copyright License. Subject to the terms and conditions of this License, each Contributor hereby grants to You a perpetual, worldwide, non-exclusive, no-charge, royalty-free, irrevocable copyright license to reproduce, prepare Derivative Works of, publicly display, publicly perform, sublicense, and distribute the Work and such Derivative Works in Source or Object form. Grant of Patent License. Subject to the terms and conditions of this License, each Contributor hereby grants to You a perpetual, worldwide, non-exclusive, no-charge, royalty-free, irrevocable (except as stated in this section) patent license to make, have made, use, offer to sell, sell, import, and otherwise transfer the Work, where such license applies only to those patent claims licensable by such Contributor that are necessarily infringed by their Contribution(s) alone or by combination of their Contribution(s) with the Work to which such Contribution(s) was submitted. If You institute patent litigation against any entity (including a cross-claim or counterclaim in a lawsuit) alleging that the Work or a Contribution incorporated within the Work constitutes direct or contributory patent infringement, then any patent licenses granted to You under this License for that Work shall terminate as of the date such litigation is filed. Redistribution. You may reproduce and distribute copies of the Work or Derivative Works thereof in any medium, with or without modifications, and in Source or Object form, provided that You meet the following conditions: (a) You must give any other recipients of the Work or Derivative Works a copy of this License; and (b) You must cause any modified files to carry prominent notices stating that You changed the files; and (c) You must retain, in the Source form of any Derivative Works that You distribute, all copyright, patent, trademark, and attribution notices from the Source form of the Work, excluding those notices that do not pertain to any part of the Derivative Works; and (d) If the Work includes a \"NOTICE\" text file as part of its distribution, then any Derivative Works that You distribute must include a readable copy of the attribution notices contained within such NOTICE file, excluding those notices that do not pertain to any part of the Derivative Works, in at least one of the following places: within a NOTICE text file distributed as part of the Derivative Works; within the Source form or documentation, if provided along with the Derivative Works; or, within a display generated by the Derivative Works, if and wherever such third-party notices normally appear. The contents of the NOTICE file are for informational purposes only and do not modify the License. You may add Your own attribution notices within Derivative Works that You distribute, alongside or as an addendum to the NOTICE text from the Work, provided that such additional attribution notices cannot be construed as modifying the License. You may add Your own copyright statement to Your modifications and may provide additional or different license terms and conditions for use, reproduction, or distribution of Your modifications, or for any such Derivative Works as a whole, provided Your use, reproduction, and distribution of the Work otherwise complies with the conditions stated in this License. Submission of Contributions. Unless You explicitly state otherwise, any Contribution intentionally submitted for inclusion in the Work by You to the Licensor shall be under the terms and conditions of this License, without any additional terms or conditions. Notwithstanding the above, nothing herein shall supersede or modify the terms of any separate license agreement you may have executed with Licensor regarding such Contributions. Trademarks. This License does not grant permission to use the trade names, trademarks, service marks, or product names of the Licensor, except as required for reasonable and customary use in describing the origin of the Work and reproducing the content of the NOTICE file. Disclaimer of Warranty. Unless required by applicable law or agreed to in writing, Licensor provides the Work (and each Contributor provides its Contributions) on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied, including, without limitation, any warranties or conditions of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A PARTICULAR PURPOSE. You are solely responsible for determining the appropriateness of using or redistributing the Work and assume any risks associated with Your exercise of permissions under this License. Limitation of Liability. In no event and under no legal theory, whether in tort (including negligence), contract, or otherwise, unless required by applicable law (such as deliberate and grossly negligent acts) or agreed to in writing, shall any Contributor be liable to You for damages, including any direct, indirect, special, incidental, or consequential damages of any character arising as a result of this License or out of the use or inability to use the Work (including but not limited to damages for loss of goodwill, work stoppage, computer failure or malfunction, or any and all other commercial damages or losses), even if such Contributor has been advised of the possibility of such damages. Accepting Warranty or Additional Liability. While redistributing the Work or Derivative Works thereof, You may choose to offer, and charge a fee for, acceptance of support, warranty, indemnity, or other liability obligations and/or rights consistent with this License. However, in accepting such obligations, You may act only on Your own behalf and on Your sole responsibility, not on behalf of any other Contributor, and only if You agree to indemnify, defend, and hold each Contributor harmless for any liability incurred by, or claims asserted against, such Contributor by reason of your accepting any such warranty or additional liability. END OF TERMS AND CONDITIONS APPENDIX: How to apply the Apache License to your work. To apply the Apache License to your work, attach the following boilerplate notice, with the fields enclosed by brackets \"[]\" replaced with your own identifying information. (Don't include the brackets!) The text should be enclosed in the appropriate comment syntax for the file format. We also recommend that a file or class name and description of purpose be included on the same \"printed page\" as the copyright notice for easier identification within third-party archives. Copyright 2023 Equinor Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License."
  },
  "articles/limitations.html": {
    "href": "articles/limitations.html",
    "title": "List of known limitations | TimeSeriesAnalysis reference documentation",
    "keywords": "List of known limitations This is a working list of currenlty known limitations of capability. The aim is generally to address these in further work, if possible. Plant Simulator PlantSimulator initalizes systems only to steady-state, and all PID-loops are currently initalized to the value of the setpoint. This has implication when simulating system that have input additive disturbances on the output. simulations will currently likely fail if more than one select controller is present PlantSimulator currently always consider e[i-1] when simulating PID-controllers (unlike UnitSimulator), this should be configurable, but requires a change to the DetermineCalculationOrderOfModels() PID-Controller the tracking functionality of the included PID-controller needs work(reformulation?), the example of tracking is unfinished as a result, split range has not been verified in a test, the uncertainty of estimated PID-parameters is currently not calculated or stored, but it is possible to do so, Disturbance (closed-loop) estimaton the disturbance estimation makes assumptions about u[0] being at steady-state and formulates model related to this u0=u[0] the current closed-loop unit identifier cannot find dynamic models, for dynamic models some of the transients thus bleed into the estimated disturbance disturbance estimation is only available currently for systems that the UnitSimulator can simulate, so not for advanced control schemes."
  },
  "articles/matlab.html": {
    "href": "articles/matlab.html",
    "title": "Loading this library from MatLab | TimeSeriesAnalysis reference documentation",
    "keywords": "Loading this library from MatLab MatLab supports importing .NET assemblies(*.dlls) through the built-in NET.addAssembly() command. Note Once an assembly is loaded in MatLab , it cannot be unloaded except by restarting the program. Note Not all .NET features are supported in MatLab a list of limitiations is given in https://se.mathworks.com/help/matlab/matlab_external/limitations-to-net-support.html Step-by-step: Take a complete build of TimeSeriesAnalyis.dll and accompanying assemblies such as Accord.NET *.dlls and copy into your MatLab working directory such as C:\\Appl\\OneDrive\\Documents\\MATLAB (either build yourself or copy pre-built zip-file from https://github.com/equinor/TimeSeriesAnalysis/releases/ and unzip.) load the assembly with NET.addAssembly() : import the methods of the .NET assembly using the MatLab command import you can now directly call methods in the \"TimeSeriesAnalysis\" namespace (consult the API reference) A simple \"hello-world\" example: assembly = NET.addAssembly('C:\\Appl\\OneDrive\\Documents\\MATLAB\\TimeSeriesAnalysis.dll') import TimeSeriesAnalysis.* results = Vec.Add([1 2],[3 4]) will give as a result a Double[] where >> result(1) ans = 4 >> result(2) ans = 6 Calling >> assembly.Classes reveals the classes that Matlab has loaded: ans = 301 cell array {'TimeSeriesAnalysis.RegressionResults' } {'TimeSeriesAnalysis.Array2D' } {'TimeSeriesAnalysis.Array2DExtensionMethods' } {'TimeSeriesAnalysis.Matrix' } {'TimeSeriesAnalysis.Vec' } {'TimeSeriesAnalysis.VecExtensionMethods' } {'TimeSeriesAnalysis.Utility.CSV' } {'TimeSeriesAnalysis.Utility.StringToFileWriter' } {'TimeSeriesAnalysis.Utility.TimeSeriesCreator' } {'TimeSeriesAnalysis.Utility.UnixTime' } {'TimeSeriesAnalysis.Utility.Plot' } {'TimeSeriesAnalysis.Utility.Plot4Test' } {'TimeSeriesAnalysis.Utility.ParserFeedback' } {'TimeSeriesAnalysis.Utility.SignificantDigits' } {'TimeSeriesAnalysis.Dynamic.DefaultProcessModel' } {'TimeSeriesAnalysis.Dynamic.DefaultProcessModelIdentifier'} {'TimeSeriesAnalysis.Dynamic.DefaultProcessModelParameters'} {'TimeSeriesAnalysis.Dynamic.BandPass' } {'TimeSeriesAnalysis.Dynamic.HighPass' } {'TimeSeriesAnalysis.Dynamic.LowPass' } {'TimeSeriesAnalysis.Dynamic.PIDModel' } {'TimeSeriesAnalysis.Dynamic.PIDModelParameters' } {'TimeSeriesAnalysis.Dynamic.PIDAntiSurgeParams' } {'TimeSeriesAnalysis.Dynamic.PIDcontroller' } {'TimeSeriesAnalysis.Dynamic.PIDgainScheduling' } {'TimeSeriesAnalysis.Dynamic.PIDscaling' } {'TimeSeriesAnalysis.Dynamic.PIDtuning' } {'TimeSeriesAnalysis.Dynamic.SubProcessDataSet' } {'TimeSeriesAnalysis.Dynamic.TimeDelay' } {'TimeSeriesAnalysis.Dynamic.MovingAvg' } It is possible to load classes form namesapces like TimeSeriesAnalysis.Utility and TimeSeriesAnalysis.Dynamic as well, for instance: >> import TimeSeriesAnalysis.* >> import TimeSeriesAnalysis.Utility.* >> TimeSeriesCreator.Step(25,50,0,1) returns a Double[] of length 50 ."
  },
  "articles/multiprocesssim.html": {
    "href": "articles/multiprocesssim.html",
    "title": "ProcessSimulator | TimeSeriesAnalysis reference documentation",
    "keywords": "ProcessSimulator Simulating multiple processes together is orchestrated by the class ProcessSimulator ."
  },
  "articles/nuget.html": {
    "href": "articles/nuget.html",
    "title": "| TimeSeriesAnalysis reference documentation",
    "keywords": ""
  },
  "articles/nuget_setup.html": {
    "href": "articles/nuget_setup.html",
    "title": "Setting up NuGet | TimeSeriesAnalysis reference documentation",
    "keywords": "Setting up NuGet TimeSeriesAnalysis uses NuGet to retrieve pre-compiled open-source packages on which it is based. NuGet can be set up in several different ways. TimeSeriesAnalysis uses the PackageReference type of configuration, in which NuGet configuration is stored in TimeSeriesAnalysis.csprocj . Note NuGet will not create a local packages subfolder upon a NuGet restore .Instead it creates a global package folder on your computer in the folder %userprofile%\\.nuget\\packages . In some cases it is insightful to examine the contents of this folder if you are having any NuGet issues. In Visual Studio , examine the menu TOOLS>NuGet Package Manager>Package Manager Settings . You should have the following selected: Allow NuGet to download missing packages (should be Checked ) Automatically check for missing packages during build in Visual Studio (should be Checked ) Default package management format should be PacakgeReference Note If you are having issues with NuGet, you can try pressing Clear All NuGet Cache(s) in the above dialog box. Solution Explorer>Solution TimeSeries analysis(right click)>Restore NuGet packages should run with zero errors (observe the Output>Package Manger for possible error) messages."
  },
  "articles/other_languages.html": {
    "href": "articles/other_languages.html",
    "title": "Loading this library from MatLab or Python | TimeSeriesAnalysis reference documentation",
    "keywords": "Loading this library from MatLab or Python Python There is a package for Python called Python.Net that allows you to access the methods in this library. MatLab MatLab supports importing .NET assemblies(*.dlls) through the built-in NET.addAssembly() command. Note Once an assembly is loaded in MatLab , it cannot be unloaded except by restarting the program. Note Not all .NET features are supported in MatLab a list of limitiations is given in https://se.mathworks.com/help/matlab/matlab_external/limitations-to-net-support.html Step-by-step: Take a complete build of TimeSeriesAnalyis.dll and accompanying assemblies such as Accord.NET *.dlls and copy into your MatLab working directory such as C:\\Appl\\OneDrive\\Documents\\MATLAB (either build yourself or copy pre-built zip-file from https://github.com/equinor/TimeSeriesAnalysis/releases/ and unzip.) load the assembly with NET.addAssembly() : import the methods of the .NET assembly using the MatLab command import you can now directly call methods in the \"TimeSeriesAnalysis\" namespace (consult the API reference) A simple \"hello-world\" example: assembly = NET.addAssembly('C:\\Appl\\OneDrive\\Documents\\MATLAB\\TimeSeriesAnalysis.dll') import TimeSeriesAnalysis.* results = Vec.Add([1 2],[3 4]) will give as a result a Double[] where >> result(1) ans = 4 >> result(2) ans = 6 Calling >> assembly.Classes reveals the classes that Matlab has loaded: ans = 301 cell array {'TimeSeriesAnalysis.RegressionResults' } {'TimeSeriesAnalysis.Array2D' } {'TimeSeriesAnalysis.Array2DExtensionMethods' } {'TimeSeriesAnalysis.Matrix' } {'TimeSeriesAnalysis.Vec' } {'TimeSeriesAnalysis.VecExtensionMethods' } {'TimeSeriesAnalysis.Utility.CSV' } {'TimeSeriesAnalysis.Utility.StringToFileWriter' } {'TimeSeriesAnalysis.Utility.TimeSeriesCreator' } {'TimeSeriesAnalysis.Utility.UnixTime' } {'TimeSeriesAnalysis.Utility.Plot' } {'TimeSeriesAnalysis.Utility.Plot4Test' } {'TimeSeriesAnalysis.Utility.ParserFeedback' } {'TimeSeriesAnalysis.Utility.SignificantDigits' } {'TimeSeriesAnalysis.Dynamic.DefaultProcessModel' } {'TimeSeriesAnalysis.Dynamic.DefaultProcessModelIdentifier'} {'TimeSeriesAnalysis.Dynamic.DefaultProcessModelParameters'} {'TimeSeriesAnalysis.Dynamic.BandPass' } {'TimeSeriesAnalysis.Dynamic.HighPass' } {'TimeSeriesAnalysis.Dynamic.LowPass' } {'TimeSeriesAnalysis.Dynamic.PIDModel' } {'TimeSeriesAnalysis.Dynamic.PIDModelParameters' } {'TimeSeriesAnalysis.Dynamic.PIDAntiSurgeParams' } {'TimeSeriesAnalysis.Dynamic.PIDcontroller' } {'TimeSeriesAnalysis.Dynamic.PIDgainScheduling' } {'TimeSeriesAnalysis.Dynamic.PIDscaling' } {'TimeSeriesAnalysis.Dynamic.PIDtuning' } {'TimeSeriesAnalysis.Dynamic.SubProcessDataSet' } {'TimeSeriesAnalysis.Dynamic.TimeDelay' } {'TimeSeriesAnalysis.Dynamic.MovingAvg' } It is possible to load classes form namesapces like TimeSeriesAnalysis.Utility and TimeSeriesAnalysis.Dynamic as well, for instance: >> import TimeSeriesAnalysis.* >> import TimeSeriesAnalysis.Utility.* >> TimeSeriesCreator.Step(25,50,0,1) returns a Double[] of length 50 ."
  },
  "articles/pid_cascade.html": {
    "href": "articles/pid_cascade.html",
    "title": "Cascade control | TimeSeriesAnalysis reference documentation",
    "keywords": "Cascade control This example considers a cascade control scheme consisting of a rapid inner loop( process1 and pid ) and a slower outer loop( process2 and pid2 ), both being subjected to simulated disturbances. (In a real-world case, the inner loop of a cascade is often a (rapid) valve flow-rate controller, while the outer loop could for instance be a level that depends on the flow rate.) A sinusoidal disturbance D1 is introduced on process1, wheras a step disturbance is introduced halfway through the simulation in D2 , and the aim is for the cascade controllers to reject both disturbances as well as possible. The code to implement the controllers: var processParameters1 = new UnitParameters { TimeConstant_s = 2,//rapid LinearGains = new double[] { 1.1 }, U0 = new double[] { 50 }, TimeDelay_s = 0, Bias = 50 }; var processParameters2 = new UnitParameters { TimeConstant_s = 30,//slow LinearGains = new double[] { 1 }, U0 = new double[] { 50 }, TimeDelay_s = 5, Bias = 50 }; var pidParameters1 = new PidParameters() { Kp = 3, Ti_s = 2 //rapid }; var pidParameters2 = new PidParameters() { Kp = 1, Ti_s = 40 //slow }; var process1 = new UnitModel(processParameters1, \"Process1\"); var process2 = new UnitModel(processParameters2, \"Process2\"); var pid1 = new PidModel(pidParameters1, \"PID1\"); var pid2 = new PidModel(pidParameters2, \"PID2\"); var sim = new PlantSimulator(new List<ISimulatableModel> { process1, process2, pid1, pid2 }); // pid1.SetManualOutput(50); // pid1.SetToManualMode(); // pid2.SetManualOutput(50); // pid2.SetToManualMode(); sim.ConnectModels(process1, process2); sim.ConnectModels(process1, pid1); sim.ConnectModels(pid1, process1); sim.ConnectModels(process2, pid2); sim.ConnectModels(pid2, pid1,(int)PidModelInputsIdx.Y_setpoint); var inputData = new TimeSeriesDataSet(); inputData.Add(sim.AddExternalSignal(pid2,SignalType.Setpoint_Yset),TimeSeriesCreator.Constant(50, N)); inputData.Add(sim.AddExternalSignal(process1,SignalType.Disturbance_D),TimeSeriesCreator.Sinus(5,20,timeBase_s,N)); inputData.Add(sim.AddExternalSignal(process2,SignalType.Disturbance_D),TimeSeriesCreator.Step(300, N, 0, 1)); inputData.CreateTimestamps(timeBase_s); var isOK = sim.Simulate(inputData,out var simResult); // Shared.EnablePlots(); Plot.FromList(new List<double[]> { simResult.GetValues(process1.GetID(),SignalType.Output_Y), simResult.GetValues(process2.GetID(),SignalType.Output_Y), inputData.GetValues(pid2.GetID(),SignalType.Setpoint_Yset), simResult.GetValues(pid1.GetID(),SignalType.PID_U), simResult.GetValues(pid2.GetID(),SignalType.PID_U) }, new List<string> { \"y1=y1\", \"y2=y2[right]\",\"y2=y2_set[right]\", \"y3=u1\", \"y4=u2[right]\" }, timeBase_s, \"CascadeEx\"); // Shared.DisablePlots(); The resulting results. To observe the open-loop behavior of the system for the same disturbances but with both controllers in manual mode , comment in the code lines: pid1.SetManualOutput(50); pid1.SetToManualMode(); pid2.SetManualOutput(50); pid2.SetToManualMode(); The resulting open-loop simulation results: These simualtions show the benefits of the cascade control over open-loop: transients in y2 of +/-0.5 , are reduced to approximiately +/-0.1 , and the step disturbance in y2 is rejected. Note There are slight \"bumps\" in both the open-loop and closed-loop cases above. This is because the simulations by design start in steady-state, whereas for the rest of the simulation the entire process is in never-ending transient state because of the sinusoidal disturbance on y1 . Thus this bump is unavoidable, therefore in cases such as this, models should only be evaluated after a run-in-time."
  },
  "articles/pid_feedforward.html": {
    "href": "articles/pid_feedforward.html",
    "title": "Feedforward control | TimeSeriesAnalysis reference documentation",
    "keywords": "Feedforward control . Simulating pid-control against an external disturbance without feed-forward The first part of this example shows the performance of the process and PID-controller when a step change occurs in the disturbance signal. Note that while the PID-controller is able to stabilize the process, it does create significant offset in y , it falls to about y=46.5 at its lowest. var processParameters = new UnitParameters { TimeConstant_s = 30, LinearGains = new double[] { 1.1 }, U0 = new double[] { 50 }, TimeDelay_s = 0, Bias = 50 }; var disturbanceParameters = new UnitParameters { TimeConstant_s = 30, LinearGains = new double[] { 1 }, U0 = new double[] { 0 }, TimeDelay_s = 5, Bias = 0 }; var pidParameters = new PidParameters() { Kp = 0.3, Ti_s = 20 }; var processModel = new UnitModel(processParameters, \"Process1\"); var disturbanceModel = new UnitModel(disturbanceParameters, \"Disturbance1\"); var pidModel = new PidModel(pidParameters, \"PID\"); var simNoFeedF = new PlantSimulator( new List<ISimulatableModel> { processModel, disturbanceModel, pidModel }); simNoFeedF.ConnectModels(pidModel, processModel); simNoFeedF.ConnectModels(processModel, pidModel); simNoFeedF.ConnectModelToOutput(disturbanceModel, processModel); var inputData = new TimeSeriesDataSet(); inputData.Add(simNoFeedF.AddExternalSignal(pidModel, SignalType.Setpoint_Yset), TimeSeriesCreator.Constant(60, 600)); inputData.Add(simNoFeedF.AddExternalSignal(disturbanceModel, SignalType.External_U), TimeSeriesCreator.Step(300, 600, 25, 0)); inputData.CreateTimestamps(timeBase_s); var isOk = simNoFeedF.Simulate(inputData,out var dataNoFeedF); Plot.FromList(new List<double[]> { dataNoFeedF.GetValues(processModel.GetID(),SignalType.Output_Y), inputData.GetValues(pidModel.GetID(),SignalType.Setpoint_Yset), dataNoFeedF.GetValues(disturbanceModel.GetID(),SignalType.Output_Y), dataNoFeedF.GetValues(pidModel.GetID(),SignalType.PID_U), inputData.GetValues(disturbanceModel.GetID(),SignalType.External_U) }, new List<string> { \"y1=y_run1\", \"y1=y_setpoint\", \"y2=y_dist[right]\", \"y3=u_pid\", \"y3=u_dist\" }, timeBase_s, \"FeedForwardEx1\"); Adding feed-forward to the simulation In the second part of this example a feed-forward term is added to the PID-controller. The input to the disturbance process is assumed to be measured and is used as the feed-forward variable. Since this variable moves slightly in advance of the disturbance as seen on y due to a time delay and time constant, a feed-forward from this variable should improve performance. As seen, the offset between y and y_set is less during the same disturbance step as in the previous part of this example, with y falling to just y=50.4 at its lowest, but at the expense of a slight overshoot in y . var processParameters = new UnitParameters { TimeConstant_s = 30, LinearGains = new double[] { 1.1 }, U0 = new double[] { 50 }, TimeDelay_s = 0, Bias = 50 }; var disturbanceParameters = new UnitParameters { TimeConstant_s = 30, LinearGains = new double[] { 1 }, U0 = new double[] { 0 }, TimeDelay_s = 5, Bias = 0 }; var pidParameters = new PidParameters() { Kp = 0.3, Ti_s = 20, FeedForward = new PidFeedForward() { isFFActive = true, FF_Gain = -0.7, FFHP_filter_order = 1, FFLP_filter_order = 1, FF_HP_Tc_s = 60, FF_LP_Tc_s = 0//120 } }; var processModel = new UnitModel(processParameters, \"Process1\"); var disturbanceModel = new UnitModel(disturbanceParameters, \"Disturbance1\"); var pidModel = new PidModel(pidParameters, \"PID\"); var simNoFeedF = new PlantSimulator( new List<ISimulatableModel> { processModel, disturbanceModel, pidModel }); simNoFeedF.ConnectModels(pidModel, processModel); simNoFeedF.ConnectModels(processModel, pidModel); simNoFeedF.ConnectModelToOutput(disturbanceModel, processModel); var inputData = new TimeSeriesDataSet(); inputData.Add(simNoFeedF.AddExternalSignal(pidModel, SignalType.Setpoint_Yset), TimeSeriesCreator.Constant(60, 600)); string dSignalID = simNoFeedF.AddExternalSignal(disturbanceModel, SignalType.External_U); inputData.Add(dSignalID, TimeSeriesCreator.Step(300, 600, 25, 0)); inputData.CreateTimestamps(timeBase_s); simNoFeedF.ConnectSignalToInput(dSignalID, pidModel, (int)PidModelInputsIdx.FeedForward); var isOk = simNoFeedF.Simulate(inputData,out var dataNoFeedF); Plot.FromList(new List<double[]> { dataNoFeedF.GetValues(processModel.GetID(),SignalType.Output_Y), inputData.GetValues(pidModel.GetID(),SignalType.Setpoint_Yset), dataNoFeedF.GetValues(disturbanceModel.GetID(),SignalType.Output_Y), dataNoFeedF.GetValues(pidModel.GetID(),SignalType.PID_U), inputData.GetValues(disturbanceModel.GetID(),SignalType.External_U) }, new List<string> { \"y1=y_run1\", \"y1=y_setpoint\", \"y2=y_dist[right]\", \"y3=u_pid\", \"y3=u_dist\" }, timeBase_s, \"FeedForwardEx2\");"
  },
  "articles/pid_gainscheduling.html": {
    "href": "articles/pid_gainscheduling.html",
    "title": "Gain-scheduling a nonlinear process | TimeSeriesAnalysis reference documentation",
    "keywords": "Gain-scheduling a nonlinear process This example considers a system that is nonlinear, and illustrates how to apply and simulate gain-scheduling for such a system. Note This example considers gain-scheduling only in Kp , but PIDModel also supports gain scheduling in Ti . Simulating step responses of the open-loop system The system considered is given a negative curvature , meaning that the gain will decrease with increasing values of u . Firstly, the system is defined and the two simulation runs are done, one run at a low value of input, where the gain is high , and a second at a high value of the input, where the gain is low . var modelParameters = new UnitParameters { TimeConstant_s = 0, LinearGains = new double[] { 1.1 }, Curvatures = new double[] { -0.7 }, U0 = new double[] { 50 }, UNorm = new double[] { 50 }, TimeDelay_s = 0, Bias = 50 }; var processModel = new UnitModel(modelParameters, \"Process1\"); var openLoopSim1 = new PlantSimulator( new List<ISimulatableModel> { processModel }); var inputDataSim1 = new TimeSeriesDataSet(); inputDataSim1.Add(openLoopSim1.AddExternalSignal(processModel, SignalType.External_U), TimeSeriesCreator.Step(50, 200, 80, 90)); inputDataSim1.CreateTimestamps(timeBase_s); openLoopSim1.Simulate(inputDataSim1,out var openLoopData1); var openLoopSim2 = new PlantSimulator( new List<ISimulatableModel> { processModel }); var inputDataSim2 = new TimeSeriesDataSet(); inputDataSim2.Add(openLoopSim2.AddExternalSignal(processModel, SignalType.External_U), TimeSeriesCreator.Step(50, 200, 20, 30)); inputDataSim2.CreateTimestamps(timeBase_s); var isOk1 = openLoopSim2.Simulate(inputDataSim2,out var openLoopData2); Plot.FromList(new List<double[]> {openLoopData1.GetValues(processModel.GetID(),SignalType.Output_Y), openLoopData2.GetValues(processModel.GetID(),SignalType.Output_Y), openLoopData1.GetValues(processModel.GetID(),SignalType.External_U), openLoopData2.GetValues(processModel.GetID(),SignalType.External_U) }, new List<string> {\"y1=y1(run1)\",\"y1=y2(run2)\",\"y3=u(run1)\",\"y3=u(run2)\"} ,timeBase_s,\"GainSchedulingEx\"); The resulting plot is shown below: Simulating the use of two standard PID-controllers // the system rejecting a disturbance at y=20 with pidModel1 var pidParameters1 = new PidParameters() { Kp = 0.3, Ti_s = 20 }; var pidModel1 = new PidModel(pidParameters1, \"PID1\"); var closedLoopSim1 = new PlantSimulator( new List<ISimulatableModel> { pidModel1, processModel }); closedLoopSim1.ConnectModels(pidModel1,processModel); closedLoopSim1.ConnectModels(processModel, pidModel1); var inputData1 = new TimeSeriesDataSet(); inputData1.Add(closedLoopSim1.AddExternalSignal(pidModel1, SignalType.Setpoint_Yset), TimeSeriesCreator.Constant(20,400)); inputData1.Add(closedLoopSim1.AddExternalSignal(processModel,SignalType.Disturbance_D), TimeSeriesCreator.Step(100,400,0,10)); inputData1.CreateTimestamps(timeBase_s); var isOk =closedLoopSim1.Simulate(inputData1,out var closedLoopData1); // the system rejecting a disturbance at y=70 with pidModel2 var pidParameters2 = new PidParameters() { Kp = 1,//NB! higher Kp Ti_s = 20 }; var pidModel2 = new PidModel(pidParameters2, \"PID2\"); var closedLoopSim2 = new PlantSimulator( new List<ISimulatableModel> { pidModel2, processModel }); closedLoopSim2.ConnectModels(pidModel2, processModel); closedLoopSim2.ConnectModels(processModel, pidModel2); var inputData2 = new TimeSeriesDataSet(); inputData2.Add(closedLoopSim2.AddExternalSignal(pidModel2, SignalType.Setpoint_Yset), TimeSeriesCreator.Constant(70, 400)); inputData2.Add(closedLoopSim2.AddExternalSignal(processModel, SignalType.Disturbance_D), TimeSeriesCreator.Step(100, 400, 0, 10)); inputData2.CreateTimestamps(timeBase_s); var isOk2 = closedLoopSim2.Simulate(inputData2,out var closedLoopData2); Plot.FromList(new List<double[]> {closedLoopData1.GetValues(processModel.GetID(),SignalType.Output_Y), inputData1.GetValues(pidModel1.GetID(),SignalType.Setpoint_Yset), closedLoopData1.GetValues(pidModel1.GetID(),SignalType.PID_U), closedLoopData2.GetValues(processModel.GetID(),SignalType.Output_Y), inputData2.GetValues(pidModel2.GetID(),SignalType.Setpoint_Yset), closedLoopData2.GetValues(pidModel2.GetID(),SignalType.PID_U), }, new List<string> { \"y1=y_run1\",\"y1=y_setpoint(run1)\", \"y2=u_run1(right)\",\"y3=y-run2\", \"y3=y_setpoint(run2)\", \"y4=u_run2(right)\" }, timeBase_s, \"GainSchedulingEx_2\"); The resulting plot is shown below: Note In order to get an approximately equally rapid disturbacne rejection at setpoint y=70 as for y=20 , Kp had to be increased from 0.3 to 1 , so by about a factor of three. It would be quite hard to find a single PID-controller tuning that would work equally well across the entire span of possible outputs y . Thus a gain-scheduled controller could be useful here. Combining the two controllers into a single gain-scheduled controller In the final part of this example, a gain-scheduling controller that performs equally well for both cases is created. The code to create the gain-scheduling controller and simulate both runs: // building a gain-scheduling controller that is able to handle both regimes var pidParametersGS = new PidParameters() { Ti_s = 20, GainScheduling = new PidGainScheduling() { GSActive_b =true,// turn on gain-scheduling GS_x_Min =0, //Gain-scheduling: x minimum x=GsVariable GS_x_1= 20, //Gain-scheduling: x1,x=GsVariable GS_x_2=70, //Gain-scheduling: x2,x=GsVariable GS_x_Max=100, //Gain-scheduling: x maxiumum, x = GsVariable GS_Kp_Min=0.1, //Gain-scheduling: KP @ GsVariable=GS_x_Min GS_Kp_1=0.2, //Gain-scheduling: KP @ GsVariable=GS_x_1 GS_Kp_2=1, //Gain-scheduling: KP @ GsVariable=GS_x_2 GS_Kp_Max=1.2 //Gain-scheduling: KP @ GsVariable=GS_x_Max } }; var pidModelGS = new PidModel(pidParametersGS, \"PID_GS\"); var closedLoopSimGS_1 = new PlantSimulator( new List<ISimulatableModel> { pidModelGS, processModel }); closedLoopSimGS_1.ConnectModels(pidModelGS, processModel); closedLoopSimGS_1.ConnectModels(processModel, pidModelGS); var inputDataGS1 = new TimeSeriesDataSet(); inputDataGS1.Add(closedLoopSimGS_1.AddExternalSignal(pidModelGS, SignalType.Setpoint_Yset), TimeSeriesCreator.Constant(20, 400)); inputDataGS1.Add(closedLoopSimGS_1.AddExternalSignal(processModel, SignalType.Disturbance_D), TimeSeriesCreator.Step(100, 400, 0, 10)); inputDataGS1.CreateTimestamps(timeBase_s); // Gain-scheduling variable: closedLoopSimGS_1.ConnectModels(processModel,pidModelGS,(int)PidModelInputsIdx.GainScheduling); var isOk3 = closedLoopSimGS_1.Simulate(inputDataGS1,out var closedLoopDataGS_1); var closedLoopSimGS_2 = new PlantSimulator( new List<ISimulatableModel> { pidModelGS, processModel }); closedLoopSimGS_2.ConnectModels(pidModelGS, processModel); closedLoopSimGS_2.ConnectModels(processModel, pidModelGS); var inputDataGS2 = new TimeSeriesDataSet(); inputDataGS2.Add(closedLoopSimGS_2.AddExternalSignal(pidModelGS, SignalType.Setpoint_Yset), TimeSeriesCreator.Constant(70, 400)); inputDataGS2.Add(closedLoopSimGS_2.AddExternalSignal(processModel, SignalType.Disturbance_D), TimeSeriesCreator.Step(100, 400, 0, 10)); inputDataGS2.CreateTimestamps(timeBase_s); // Gain-scheduling variable: closedLoopSimGS_2.ConnectModels(processModel, pidModelGS, (int)PidModelInputsIdx.GainScheduling); var isOk4 = closedLoopSimGS_2.Simulate(inputDataGS2, out var closedLoopDataGS_2); Plot.FromList(new List<double[]> {closedLoopDataGS_1.GetValues(processModel.GetID(),SignalType.Output_Y), inputDataGS1.GetValues(pidModelGS.GetID(),SignalType.Setpoint_Yset), closedLoopDataGS_1.GetValues(pidModelGS.GetID(),SignalType.PID_U), closedLoopDataGS_2.GetValues(processModel.GetID(),SignalType.Output_Y), inputDataGS2.GetValues(pidModelGS.GetID(),SignalType.Setpoint_Yset), closedLoopDataGS_2.GetValues(pidModelGS.GetID(),SignalType.PID_U) }, new List<string> { \"y1=y_run1\",\"y1=y_setpoint(run1)\", \"y2=u_run1(right)\",\"y3=y-run2\", \"y3=y_setpoint(run2)\", \"y4=u_run2(right)\" }, timeBase_s, \"GainSchedulingEx_3\"); The resulting plot is shown below: Note Notice how in the final plot, the gain-scheduling controller combines the control performance of both controllers in the above parts of the example in a single controller ."
  },
  "articles/pid_select.html": {
    "href": "articles/pid_select.html",
    "title": "min/max select and tracking | TimeSeriesAnalysis reference documentation",
    "keywords": "min/max select and tracking Note Work-in-progress, this article is currently a stub. Tracking signals need to be added, the treatment of tracking signals inside pidcontroller.cs needs to be reviewed, and the how to initialize a system that included select-blocks need to be reviewed. This example considers two controllers who take turns controlling a process through a min-select. PID1 is the controller which is normally active, while PID2 is a more aggressive controller that takes over to more aggressively steer the process. This type of configuration is reminiscent of how inlet separator levels may be controlled: one controller is active during \"typical\" operation with a low gain to let the level fluctuate and exploit the buffer capacity of the tank another controller is need to take over in case that a very large inlet disturbance (a \"slug\" of liquid) to avoid filling the tank completely. The two controllers in this kind of configuration have different setpoints , different integral times and different gains . The output Y could for instance be the level in the tank, and the input U could be the opening of the gas outlet, one strategy to avoid liquid carryover could be to have this valve close more if a slug arrives. . var processParameters = new UnitParameters { TimeConstant_s = 10, LinearGains = new double[] { 1 }, U0 = new double[] { 50 }, TimeDelay_s = 5, Bias = 50, Y_min =0, Y_max =100 }; var pidParameters1 = new PidParameters() { Kp = 0.5, //low-gain Ti_s = 250 // slow control (use buffer capacity, use less valve action) }; // var pidParameters2 = new PidParameters() { Kp = 2,//high-gain Ti_s = 15 // faster control(avoid carryover, aggressivley use valve when needed) }; var process = new UnitModel(processParameters, \"Process\"); var pid1 = new PidModel(pidParameters1, \"PID1\"); var pid2 = new PidModel(pidParameters2, \"PID2\"); var minSelect = new Select(SelectType.MIN,\"minSelect\"); var sim = new PlantSimulator( new List<ISimulatableModel> { process, pid1, pid2,minSelect }); // tracking and min select-related sim.ConnectModels(process, pid1); sim.ConnectModels(process, pid2); sim.ConnectModels(pid1, minSelect,0); sim.ConnectModels(pid2, minSelect,1); string selectSignalID = sim.ConnectModels(minSelect, process); sim.ConnectSignalToInput(selectSignalID,pid1,(int)PidModelInputsIdx.Tracking); sim.ConnectSignalToInput(selectSignalID,pid2,(int)PidModelInputsIdx.Tracking); var inputData = new TimeSeriesDataSet(); inputData.Add(sim.AddExternalSignal(pid1, SignalType.Setpoint_Yset), TimeSeriesCreator.Constant(50, N)); inputData.Add(sim.AddExternalSignal(pid2, SignalType.Setpoint_Yset), TimeSeriesCreator.Constant(70, N)); inputData.Add(sim.AddExternalSignal(process, SignalType.Disturbance_D), new Vec().Add(TimeSeriesCreator.Sinus(5,50,timeBase_s,N), TimeSeriesCreator.TwoSteps(N*2/8,N*3/8,N,0,80,0)) ); inputData.CreateTimestamps(timeBase_s); var isOK = sim.Simulate(inputData, out var simResult); Plot.FromList(new List<double[]> { simResult.GetValues(process.GetID(),SignalType.Output_Y), Vec<double>.Fill(85,N), inputData.GetValues(pid1.GetID(),SignalType.Setpoint_Yset), inputData.GetValues(pid2.GetID(),SignalType.Setpoint_Yset), simResult.GetValues(pid1.GetID(),SignalType.PID_U), simResult.GetValues(pid2.GetID(),SignalType.PID_U), simResult.GetValues(minSelect.GetID(),SignalType.SelectorOut), }, new List<string> { \"y1=y1\",\"y1=yHH\", \"y1=y1_set\", \"y1=y2_set\", \"y3=u_pid1\", \"y3=u_pid2\",\"y3=u_select\" }, timeBase_s, \"MinSelectEx\");"
  },
  "articles/pidcontrol.html": {
    "href": "articles/pidcontrol.html",
    "title": "PID control | TimeSeriesAnalysis reference documentation",
    "keywords": "PID control The PID-controller implemented in this library has the following features: anti-windup gain-scheduling input/output scaling feedforward tracking (for min/max select control) input filtering anti-surge \"kick\" control bumpless transfer between manual and automatic modes"
  },
  "articles/plot_setup.html": {
    "href": "articles/plot_setup.html",
    "title": "Setting up plots | TimeSeriesAnalysis reference documentation",
    "keywords": "Setting up plots Note The built-in plotting is mainly intended to provide a stand-alone plotting capability to those working in Visual Studio. If you are running the code from Python or Matlab, you might find it easier to get started with the built-in plotting in those languages (see Python \"getting started\" examples). If you have set up plotting correctly, you should be able to run the \"PlotUnitTests\" test from the Test Explorer in Visual Studio and plots should appear in a new browser window. For plotting to work you need four prerequisites Chrome must installed (by default in C:\\Program Files (x86)\\Google\\Chrome\\Application\\chrome.exe ) you need to be running a local http-server, if it servers a folder [wwwroot] then beneath it there mustbe a [wwwroot]\\plotly that contains the javscript files in the \"www\\plotly\" subfolder in the TimeSeriesAnalysis repository the folder [wwwroot]\\plotly\\Data needs to match the plotDataPath in Plot (by default: C:\\inetpub\\wwwroot\\plotly\\Data ). CSV-data files will be written in here. the front-end JavaScript code needs to find the time-series data in csv-files in its localhost\\plotly\\data folder. (if your http-server is serving another folder than C:\\inetpub\\wwwroot up on localhost , you need to use mklink` to link this folder with the http-server's [root]\\plotly\\data`` folder ) Caution Be aware that you if port 80 and 443 are open on your machine and network, the data in the plotly\\data folder may be shared with the world. It is your responsibility to block these ports if you want to avoid sharing sensitive data. Chrome Currently, plotting requires Chrome,and the project expects Chrome to be installed in the folder C:\\Program Files (x86)\\Google\\Chrome\\Application\\chrome.exe . Running a local HTTP-server In Windows, if you are not already running a http-server, the easiest way to install one may be to install Internet Information Services(IIS) . This is done from Control Panel->Windows Features and selecting Internet information Services in the menu that appears (requires Administrator privileges). If setting up a new server, it is advantageous to map the folder c:\\inetpub\\wwwroot , but it can be any path as long as it contains a \"plotly\" subfolder and that subfolder has a subfolder data where data-files are added. If running IIS, start \"Internet Information Services(IIS) Manager\" from the start menu, then go to \"default website\" press \"basic settings\", make a note of the \"physical path\" and change if needed. The \"physical path\" is where you need to link in the \"plotly\" folder. Serving up the \"plotly\" folder When running a local http-server for development, you will need to add the folder \"plotly\" to it. The preferable way to to this is to add a symbolic link to the TimeSeriesAnalysis folder rather than copying files, to allow for version control. Suppose that your TimeSeriesAnalysis source code is stored in C:\\appl\\source\\TimeSeriesAnalysis , and that you are running an http-sever that is hosting the folder C:\\inetpub\\wwwroot (your localhost ). In Windows : Start a command prompt (cmd.exe) session in Windows with administrator privileges and give the following command: mklink /D c:\\inetpub\\wwwroot\\plotly C:\\appl\\source\\TimeSeriesAnalysis\\www\\plotly Note Plotting using the Plot class will cause browser windows to open on localhost\\plotly\\index.html . This html-file expects to find javscript files CsvToTable.js , plotlyInterface.js and vendor\\plotly.min.js . vendor\\plotly.min.js is obtained from https://plotly.com/javascript/getting-started/ and you can swap the given file for other versions if needed. Changing the paths by editing TimeSeriesAnalysis.dll.config If the paths described above for whatever reason conflict with the setup of your computer, you can change these paths by editing the file TimeSeriesAnalysis.dll.config , which by default has the following content: <?xml version=\"1.0\" encoding=\"utf-8\"?> <configuration> <appSettings> <add key=\"PlotsAreEnabled\" value=\"true\" /> <add key=\"ChromePath\" value=\"C:\\Program Files (x86)\\Google\\Chrome\\Application\\chrome.exe\" /> <add key=\"PlotlyURL\" value=\"localhost\\plotly\\index.html\" /> <add key=\"PlotDataPath\" value=\"C:\\inetpub\\wwwroot\\plotly\\Data\" /> <add key=\"ClientSettingsProvider.ServiceUri\" value=\"\" /> </appSettings> <system.web> <membership defaultProvider=\"ClientAuthenticationMembershipProvider\"> <providers> <add name=\"ClientAuthenticationMembershipProvider\" type=\"System.Web.ClientServices.Providers.ClientFormsAuthenticationMembershipProvider, System.Web.Extensions, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35\" serviceUri=\"\" /> </providers> </membership> <roleManager defaultProvider=\"ClientRoleProvider\" enabled=\"true\"> <providers> <add name=\"ClientRoleProvider\" type=\"System.Web.ClientServices.Providers.ClientRoleProvider, System.Web.Extensions, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35\" serviceUri=\"\" cacheTimeout=\"86400\" /> </providers> </roleManager> </system.web> </configuration> Disabling all plots It is possible to entirely disable all plotting by setting the variable PlotsAreEnabled in the above mention filed to false . This could be useful as a safety-measure if the code was ever to run in a production environment. If necessary localhost\\plotly\\data needs to symbolically linked to c:/inetpub/www/plotly/data folder An alternate way to get around paths that do not suit your runtime environment is to use mklink . If your http-server is mapping \"c:\\inetpub\", then you will not need to do this step. TimeSeriesAnalysis will write data into C:\\inetpub\\plotly\\Data and it will thus be found by the javascript browser-side code and run to display your plots. If you are serving up another folder [PathXYZ] on your computer to localhost than \"c:\\inetpub\" , and do not want or cannot for whatever reason change TimeSeriesAnalysis.dll.config ,an alternate solution is to make a directory link by the following command on the command prompt( cmd.exe ) so: mklink /D C:\\inetpub\\wwwroot\\plotly\\Data C:\\[PathXYZ]\\plotly\\Data"
  },
  "articles/plotly.html": {
    "href": "articles/plotly.html",
    "title": "Plotly.js | TimeSeriesAnalysis reference documentation",
    "keywords": "Plotly.js Plotting of time-series is based on the plotly.js library, which is released under the MIT license and is free to distribute and use commerically. No changes are made or will be made to the original source files, but this class library is distributed with some additional javascript code that handles reading the URL and reading text files from disk containing the time-series information and calling the plotly.js library. Plotting is not a major part of this library's functionality, and the library can be used completely without this plotting. The plotting is also intended mostly as support during testing, for test-driven development, but since the plots are in web-page form they could also be used as a component in web-based dashboards or advisory tools. Note If calling on this library from Matlab or Python, users may choose to use the built-in plotting functionalities of those languages and their tools, the inclusion of plotly.js is to make the choice of plotting tool voluntary and to not require installing additional programs."
  },
  "articles/plotting.html": {
    "href": "articles/plotting.html",
    "title": "Plotting capabilities | TimeSeriesAnalysis reference documentation",
    "keywords": "Plotting capabilities Note This library is written to support test-driven development(TDD) of algorithms based on time-series, and to support the TDD workflow, it supports time-series plotting. This feature is extremely useful to visualize the results of of unit tests or acceptance tests, and this helps enormously with debugging. The unit tests of this repository, give an example of how you can use these plotting capabilities for your own testing. Plotting features supported one or two subplots(stacked vertically) one or two y-axes on either subplot support for zooming in the plot, subplots x-axes are linked when zooming ability to turn trends on/off, which will cause auto-zoom to update ability to hover over trends to inspect values currently up to six trends can be plotted on a page in total(this can be increased if there is interest) The plotting leverages the JavaScript framework plot.ly . Some JavaScript extensions have been made to this toolbox to allow time-series to seamlessly be exported from your .NET code to the browser. Consider the unit-test PlotUnitTests.SubplotPositionWorksOk() : The code below is used to generate four \"vectors\", arrays of doubles, with a step change in each. public void SubplotPositionWorksOk() { double[] input2 = Vec<double>.Concat(Vec<double>.Fill(0, 20), Vec<double>.Fill(2, 20)); double[] input1 = Vec<double>.Concat(Vec<double>.Fill(0, 10), Vec<double>.Fill(1, 30)); double[] input3 = Vec<double>.Concat(Vec<double>.Fill(0, 30), Vec<double>.Fill(1, 10)); double[] input4 = Vec<double>.Concat(Vec<double>.Fill(0, 35), Vec<double>.Fill(1, 5)); string plotURL = Plot.FromList(new List<double[]>{ input1,input2,input3,input4}, new List<string>{ \"y1=input1\",\"y2=input2\",\"y3=input3\",\"y4=input4\"},1, \"unit test\",new DateTime(2020,1,1, 0,0,0), \"Test_SubplotPositionWorksOk\"); } Note Note how the Vec.Fill() an Vec.Concat() of TimeSeriesAnalysis package is used in this example to create two vectors of a given length and value and concatenate them in a single line of code. The above code generates the following interactive plot in a Chrome-window(this window pops up automatically): This plot has two subplots (one top, one bottom). Each subplot has both a left and a right axis: the top subplot has axes y1 and y2 and the bottom subplot has axes y3 and y4 . By using the top left menu, it is possible to zoom and drag the plots, and the two subplots are linked , meaning when you zoom in one of them, the x-axes of the other plot will zoom as well. Moving the cursor over each plot allows the values to be browsed by an interactive scooter . By clicking on the variable names in the legend on the top left, it is possible to disable plotting selected variables. Note Multiple plots will cause Chrome to display them in multiple tabs. A large number of figures can be generated and sorted in this way."
  },
  "articles/principles.html": {
    "href": "articles/principles.html",
    "title": "Design choices | TimeSeriesAnalysis reference documentation",
    "keywords": "Design choices Motivation human-configurable and human-readable dynamic process models (all parameters have an intuitive interpretation ) motivated by system identification methodology with intuitive parameters, humans can better understand automatically generated models and it becomes possible for humans to alter such models (semi-autonomous model generation). this excludes neural networks create large-scale dynamic simulator by connecting sub-systems, creating \"digital twin\" models this kind of sub-model is also intuitive to humans and visual start by modeling the process control system (PID-control loops), as this is the handle through which process changes are made. to model the process control system, the library must be able to describe dynamics , feedbacks and different kinds of PID-controllers . try to recreate disturbance signals D of each PID-control loop explicitly , as this is the \"excitation\" that causes variation in an industrial process, yet these signals are not measured or observed directly. How do disturbances move through a process with multiple PID-control stages? Can this be simulated? An explicit estimate of disturbances allows \"playback\" in simulations, which means that the response of the control system with other tunings or configurations can potentially be assessed in simulation. such a representation would negate the need for \"tuning rules\" for PID-controllers, they could instead be tuned by simulation it would become possible to consider the joint effect on re-tuning multiple PID-controllers it would become possible to consider changes in control structure , not just changes in tuning . if it were possible to find models with the above qualities from data it would enable: advanced analytics : autonomous or semi-autonomous analysis of process control which generates recommended actions data-driven digital twins : rapid development of \"fitted\" dynamic models for specific cases-studies or advanced control System identification \"The goal of the identification procedure is, in loose terms, to obtain a good and reliable model with a reasonable amount of work.\" (Lennart Ljung, Theory for the user 2ed, p.399) This quote displays the trade-off of the three different and sometimes opposing goals of identification: a good (accurate, descriptive) model, a reliable model, and a model developed with a reasonable amount of work . This library intends to focus on methods that give deliver a good balance of all three goals . Conversely this means that models that are either not good enough not reliable enough , or cannot be developed with a reasonable amount of work will not be considered. Further the choice of the model should ideally be based on \"posing a criterion for what is a good model and to list the constraints that are imposed on the design by limited time and cost\" (p.406) Thus system identification is a practical field that acknowledges that better models take more time and cost more money, and that these factors need to be taken into consideration. This class library is built on the following principles/assertions: most time-series are not designed for identification, and may have less than ideal amount of excitation, hence handling parameter uncertainty and avoiding over-parametrization are important, almost all systems are actually nonlinear , many but not all can be considered locally linear , real-world data will contain bad data points that need to be filtered out , and you may need to manually remove further non-representative data. Especially for recursive models, a single spurious value can destroy an entire model run, thus the tooling need to support cleaning data to avoid garbage getting into models. expect parameter uncertainty , treat it explicitly. Numerical solvers the models need to simulate without requiring any human intervention , and this has impacts on design choices for how models should be initialized and solved: rather than using numerical solvers on large matrices to find steady-state, a conscious choice is made to rather require each model to include an explicit steady-state calculation. rather than use numerical solvers on large matrices to simulate the model, a conscious choice is made to rather use logic to traverse the connected models as graphs and simulate them one-by-one in an order that is feasible. That means that this library must provide a solver that includes logic to determine a feasible solution order. Code design use dependency injection , generics and interfaces to make the process model easily replaceable - if you provide a new process model that implements the correct interfaces, it should immediately be compatible with re-usable functionality such as PID-control or simulation. do not use inheritance - except for abstract base classes - deep inheritance is hard to understand for others."
  },
  "articles/processsimulator.html": {
    "href": "articles/processsimulator.html",
    "title": "PlantSimulator | TimeSeriesAnalysis reference documentation",
    "keywords": "PlantSimulator Simulating multiple processes together is orchestrated by the class PlantSimulator . External interface The intention is that the PlantSimulator class should be able to simulate any well-formulated combination of models that implement the ISimulateableModel (such as PIDModel , Select and UnitModel .) Connections can be done using ConnectSignal connects a signal to a model ConnectModels : connects an output of one model to an input of another model ConnectModelToOutput : connects an output of model model to the output (additive) of another model External signals are defined using AddSignal : defines a new external signal that is to be included in the simulation Once all connections and signals are defined, the model combination is then simulated by PlantSimulator.Simulate() . The entire simulated dataset is presented after simulation as an object of the TimeSeriesDataSet class. Internal workings Internally each signal in the returned TimeSeriesDataSet is named by a naming convention that is handled by SignalNamer , which combines information about modelID and signal type to create a unique ID for each signal in the simulation. Determining calculation order, parsing connections By default, PlantSimulator traverses the combination of models and signals to create a feasible run-order in which to run the model, orchestrated by ConnectionParser.DetermineCalculationOrderOfModels . Models are then run in that given order for each iteration in PlantSimulator.Simulate() . This means that process simulation does not rely on simultaneously solving large sets of dynamic equations, which an approach that may be easier to comprehend and debug, but it is reliant on the quite complex logic required to determine the calculation order. Initialization of the dynamic model The model can be started without supplying a initial state. In that case the model attempts to start in the steady state that results from the first value (at t=t0 ) in each supplied PlantSimulator.AddSignal() . Determining the initial state is handled by the private method PlantSimulator.InitToSteadyState() , which is handled by parsing the model set and connections by logic. ModelBaseClass: Two types of inputs All models should inherit from ModelBaseClass . Each model has a number of inputs that travel through the model, each with an id these are referred to as model input IDs . In addition, models support adding signals directly to the output. This is a feature intended for modeling disturbances. The IDs of such signals are referred to as additive input IDs ."
  },
  "articles/python.html": {
    "href": "articles/python.html",
    "title": "Loading this library from Python | TimeSeriesAnalysis reference documentation",
    "keywords": "Loading this library from Python Loading and using the TimeSeriesAnalysis .NET class library in Python is possible by utilizing the Python.NET package. pythonnet enables calling .NET code in Python, and allows Python code to interact with the .NET Common Language Runtime (CLR). Note The current version of Python.NET is supported for Python 2.7 and for versions <= 3.8. Python setup In order to set up a working configuration in Windows, follow the steps below: Install a compatible version of Python (>= 3.5, <= 3.8). In your project directory (e.g. \"C:\\Appl\\myProject\"), create a new virtual environment and specify the desired Python version (e.g. 3.8): # In project directory \"C:\\Appl\\myProject\" > python3.8 -m venv venv Activate the virtual environment: > venv\\Scripts\\activate Install the Python.NET package: > pip install pythonnet Download a complete build of the TimeSeriesAnalysis assembly and accompanying dependecies from the list of online releases , and unzip the assembly in a designated folder you have created in your project directory (e.g. \"C:\\Appl\\myProject\\TSABuild\"). Note Alternatively, you can build and assemble the Dynamic-link libraries yourself, and copy the *.ddl-files into the folder in your project directory. If the Dynamic-link libraries are downloaded from the Internet on a Windows computer, unblock the TimeSeriesAnalysis assembly: Locate the file TimeSeriesAnalysis.dll in your project directory (e.g. \"C:\\Appl\\myProject\\TSABuild\"). Right-click on the file and select Properties from the menu. Click \"Unblock\" under the General tab. Click Apply, and then OK. To ensure the assembly can be implicitly imported, the directory containing the TimeSeriesAnalysis assembly must be added to your Python system path. In your desired Python file within your project, append the path of the folder containing the *.dll-files (e.g. \"C:\\Appl\\myProject\\TSABuild\") to the PYTHONPATH of your system: import sys assembly_path = r\"C:\\Appl\\myProject\\TSABuild\" sys.path.append(assembly_path) Load the TimeSeriesAnalysis assembly using Python.NET: import clr clr.AddReference(\"TimeSeriesAnalysis\") The non-private classes, structs, interfaces and methods from the TimeSeriesAnalysis .NET class library can now be utilized in Python. Consult the API documentation for reference, or check out some of the Python-specific introductory code examples. Using the modules in Python Classes and methods can be imported from the TimeSeriesAnalysis namespace and subnamespaces and used in Python. Importing the vector class and implementing the vector addition from TimeSeriesAnalysis import Vec results = Vec().Add([1, 2], [3, 4]) will yield an array of the type System.Double[] , which can be accessed using standard Python list indexing syntax: >> results[0] 4.0 >> results[1] 6.0"
  },
  "articles/sysid.html": {
    "href": "articles/sysid.html",
    "title": "| TimeSeriesAnalysis reference documentation",
    "keywords": "The field of system identification uses statistical methods to build mathematical models of dynamical systems from measured data . This library initially focuses on a simple and understandable, yet versatile class of models. For lack of a better name, this model class is referred to as the default process model . For those of you with a background in system identification, you can think of this model class as \"1.order ARX models with time delay and states(for dealing with disturbances).\" The default process model"
  },
  "articles/sysid_defaultmodel.html": {
    "href": "articles/sysid_defaultmodel.html",
    "title": "UnitModel - the default process model | TimeSeriesAnalysis reference documentation",
    "keywords": "UnitModel - the default process model Note As we shall se, the UnitModel has five very useful proprieties: the number of parameters is as low as possible, given the model's capability, reducing the likelihood of over-fitting , the parameters can be given an intuitive physical interpretation (making the model \"grey-box\" rather than \"black box\"), the model is linear-in-parameters , meaning parameters can be found using linear regression, the model can describe curvatures , a nonlinearity in the process gain, and by turning on or off different parameters, the model can take different capabilities, it acts as a flexible \"model set\" . Details The \"default\" model in this library is UnitModel , intended to be a model that can describe most average process systems. It aims to avoid over-parametrization , as this is known to cause issues on real-world datasets with limited excitation. As a design choice, the model has built in support for explicitly treating measured/modeled external disturbances , for use in analysis of closed-loop systems. The model is on the form y[k] = x[k] + d[k] where x[k] is the state at time k , d[k] is an external disturbance at time k , furthermore the state x[k] is modeled as x[k] = ax[k-1] + b(u[k-td]-u0) + q (linear in u) where t_d here denotes the time-delay in samples. The parameter a in the above equation should always be between [0;0.9999] . Note Notice that if a=0 the the recursive term is stricken, the disturbance is neglected and time delay is zero, then the model reverts to standard linear static model y[k] = bu[k] . The model is a difference model as x[k] depends on the previous value x[k-1] . is local as the terms b and optionally c apply locally around the operating point u0 . The above shows the model for a single input u , but the model excepts any number of inputs, so in the case of two inputs u1 and u2 for instance x[k] = ax[k-1] + b1(u1[k-t_d]-u_10)+ b2(u2[k-t_d]-u_20) + q (linear in u) Note All inputs in the same model by design share the same dynamic parameters a and t_d . If multiple inputs act on a single output y with different dynamics, then this should be modeled by two or more separate \"default models\" that are then added together - in identification the input of other sub-models can be accounted for by the disturbance-term d Second-order polynomial nonlinear gain Optionally the default model can be extended with a square term: x[k] = ax[k-1] + b(u[k-t_d]-u_0) + c/uNorm(u[k-t_d]-u_0)^2 + q (non-linear in u) Internally the parameter c is referred to as the \"Curvature\" of the default model. uNorm is a scaling parameter that is intended to ensure that the parameters b and c are of approximately equal scale during identification. It is recommended to choose uNorm equal to how much u is expect to vary from u0 . For example, if u0 and u is expected to vary in the range [20,80] , then uNorm should be chosen as 30 . Note The sign of the curvature terms c can be either positive or negative . If c is negative , then this means that the gains is higer below u0 and lower above u0 . If c is positive , then this means that the gains is lower below u0 and higher above u0 . Note If the model has curvature terms c then the process gain depends on both parameters b and c . Process gain and time constant It is related to the time-constant Tc by the equation a = 1/(1+Ts/Tc) where Ts is the sampling time , so that: Tc = Ts/(1/a-1). Note The time-constant is far easier to interpret intuitively, and is much easier to relate to PID-controller terms or filters than a directly. The process gain G1 between an input u1 and the output y is: G1 = b1/(1-a). If the model has two inputs, the second input u2 will have a process gain that depends on b2 G2 = b2/(1-a). If the default model has a second-order term with parameters c1,c2,... ,the the process gains are no longer constant, but will vary dependent on the value of the inputs u . Thus, these models are \"nonlinear in u\" , but the beauty of this model is that these model are still \"linear in parameters [a, b1,..bN, c1,...CN] \" so that the identifier can be based on linear regression. The process gains become functions of u , so for instance for u1 , the process gain will be G1(u1) becomes: G1(u1) = b1/(1-a) + c1/(1-a)2u1."
  },
  "articles/sysid_disturbance.html": {
    "href": "articles/sysid_disturbance.html",
    "title": "Closed-loop disturbance signal estimation | TimeSeriesAnalysis reference documentation",
    "keywords": "Closed-loop disturbance signal estimation What is it? The disturbance is an additive signal that moves the output of the given unit process. Counter-acting disturbances are the very reason that feedback controllers are used, they observe the deviation between setpoint and measurement of the plant output, and change one-or more inputs to counter-act the disturbance. Example: step disturbance Consider a step disturbance acting on a system without feedback The feedback is directly fed through to the output, while the input is constant. Now consider and compare the same step disturbance, but this time a PID-controller counter-acts the disturbance The disturbance initally appears on the system output, then is slowly counter-acted by change of the manipulated variable u by feedback control, thus moving the effect of the disturbance from the output y to the manipualted u . Observing the offset between setpoint and measurement gives a \"high-frequency\" d_HF response and is seen first, while the change in u is gradual and \"low-frequency\" d_LF and the approach will attempt to combine the two as shown below The aim of this section is to develop an algorithm to estimate the the un-meausred disturbance d indirectly based on the measured u and e Why is distrubance signal estimation important? Disturbances are the \"action\" or \"excitation\" that causes feedback-controlled systems to move, if these signals could be estimated, then a disturbance could be \"played back\" in a simulation and different changes to the control system could be assessed and compared. Describing the disturbance signal is also important for identifying the other components of a feedback-controlled system correctly, as disturbances are \"non-white\" noise that tends to skew estimates (destroying the regression accuracy) if not accounted for. What are the challenges? The challenge in describing disturbances in feedback-systems is that the feedback aims to counter-act the very disturbance which needs to be described by changing the manipulated variable. Thus, the effect of the disturbance is in the short-term seen on the system output y , but in the long-term the effects of the disturbance are seen on the feedback-manipulated variable u . The PID-controller will act with some time-constant on u ,and this change in u will again act back on the output y with a delay or dynamic behavior that is given by the process(described by the process model.) To know what amplitude a disturbance has, requires knowledge of how much effect (or \"gain\") the change in manipulated variable u will have caused on the output y . Thus the two tasks of estimating the disturbance and estimating the process model are linked , and thus they likely need to be solved jointly . Approach The chosen approach to solve the linked problem of solving for process model and disturbance signal is sequential (as opposed to simultaneous), meaning that the algorithm first estimates a disturbance signal, then what process model best describes the data for the given disturbance signal, then the estimate of the disturbance is updated using the model, back-and-forth until both estimates hopefully converge. Let the control deviation e be defined as e = (y_meas-y_set) Further, the disturbance is divided into a high-frequency part d_HF and a low-frequency part d_LF , and it is assumed that d = d_HF+d_LF = d_HF(e)+ d_LF(u) d_LF will in general also be a function of the process model, especially the process gain. Guessing the sign of the process gain Methods for open-loop estimation when applied naively to closed loop time-series often estimte process gain with the incorrect sign. The reason for this is that cause-and-effect relatinships are different in closed- and open loop. As an example, if inputs u and output y increase in unison, you would in the open-loop case assume that the process gain is positive . In the closed-loop case, the same relation between input and output change is often indicative of a negative process gain . In the closed loop, a disturbance enteres the output y , is counter-acted by the controller output u , so an increasing u in response to an increasing y would be because the sign is negative. The inverse is also true, what appear to be negative process gains at first sight may in closed-loop be positive process gains. It is thus important to use an identification algorithm that is intended for closed loop signals, and to also include information about the setpoint yset to the algorithm, so that the algorith can infer about the control error e . First, model-free estimate In order to initialize the sequential estimation, a model-free estimate of the disturbance is require initially. For the first iteration, all process dynamics and nonlinearities are neglected, a linear static model essentially boils down to estimating the process gain. This first estimate of the process gain G in a linear model y = G x u is found by the approximation G = max(e)/(max(u)-min(u)) Separating the state of the system from the output Let the state X be defined as the output minus the disturbance: y = x + d When solving the process model for a given disturbance, the identification is done on the un-measured x found from x = y-d Determing the dynamic parameters of the process This is currently a work in progress. If the process is actually dynamic yet is modeled as static, then the above methodology will result into un-modeled transients bleeding into the estimated disturbance, where they will appear as \"overshoots\" 2.order dynamics in the estimated disturbance. If every change in e is followed by similar transient in d then this is a sure sign that there is un-modeled dynamics, if these \"transients\" can be described by adding dynamic terms to models and this causes a \"flatter\" estimated disturbance, then this is usually preferable. These un-modeled transients may also cause process gains and disturbance estimates to be skewed slightly too large. In the final step, the ClosedLoopEstimator tries to modify the static models identifier previously by adding larger and larger time constants to the identified model, and observing if this reduces the *absolute, sample-over-sample variance in the disturbance\". Algorithm (In the case of no setpoint changes in the data set) - Guess the process gain, as shown above - Disturbance(\"run1\"):Estimate the disturbance for the linear static process gain - Model(\"run1\"):Subtract the above disturbance signal from y, and run UnitIdentifier.IdentifyLinearAndStatic to estimate - Disturbance(\"run2\"):Estimate the disturbance using the above process model - Model(\"run2\"): Subtract the above disturbance signal from y, and run UnitIdentifier.Linear - Disturbance(\"run3\"):Estimate the disturbance using the above process model - Model(\"run3\"): Subtract the above disturbance signal from y, and run UnitIdentifier.Linear - Disturbance(\"run4\"):Estimate the disturbance when different time-constants are added to the model of run3, choose the model which gives the disturbance with the least absolute sample-over-sample variance"
  },
  "articles/sysid_ex_nonlin.html": {
    "href": "articles/sysid_ex_nonlin.html",
    "title": "| TimeSeriesAnalysis reference documentation",
    "keywords": "This example shows how the UnitIdentifier can be used to identify a model that can include nonlinearities, time-delay and time-constant simultaneously. The code for this example: public void NonlinearUnitModel() { // constants of the designed double timeConstant_s = 10; double timeDelay_s = 4; double timeBase_s = 1; double bias = 1; double noiseAmplitude = 0.1; // create the input U as a matrix double[] u1 = TimeSeriesCreator.ThreeSteps(60, 120, 180, 240, 0, 1, 2, 3); double[] u2 = TimeSeriesCreator.ThreeSteps(90, 150, 210, 240, 2, 1, 3, 2); double[,] U = Array2D<double>.CreateFromList(new List<double[]> { u1, u2 }); // simulate a linear reference model for comparison UnitParameters paramtersNoCurvature = new UnitParameters { TimeConstant_s = timeConstant_s, TimeDelay_s = timeDelay_s, LinearGains = new double[] { 2, -0.05 }, U0 = new double[] { 1.1, 1.1 }, Bias = bias }; var refModel = new UnitModel(paramtersNoCurvature, \"Reference\"); var refSim = new UnitSimulator(refModel); var refData = new UnitDataSet(); refData.U = U; refSim.Simulate(ref refData); // simulate the nonlinear model UnitParameters designParameters = new UnitParameters { TimeConstant_s = timeConstant_s, TimeDelay_s = timeDelay_s, LinearGains = new double[] { 1, 0.7 }, Curvatures = new double[] { 1, -0.8 }, U0 = new double[] { 1.1, 1.1 },// set this to make results comparable UNorm = new double[] { 1, 1 },// set this to make results comparable Bias = bias }; var trueModel = new UnitModel(designParameters, \"NonlinearModel1\"); var sim = new UnitSimulator(trueModel); var idDataSet = new UnitDataSet(); idDataSet.U = U; idDataSet.CreateTimeStamps(timeBase_s); sim.SimulateYmeas(ref idDataSet, noiseAmplitude); // do identification FittingSpecs fittingSpecs = new FittingSpecs(designParameters.U0, designParameters.UNorm); UnitModel idModel = UnitIdentifier.Identify(ref idDataSet, fittingSpecs); Plot.FromList(new List<double[]> { idModel.GetFittedDataSet().Y_sim, idModel.GetFittedDataSet().Y_meas, refData.Y_sim, u1, u2 }, new List<string> { \"y1=ysim\", \"y1=ymeas\", \"y1=yref(linear)\", \"y3=u1\", \"y3=u2\" }, (int)timeBase_s, \"NonlinearUnitModelEx\", default); Console.WriteLine(idModel.ToString()); } It can be hard to see with the naked eye that a combination of inputs (U) and output (y) are related non-linearly to another. For this reason, a reference linear model is also simulated and plotted for comparison purposes. The significant difference between ymeas and yref(linear) in the below plot illustrate that the process is significantly non-linear. The resulting figure, containing the dataset, the fitted model and the reference linear model. The output of idModel.ToString() gives details on the model: UnitModel ------------------------- ABLE to identify TimeConstant : 9,22 sec  3,5 TimeDelay : 4 sec ProcessGains(at u0) : 1,97  1,6 -0,0525  0,96 -> Linear Gain : 0,998  1,4 0,77  0,92 -> Curvature Gain : 0,961  0,026 -0,821  0,021 -> u0 : [1.1;1.1] -> uNorm : [1;1] Bias : 0,997  1,3 Results: the estimated bounds of the estimated time-constant contains the actual time-constant(10), the estimated time delay matches the actual value (4), the estimated bound of linear gains contain the actual values [1,0.7] the estimated bound of curvatures contain the actual values [1,-0.8] the estimated bias is close to the actual value (1). Overall, this is example shows a successful use of identification method. Under the hood UnitIdenfier has automatically tested and evaluated a number of different linear/nonlinear and static/dynamic combinations before deciding on the returned nonlinear, dynamic model structure. The major intended design benefit of using UnitIdentifier is that the user is spared the details of this low-level model selection process. Notice that this dataset had three step changes for each of the two inputs, to ensure that the curvatures were identifiable. In cases with less excitation in the dataset, identification could have returned a local linear model, even though the underlying process was nonlinear. This is an unavoidable consequence of lack of excitation in the dataset, that one has to be aware of. The user did not need to specify if the model should be linear or nonlinear, dynamic or static or if the model should have time-delay or not. UnitIdentifier does need a UnitDataSet as input, thus the inputs( U ) and output( y ) need to be specified. Thus UnitIdentifier is not be able to take a general TimeSeriesDataSet that contain any number of un-ordered time-series and produce a general PlantSimulator . This more challenging task will be a topic for later examples."
  },
  "articles/sysid_ex_pid.html": {
    "href": "articles/sysid_ex_pid.html",
    "title": "| TimeSeriesAnalysis reference documentation",
    "keywords": "This example shows how the PidIdentifier class can identify the paramters of a PID-controllers giving only the time-series. The dataset generated is simulated using PlantSimulator , the code of this example: void PidModelId() { // create a PlantSimulator simulated dataset with known paramters double timeBase_s = 1; int N = 200; double noiseAmplitude = 0.1; var pidParameters1 = new PidParameters() { Kp = 0.5, Ti_s = 20 }; UnitParameters modelParameters1 = new UnitParameters { TimeConstant_s = 10, LinearGains = new double[] { 1 }, TimeDelay_s = 5, Bias = 5 }; var processModel1 = new UnitModel(modelParameters1, \"Process1\"); var pidModel1 = new PidModel(pidParameters1, \"PID1\"); var processSim = new PlantSimulator( new List<ISimulatableModel> { pidModel1, processModel1 }); processSim.ConnectModels(processModel1, pidModel1); processSim.ConnectModels(pidModel1, processModel1); var inputData = new TimeSeriesDataSet(); inputData.Add(processSim.AddExternalSignal(pidModel1, SignalType.Setpoint_Yset), TimeSeriesCreator.Step(N / 4, N, 50, 55)); inputData.Add(processSim.AddExternalSignal(processModel1, SignalType.Disturbance_D), TimeSeriesCreator.Noise(N, noiseAmplitude)) ; inputData.CreateTimestamps(timeBase_s); processSim.Simulate(inputData, out TimeSeriesDataSet simData); // do the actual identification var pidDataSet = processSim.GetUnitDataSetForPID(inputData.Combine(simData), pidModel1); var pidId = new PidIdentifier(); var idResult = pidId.Identify(ref pidDataSet); // view results Console.WriteLine(idResult.ToString()); Plot.FromList(new List<double[]> { simData.GetValues(processModel1.GetID(),SignalType.Output_Y), inputData.GetValues(pidModel1.GetID(),SignalType.Setpoint_Yset), simData.GetValues(pidModel1.GetID(),SignalType.PID_U), Array2D<double>.GetColumn(pidDataSet.U_sim,(int)INDEX.FIRST) }, new List<string>{ \"y1=y_sim\", \"y1=y_set\",\"y3=u_pid\",\"y3=u_pid(id)\" },timeBase_s); } The code generates the following figure, showing that the estimated paramters fit the actual PID-output u very well: The output of idResult.ToString() gives details on the model: TimeSeriesAnalysis.Dynamic.PidParameters ------------------------- ABLE to identify Kp : 0,496 Ti : 19,7 sec Td : 0 sec Scaling not given, default values used: Umin : 0 Umax : 100 Ymin : 0 Ymax : 100 NO gainsceduling NO feedforward Note that the estimated parameters Kp=0.496 and Ti_s=19.7 are very close to the actual paramters."
  },
  "articles/sysid_tricks_of_the_trade.html": {
    "href": "articles/sysid_tricks_of_the_trade.html",
    "title": "System identification: tricks of the trade | TimeSeriesAnalysis reference documentation",
    "keywords": "System identification: tricks of the trade While it is true that a static model can be turned into a dynamic model by simply adding a forgetting factor , an industrial implementation of this idea that is numerically robust and is well-behaved enough to either succeed or fail gracefully for any given industrial dataset without human supervision requires a non-trivial bit of additional coding. Based on experience, a number of design choices have been made in the design of UnitModel and UnitIdentifier , these tricks are presented as a numbered list below: base identification on linear regression : choose models that are linear-in-parameters , as you will need to do a large number of identification runs, and linear regression is both fast, robust and easy to analyze. Note that it will still be possible to express nonlinearities, but you avoid the complications of introducing nonlinear optimization solvers . add regularization that will bring parameters to zero in the case the dataset contains no information on this parameter use a robust solver (such as Singular Value Decomposition ,SVD) in combination with regularization, avoid that the parameters will take on extreme values in the case that there is little information on some variables, choose a model structure that is an extension of a linear, static model : the model should be possible to simplify to a normal static, linear model by striking terms - this way there is a fall-back in cases of little information in the data , prune away additive terms that add little to the model : to avoid over-fitting and poor out-of-sample performance, only keep terms in the model where analysis clearly show that model works better with than without the term. In this code, this means: add nonlinearity and time constants through separate additive terms that are linear-in-parameters , this way you can start with a linear static model and compare model performance by adding terms one-at-a-time. keep a set of metrics for assessing the fit : metrics like R-squared and objective function value should be calculated for each run and used to avoid over-complicating a model with term that contribute little or nothing use an objective function on difference form : when identifying a dynamic model, you are likely to get better performance by expressing the objective in terms of the differences between neighboring samples rather than absolute values(or, you can do both!) use estimated parameter confidence intervals to automatically determine if to keep a model term , if the confidence interval of a parameter estimate includes zero, and at value zero the term is stricken, the term can likely be stricken, re-formulate model parameters into the most human-intuitive possible : this might mean that after solving identification with the model structure that is most beneficial for the solver, you re-formulate the model to a form that is more human-readable. This is a core principle in the \"grey-box\" approach - it needs to be possible for humans to easily understand and interpret the models . In our case this means: re-formulate your forgetting factor to time-constant : a forgetting factor is hard to interpret, as it has no dimension. Do parameter conversion to time-constants, which has a time-unit and is easy to interpret, and is often used to tune PID-controllers. re-formulate other factors into \"gains\" : in a dynamic model, the \"gain\" from an input to the output will depend on the forgetting factor, do this conversion so that model \"gains\" can be assessed. add support for removing bad or irrelevant data points throughout : real data has bad or missing data points, and you may want to remove startups/shutdowns or other non-representative data. This means that all your methods for regression and analysis of the result need to support filtering out data points. This is especially important for dynamic identification,as a single bad data point can linger in the internal state of a dynamic model, usually destroying the identification run. creating synthetic datasets to verify your method : if you create a dataset with known parameters and your identification method identifies these correctly, you can have confidence it works. testing needs to be automated : you will need to create hundreds of test datasets to test all aspects and edge cases likely to be encountered in autonomous identification. Tests need to be re-run every time any part of the code is changed, thus it needs to be automatic. time-delay estimation can be brute-forced finding the time delay(an integer) together with continuous parameters creates a mixed-integer problem . Rather than introduce mixed-integer solvers, you can try evaluating the fit of the model for increasing time delays, to see if it improves fit (in effect, solving the mixed-integer problem with an ad-hoc mixed-integer solver.) automate the model structure selection : there is no rule that says you only need to do one identification run for each dataset. If you follow all the above items, turning on and off model terms is easy, you have multiple ways of assessing the model quality of each run and each identification run is cheap computationally. Thus you can automate model selection by re-running identification for different model structures and choose the best, and this process can be automated. It is the joint integration of all of these design choices together that makes for the value proposition of using UnitModel and UnitIdentifier which can enable deploying advanced analytics-methods(which by definition require autonomous or semi-autonomous modeling ) ."
  },
  "articles/unitIdentifier.html": {
    "href": "articles/unitIdentifier.html",
    "title": "The UnitIdentifier - identification of UnitModels | TimeSeriesAnalysis reference documentation",
    "keywords": "The UnitIdentifier - identification of UnitModels The UnitIdentifier is based on the idea of starting with a static linear regression models and to by trial-and-error add in additional terms in the model given that it doing so improves the fit of the model by given criteria. This approach is based on the recommended work-flow in the field of system identification. The idea is to automate the work-flow of selecting the best model structure in the set of model structures supported by the UnitModel . Note There is a chance of over-fitting if a model has too many parameters, thus it is not always given that adding in more terms is better, in fact doing so can degrade model performance. First run Identification starts with finding a linear static model, which acts as a reference against which all subsequent identification runs is to be compared. Note If the linear,static fit between the output and the given inputs does not at least broadly follow the measured output, then adding nonlinearities time-delays or time-constants rarely if ever is meaningful. Time constant and bias The solver solves for terms [a,b,c] jointly. The objective function is formulated in terms of differences , finding the parameters which produce the minimum sum of square differences sum_{k=2}^N(y[k]-y[k-1])^2 . Because the optimization problem of finding [a,b,c,q,t_d] requires solving a difference equation and the solver looks at difference between subsequent data points, the formulation favors estimating [a,b,c,] , but at the expense of the value of the bias q . Thus once the parameters [a,b,c,] which express the dynamics are found, the bias q is found in a subsequent calculation UnitIdentifier.ReEstimateBias() to minimize the overall difference between measured and modeled outputs y . Nonlinear terms UnitIdentifier will first try finding a model that is linear in inputs u, it will then re-solve the identification for every combination possible of curvatures for each input turned on/off, and chooses a model with one or more nonlinear terms if it results in a higher R-squared and a lower value of the objective function. To avoid over-fitting, a model with more nonlinear terms is only selected over a less complicated model if the improvement in objective function and R-squared is significant , i.e. over a threshold. Time delay Determining [a,b,c,q,t_d] can be expressed as a linear mixed-integer problem. If the integer term t_d is given, then determining the continuous parameters [a,b,c,q] is a linear optimization problem. The solver UnitIdentifier takes a sequential approach to solving the joint estimation problem. It solves for the continuous parameters starting at zero time delay and then for ever-increasing time-delays identifies and compares, until the logic determines that attempting to solve for larger time delays is not necessary. The solver then selects the best time delay and the associated continuous parameters. This logic is implemented in the class ProcessTimeDelayIdentifier . Flow of solver The flow of the solver is as below: start at zero time delay t_d , while( TimeDelay object says to continue ), solve the model with no curvatures c=0 Solve for [a,b,c,] with every combination of curvatures on/off for a given t_d , for each given [a,c,d,t_q] find the bias q , choose the best model of the above for the given time delay save the best model run for the given time-delay in the `TimeDelay`` class object, and increase time delay. TimeDelay object chooses the best model run out of all the saved runs. Note The solver may thus run tens or hundreds separate identifications with different model terms turned on/off for each run of the UnitModelIdentifier , but without requiring any user-interaction."
  },
  "contributing.html": {
    "href": "contributing.html",
    "title": "Contributing | TimeSeriesAnalysis reference documentation",
    "keywords": "Contributing This project welcomes contributions and suggestions. We believe in collaboration. Collaboration with developers and users, vendors and educational institutions, partners and competitors. Within and outside our industry. Contribution code-of-conduct When contributing to this repository, please first discuss the change you wish to make via issue, or by the GitHub discussions forum, or any other method with the owners of this repository before making a change. Proposed code changes to this project should be submitted for review as pull requests. Pull request Requirements for pull requests: should follow the coding convention below pull request should only address a single feature/issue, all existing tests should pass, any new feature should be supported by at least one new unit test, that both shows that the new feature works and documents how to use the new feature, consider using TestCase to re-run a new unit test for more than one set of input parameters (remember: testing edge-cases and testing the negative.) the submitter must be available for questions of the reviewer, and for complex methods such as those related to filtering, dynamic models or PID-control, unit tests should use the Plot4Test class to plot the time-series that illustrate the test data sets used and the results of any new calculation. It is much easier to understand capability visually both for code review but also for other users. Code to plot the time-series should be available in the code, but should either be disabled with logic by default or commented out, this is to avoid swamping the user with plots if re-running all tests. Avoiding feature-creep: not an encyclopedia of every possible method The more code this repository has, the more time it will take to maintain it and the more things that can go wrong. An important part of Lean is \"maximizing the work not done\" - we want to apply this idea to this repository as well, or \"just because something can be added, does not mean it should \". This repository should not become an encyclopedia of everything time-series related. It is hard to give absolute rules, but some guidelines to consider before proposing to add new functionality to this class library: If the functionality is useful on its own, could the functionality instead be a stand-alone repository and NuGet package? If the stand-alone functionality already exists on NuGet in another repository, it is probably better for users to just pull in that package. If the new feature does a task like process modeling, filtering or PID-control in a different way than what the repository already does, there should be a clear benefit of the new approach in terms of performance or features . This repository is aimed toward industrial applications , so esoteric methods(i.e. of specicial, rare or unusual interest) that have academic interest but lack proven practical benefit on real-world data from real-world systems are better left outside this package. If the new feature builds on top of existing functionality it could be interesting to add in, but only if it is generally applicable methodology with practical and industrial use-cases. What kind of contributions? Reporting issues If you during the use of this library discover that something is not working, you are encouraged to report it as an issue in the github issues page. If you can propose how to fix it that increases the likelihood it will be fixed. If you have made a fix that you would like to propse be merged in, make a push request. Data mining/ advanced analytics methods that build on top of existing methods If you would like to contribute on this, this is very welcome. Developing the repository in this direction is on the roadmap toward versions 2.x . Benchmarking and academic comparisons If you would like to compare and benchmark other methods in this project, such as the PID-controller or system identification, that would be much appreciated (even if the other methods you tried appear to be better). For academic use, this project could be used as a reference for academics who are developing their own methods. Expanding on the (dynamic) system-identification tool set Do you have a great idea for how better to identify models for dynamic systems? If you would like to contribute your own method into the tool set, that sort of method is much appreciated. Coding convention All code should follow conventional C# naming conventions, please refer to https://learn.microsoft.com/en-us/dotnet/standard/design-guidelines/naming-guidelines , this includes using camelCase or PascalCase as appropriate for varibale names, and names of variables and classes should prioritize readability over brevity, and not include abbreviations or underscores name new classes and variables in ways that are consistent with the names already used. all unit tests should follow the naming convention MethodName_StateUnderTest_ExpectedBehavior or for simple classes StateUnderTest_ExpectedBehavior Organize code so that others can easily undertand, maintain and extend it: Favor smaller classes and methods that have a single specific purpose, clearly expressed in the name. Use unit test framework during development, and keep tests in project as part of documentation and as a \"fail-safe\" mechanism for other developers To understand how code works, how it is called and what it should do, refer to the tests When re-writing functionality, unit-tests are important fail-safe to check that nothing is broken. Unit tests are important for refactoring. Unit tests need to be quick, so that they can be run frequently without hurting developer output. During development, it is advised to use the Plot.FromList() to plot time-series together, but care should be taken to not check in code that will cause plotting."
  },
  "readme.html": {
    "href": "readme.html",
    "title": "TimeSeriesAnalysis : Data-driven dynamic modeling and simulation | TimeSeriesAnalysis reference documentation",
    "keywords": "TimeSeriesAnalysis : Data-driven dynamic modeling and simulation Overview This library that deals with developing time-series models and simulators from time-series data . The methods in this library are primarily designed to describe time-series of physical, real-world systems for an industrial setting. Real-world industrial systems often exhibit repeatable transient responses to changes in inputs usually include feeback loops , either due to recirculation in the process or because the system is controlled with PID-controllers (PID-model is included) and often consist of a network of interconnected units that interact. This library was designed to create dynamic unit models that can be chained into interconnected networks that can include PID-control or other feedback- or circulation loops. Models are not derived from physical first principles, but are inferred from time-series data using the principles of system identification , the methods to infer models are built on multiple modfied linear regression steps(identification methods are included). The library is written in C# but can be referenced from any language that can reference .NET language, including Matlab or Python. The target framework is .NET Standard 2.0. Use cases: Digital twins, anomaly detection, \"what-if\", PID-tuning, monitoring and screening The power of this library lies in the ability to automate or semi-automate the steps of identfiying new models or simulating existing models at scale. In effect this libary can create \"digital twin\" models of sections of a process. The methods lend themselves readily to for instance automatically building a large number of similar models for similar sections of a process, for instance to monitor every valve, separation tank or PID-control loop in a similar fashion, in a way that lends itself to process monitoring and -screening. The methods in this library are scalable and modular , i.e. by chaining together unit models, the library can also simulate larger sections of a process plant, so the methodology could in principle be extended to assemble a digital twin of an entire process plant. Models can be run alongside the plant, and monitoring the difference between measured and modelled values can provide insight into changes in the plant (anomaly detection.) By manually simulating changes on these kinds of models, \"what-if\" scenarios can be evaluted either manually or automatically. One very interesting such use-case is to evaluate the possible benefits of re-tuning PID-controllers. The above use-cases could be put under the umbrella term \"advanced analytics\", i.e. using algorithms and data to make deep insights about causes and effects to make predictions and reccomendations. Explainable models for low-information datasets Note that although this library uses regression methods and algorithms to learn parameters to describe data, the methodology is somewhat different from traditional machine learning in that models follow the principles of system identification rather than AI. The number of free parameters are kept low by design, as this makes reduces the likelihood of over-fitting. Over-fitting is particularly important when dealing with industrial data, as this kind of data has to be used \"as-is\" and one often has less information than one would like. Another benefit of keepting the number of fitted paramters low is that models remain explainable and human-understandable, and it becomes possible to combine fitted models with human pre-knowledge, what is often referred to as \"grey-box\" modeling. Documentation:  TimeSeriesAnalysis documentation   TimeSeriesAnalysis API documentation  Roadmap The aim of this repository is to collect building blocks to developing digital twins from datasets in a manner that can be automated. This repository development in versions 1.x , is focused on \"getting the basics right\" defining a set of unit models that together can simulate most industrial processes (especially PidModel and UnitModel ), establishing unit identification methods for each unit model type, and efficent simulation of \"plants\" of unit models Contributing This project welcomes contributions and suggestions. Please read CONTRIBUTING.md for details on our code of conduct, and the process for submitting pull requests. Getting started Regardless if you call this library from C#, Python or Matlab, the resulting code is very similar. A good first step is to read through the getting started examples and try copying in that code and getting it to run to get the hang of things Calling this library from Python The library can be conveniently used from Python grab the zipped binaries from a release and unzip set up Python.Net , start calling the API-methods (see help article Getting started:Python .) Calling this library from MatLab The library be conveniently used from Matlab grab the zipped binaries from a release and unzip load the assembly with NET.addAssembly() start calling the API (see article Getting started:Matlab .) Calling this library from your .NET project create a project in Visual Studio, and import the \"TimeSeriesAnalysis\" library from NuGet start calling the API Working with the code of this repository check out this repository, make sure NuGet is setup correctly, and all examples are implemented as unit-tests using NUnit, try running these to Discussion forum and contact person The contact person for this repository is Steinar Elgster, please post any question you may have related to TimeSeriesAnalysis in the github discussion pages . License TimeSeriesAnalysis is distributed under the Apache 2.0 license ."
  },
  "SECURITY.html": {
    "href": "SECURITY.html",
    "title": "Security Policy | TimeSeriesAnalysis reference documentation",
    "keywords": "Security Policy If you discover a security vulnerability in this project, please follow these steps to responsibly disclose it: Do not create a public GitHub issue for the vulnerability. Follow our guideline for Responsible Disclosure Policy at https://www.equinor.com/about-us/csirt to report the issue The following information will help us triage your report more quickly: Type of issue (e.g. buffer overflow, SQL injection, cross-site scripting, etc.) Full paths of source file(s) related to the manifestation of the issue The location of the affected source code (tag/branch/commit or direct URL) Any special configuration required to reproduce the issue Step-by-step instructions to reproduce the issue Proof-of-concept or exploit code (if possible) Impact of the issue, including how an attacker might exploit the issue We prefer all communications to be in English."
  }
}