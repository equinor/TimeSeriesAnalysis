{
  "api/index.html": {
    "href": "api/index.html",
    "title": "PLACEHOLDER | TimeSeriesAnalysis reference documentation",
    "keywords": "PLACEHOLDER TODO: Add .NET projects to the src folder and run docfx to generate REAL API Documentation !"
  },
  "api/TimeSeriesAnalysis.Array2D.html": {
    "href": "api/TimeSeriesAnalysis.Array2D.html",
    "title": "Class Array2D | TimeSeriesAnalysis reference documentation",
    "keywords": "Class Array2D Non-generic 2D-array methods Inheritance System.Object Array2D Inherited Members System.Object.ToString() System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.ReferenceEquals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() Namespace : TimeSeriesAnalysis Assembly : TimeSeriesAnalysis.dll Syntax public static class Array2D Methods GetColumnParsedAsDateTime(String[,], Int32, String) Parses a column of strings in an array/matrix of strings Declaration public static DateTime[] GetColumnParsedAsDateTime(this string[, ] matrix, int columnNumber, string dateFormat) Parameters Type Name Description System.String [,] matrix a 2D-aray of strings System.Int32 columnNumber the index of the column to parse System.String dateFormat the DateTime dateformat,For the format of dateFormat, see https://docs.microsoft.com/en-us/dotnet/standard/base-types/custom-date-and-time-format-strings Returns Type Description System.DateTime []"
  },
  "api/TimeSeriesAnalysis.Array2D-1.html": {
    "href": "api/TimeSeriesAnalysis.Array2D-1.html",
    "title": "Class Array2D<T> | TimeSeriesAnalysis reference documentation",
    "keywords": "Class Array2D<T> Generic array operations that can be done on arrays of any type, for operators specific to numerical arrays(matrices) see Matrix.cs Inheritance System.Object Array2D<T> Inherited Members System.Object.ToString() System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.ReferenceEquals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() Namespace : TimeSeriesAnalysis Assembly : TimeSeriesAnalysis.dll Syntax public class Array2D<T> Type Parameters Name Description T Methods Convert2DtoJagged(T[,]) converts a 2d array into a jagged array Declaration public static T[][] Convert2DtoJagged(T[, ] matrix) Parameters Type Name Description T[,] matrix Returns Type Description T[][] GetColumn(T[][], Int32) returns the column of the matrix with the given index Declaration public static T[] GetColumn(T[][] matrix, int columnNumber) Parameters Type Name Description T[][] matrix System.Int32 columnNumber Returns Type Description T[] GetColumn(T[,], Int32) returns the column of the matrix with the given index Declaration public static T[] GetColumn(T[, ] matrix, int columnNumber) Parameters Type Name Description T[,] matrix System.Int32 columnNumber Returns Type Description T[] GetColumns(T[,], Int32[]) returns all the columns correspoding to columnNumbers in a 2d-array Declaration public static T[, ] GetColumns(T[, ] matrix, int[] columnNumbers) Parameters Type Name Description T[,] matrix System.Int32 [] columnNumbers Returns Type Description T[,] GetRow(T[,], Int32) returns the row of the matrix with the given index as an vector Declaration public static T[] GetRow(T[, ] matrix, int rowNumber) Parameters Type Name Description T[,] matrix System.Int32 rowNumber Returns Type Description T[] InitFromColumnList(List<T[]>) Initializes a 2D array from a list of arrays representing each column in the array Declaration public static T[, ] InitFromColumnList(List<T[]> columnList) Parameters Type Name Description System.Collections.Generic.List <T[]> columnList Returns Type Description T[,] null if list columnList dimensions do not match Transpose(T[,]) transposes a 2d-array (rows are turned into columns and vice versa) Declaration public static T[, ] Transpose(T[, ] matrix) Parameters Type Name Description T[,] matrix Returns Type Description T[,]"
  },
  "api/TimeSeriesAnalysis.Array2DExtensionMethods.html": {
    "href": "api/TimeSeriesAnalysis.Array2DExtensionMethods.html",
    "title": "Class Array2DExtensionMethods | TimeSeriesAnalysis reference documentation",
    "keywords": "Class Array2DExtensionMethods Extension methods based on Array2D Inheritance System.Object Array2DExtensionMethods Inherited Members System.Object.ToString() System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.ReferenceEquals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() Namespace : TimeSeriesAnalysis Assembly : TimeSeriesAnalysis.dll Syntax public static class Array2DExtensionMethods Methods Convert2DtoJagged(Double[,]) Converts a 2d-array to a jagged array Declaration public static double[][] Convert2DtoJagged(this double[, ] matrix) Parameters Type Name Description System.Double [,] matrix Returns Type Description System.Double [][] GetColumn(Double[,], Int32) returns the column of a 2d-array of doubles corresponding to columnIndex(starts at zero) Declaration public static double[] GetColumn(this double[, ] matrix, int columnIndex) Parameters Type Name Description System.Double [,] matrix System.Int32 columnIndex Returns Type Description System.Double [] GetColumn(String[,], Int32) returns the column of a 2d-array of strings corresponding to columnIndex(starts at zero) Declaration public static string[] GetColumn(this string[, ] matrix, int columnIndex) Parameters Type Name Description System.String [,] matrix System.Int32 columnIndex Returns Type Description System.String [] GetColumnParsedAsDateTime(String[,], Int32, String) Parses a column in a 2d-array and returns the results as a vector of date-times. Declaration public static DateTime[] GetColumnParsedAsDateTime(this string[, ] matrix, int columnNumber, string dateFormat) Parameters Type Name Description System.String [,] matrix System.Int32 columnNumber System.String dateFormat Returns Type Description System.DateTime [] GetColumns(Double[,], Int32[]) Returns the columns corresponding to columnNumbers as a 2d-array Declaration public static double[, ] GetColumns(this double[, ] matrix, int[] columnNumbers) Parameters Type Name Description System.Double [,] matrix System.Int32 [] columnNumbers Returns Type Description System.Double [,] GetNColumns(Double[][]) Get number of columns Declaration public static int GetNColumns(this double[][] matrix) Parameters Type Name Description System.Double [][] matrix Returns Type Description System.Int32 GetNColumns(Double[,]) Return the number of columns of a 2d-matrix Declaration public static int GetNColumns(this double[, ] matrix) Parameters Type Name Description System.Double [,] matrix Returns Type Description System.Int32 GetNRows(Double[][]) Get nubmer of rows Declaration public static int GetNRows(this double[][] matrix) Parameters Type Name Description System.Double [][] matrix Returns Type Description System.Int32 GetNRows(Double[,]) Return the number of rows of a 2d-matrix Declaration public static int GetNRows(this double[, ] matrix) Parameters Type Name Description System.Double [,] matrix Returns Type Description System.Int32 GetRow(Double[,], Int32) returns the row of a 2d-array of doubles corresponding to columnIndex(starts at zero) Declaration public static double[] GetRow(this double[, ] matrix, int rowNumber) Parameters Type Name Description System.Double [,] matrix System.Int32 rowNumber Returns Type Description System.Double [] GetRow(String[,], Int32) returns the row of a 2d-array of strings corresponding to columnIndex(starts at zero) Declaration public static string[] GetRow(this string[, ] matrix, int rowNumber) Parameters Type Name Description System.String [,] matrix System.Int32 rowNumber Returns Type Description System.String [] GetRowsAfterIndex(DateTime[], Int32) Returns rows starting with rowIndex and onwards Declaration public static DateTime[] GetRowsAfterIndex(this DateTime[] array, int rowIndex) Parameters Type Name Description System.DateTime [] array System.Int32 rowIndex Returns Type Description System.DateTime [] GetRowsAfterIndex(Double[], Int32) Returns rows starting with rowIndex and onwards Declaration public static double[] GetRowsAfterIndex(this double[] array, int rowIndex) Parameters Type Name Description System.Double [] array System.Int32 rowIndex Returns Type Description System.Double [] GetRowsAfterIndex(Double[,], Int32) Returns rows starting with rowIndex and onwards Declaration public static double[, ] GetRowsAfterIndex(this double[, ] array, int rowIndex) Parameters Type Name Description System.Double [,] array System.Int32 rowIndex Returns Type Description System.Double [,] Transpose(Double[,]) Transposes a 2d-matrix. Declaration public static double[, ] Transpose(this double[, ] matrix) Parameters Type Name Description System.Double [,] matrix Returns Type Description System.Double [,] WriteColumn(Double[,], Int32, Double[]) overwrites the columin in matrix with the new column newColumnValues Declaration public static double[, ] WriteColumn(this double[, ] matrix, int colIdx, double[] newColumnValues) Parameters Type Name Description System.Double [,] matrix System.Int32 colIdx System.Double [] newColumnValues Returns Type Description System.Double [,]"
  },
  "api/TimeSeriesAnalysis.Dynamic.BandPass.html": {
    "href": "api/TimeSeriesAnalysis.Dynamic.BandPass.html",
    "title": "Class BandPass | TimeSeriesAnalysis reference documentation",
    "keywords": "Class BandPass Numerical band-pass filter based on LowPass This filter is in a recursive(feedback) IIR form that is simple to implement, has few coefficients, requires litte memory and computation. This filter is causal, meaning that for calculating the filtered value at time k it does not use future values such as k+1 , but this is at the expense of introducing a time-shift/phase-shift. LowPass HighPass MovingAvg Inheritance System.Object BandPass Inherited Members System.Object.ToString() System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.ReferenceEquals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() Namespace : TimeSeriesAnalysis.Dynamic Assembly : TimeSeriesAnalysis.dll Syntax public class BandPass Constructors BandPass(Double, Double) Declaration public BandPass(double TimeBase_s, double nanValue = -9999) Parameters Type Name Description System.Double TimeBase_s System.Double nanValue value to be treated as NaN Methods Filter(Double, Double, Double, Int32, Boolean) Adds a single data point to the filter Declaration public double Filter(double signal, double lpFilterTc_s, double hpFilterTc_s, int order = 1, bool doReset = false) Parameters Type Name Description System.Double signal data point System.Double lpFilterTc_s low-passfilter time constant in seconds System.Double hpFilterTc_s high-passfilter time constant in seconds System.Int32 order filter order, either 1 or 2 is supported System.Boolean doReset usually false, setting to true causes filter to reset to the value of signal Returns Type Description System.Double Filter(Double[], Double, Double, Int32) Filter an entire time-series in one command Declaration public double[] Filter(double[] signal, double lpFilterTc_s, double hpFilterTc_s, int order = 1) Parameters Type Name Description System.Double [] signal the vector of the entire time-series to be filtered System.Double lpFilterTc_s filter time constant System.Double hpFilterTc_s filter time constant System.Int32 order filter order, either 1 or 2 Returns Type Description System.Double [] a vector of the filtered time-series"
  },
  "api/TimeSeriesAnalysis.Dynamic.ConnectionParser.html": {
    "href": "api/TimeSeriesAnalysis.Dynamic.ConnectionParser.html",
    "title": "Class ConnectionParser | TimeSeriesAnalysis reference documentation",
    "keywords": "Class ConnectionParser Class that tracks which model is connected to which in a set of models. This is important when traversing the models when simulating with the ProcessSimulator , as these models need to be run in a specific order Inheritance System.Object ConnectionParser Inherited Members System.Object.ToString() System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.ReferenceEquals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() Namespace : TimeSeriesAnalysis.Dynamic Assembly : TimeSeriesAnalysis.dll Syntax public class ConnectionParser Constructors ConnectionParser() Constructor Declaration public ConnectionParser() Methods AddAllModelObjects(Dictionary<String, ISimulatableModel>) Adds a list of all the model IDs that make up a process simulation Declaration public void AddAllModelObjects(Dictionary<string, ISimulatableModel> allModels) Parameters Type Name Description System.Collections.Generic.Dictionary < System.String , ISimulatableModel > allModels AddConnection(String, String) Adds a connection betweent the models with the given IDs Declaration public void AddConnection(string upstreamID, string downstreamID) Parameters Type Name Description System.String upstreamID System.String downstreamID DetermineCalculationOrderOfModels() Determine the order in which the models must be solved Declaration public List<string> DetermineCalculationOrderOfModels() Returns Type Description System.Collections.Generic.List < System.String > returns the string of sorted model IDs, the order in which modelDict models are to be run GetDownstreamModelIDs(String) Get all the models which are connected to a given model one level directly downstream of it Declaration public List<string> GetDownstreamModelIDs(string modelID) Parameters Type Name Description System.String modelID Returns Type Description System.Collections.Generic.List < System.String > GetModelsWithNoUpstreamConnections() Gets all the models that do not have any models upstream of them. (models are then either signal generators or get their input from external signals) Declaration public List<string> GetModelsWithNoUpstreamConnections() Returns Type Description System.Collections.Generic.List < System.String > GetUpstreamModels(String) Get all the models which are connected to a given model one level directly upstream of it Declaration public List<string> GetUpstreamModels(string modelID) Parameters Type Name Description System.String modelID Returns Type Description System.Collections.Generic.List < System.String > GetUpstreamPIDId(String) Get the ID of the PID-controller that is upstream a given modelID Declaration public string GetUpstreamPIDId(string modelID) Parameters Type Name Description System.String modelID Returns Type Description System.String HasUpstreamPID(String) Query if the model has an upstream PID-model. Declaration public bool HasUpstreamPID(string modelID) Parameters Type Name Description System.String modelID Returns Type Description System.Boolean"
  },
  "api/TimeSeriesAnalysis.Dynamic.DefaultProcessModel.html": {
    "href": "api/TimeSeriesAnalysis.Dynamic.DefaultProcessModel.html",
    "title": "Class DefaultProcessModel | TimeSeriesAnalysis reference documentation",
    "keywords": "Class DefaultProcessModel Simulatable \"default\" process model. This is a model that can be either dynamic or static, have one or multiple inputs and can be either linear in inputs or have inputs nonlinearity described by a polynominal. Dynamics can be either 1.order time-constant, time-delay or both. The model also supports \"additive\" signals added to its output(intended for modeling disturbances.) The model is designed to lend itesel well to identificaiton from industrial time-series datasets, and is supported by the accompanying identificaiton method DefaultProcessModelIdentifier . This model is also intended to be co-simulated with PIDModel by ProcessSimulator to study process control feedback loops. It is assumed that for most unit processes in industrial process control systems can be described sufficiently by this model, and thus that larger plants can be modeled by connecting unit models based on this model structure. It would be possible to extend this model to also describe second-order dynamics along the same principles by the intorduction of one additional paramters in future work. DefaultProcessModelParameters DefaultProcessModelIdentifier PIDModel ProcessSimulator Inheritance System.Object ModelBaseClass DefaultProcessModel Implements ISimulatableModel Inherited Members ModelBaseClass.GetID() ModelBaseClass.SetID(String) ModelBaseClass.SetProcessModelType(ProcessModelType) ModelBaseClass.GetProcessModelType() ModelBaseClass.SetInputIDs(String[], Nullable<Int32>) ModelBaseClass.AddSignalToOutput(String) ModelBaseClass.GetModelInputIDs() ModelBaseClass.GetAdditiveInputIDs() ModelBaseClass.GetBothKindsOfInputIDs() ModelBaseClass.SetOutputID(String) ModelBaseClass.GetOutputID() System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.ReferenceEquals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() Namespace : TimeSeriesAnalysis.Dynamic Assembly : TimeSeriesAnalysis.dll Syntax public class DefaultProcessModel : ModelBaseClass, ISimulatableModel Constructors DefaultProcessModel(DefaultProcessModelParameters, Double, String) Constructor Declaration public DefaultProcessModel(DefaultProcessModelParameters modelParameters, double timeBase_s, string ID = \"not_named\") Parameters Type Name Description DefaultProcessModelParameters modelParameters model paramter object System.Double timeBase_s the timebase in seconds, the time interval between samples and between calls to Iterate System.String ID a unique string that identifies this model in larger process models DefaultProcessModel(DefaultProcessModelParameters, SubProcessDataSet) Initalizer of model that for the given dataSet also creates the resulting y_sim Declaration public DefaultProcessModel(DefaultProcessModelParameters modelParameters, SubProcessDataSet dataSet) Parameters Type Name Description DefaultProcessModelParameters modelParameters SubProcessDataSet dataSet Properties FittedDataSet Declaration public SubProcessDataSet FittedDataSet { get; } Property Value Type Description SubProcessDataSet TimeDelayEstWarnings Declaration public List<ProcessTimeDelayIdentWarnings> TimeDelayEstWarnings { get; } Property Value Type Description System.Collections.Generic.List < ProcessTimeDelayIdentWarnings > Methods GetLengthOfInputVector() Returns the number of external inputs U of the model. Note that this model may have an disturbance signal added to the output in addition to the other signals. Declaration public override int GetLengthOfInputVector() Returns Type Description System.Int32 Overrides ModelBaseClass.GetLengthOfInputVector() GetModelParameters() Get the objet of model paramters contained in the model Declaration public DefaultProcessModelParameters GetModelParameters() Returns Type Description DefaultProcessModelParameters Model paramter object GetOutputSignalType() Get the type of output signal Declaration public override SignalType GetOutputSignalType() Returns Type Description SignalType Overrides ModelBaseClass.GetOutputSignalType() GetSteadyStateInput(Double, Int32, Double[]) Calcuate the steady-state input if the output and all-but-one input are known Declaration public double? GetSteadyStateInput(double y0, int inputIdx = 0, double[] givenInputs = null) Parameters Type Name Description System.Double y0 System.Int32 inputIdx System.Double [] givenInputs Returns Type Description System.Nullable < System.Double > GetSteadyStateOutput(Double[]) Get the steady state output y for a given input Declaration public double? GetSteadyStateOutput(double[] u0) Parameters Type Name Description System.Double [] u0 Returns Type Description System.Nullable < System.Double > IsModelStatic() Is the model static or dynamic? Declaration public bool IsModelStatic() Returns Type Description System.Boolean Returns true if the model is static(no time constant or time delay terms),otherwise false. Iterate(Double[], Double) Iterates the process model state one time step, based on the inputs given Declaration public double Iterate(double[] inputs, double badValueIndicator = -9999) Parameters Type Name Description System.Double [] inputs vector of inputs U. Optionally the output disturbance D can be added as the last value. System.Double badValueIndicator value in U that is to be treated as NaN Returns Type Description System.Double the updated process model state(x) - the output without any output noise or disturbance. NaN is returned if model was not able to be identfied, or if no good values U values yet have been given. If some data points in U inputsU are NaN or equal to badValueIndicator , the last good value is returned SolveQuadratic(Double, Double, Double) Sovel quadratic equation \"a x^2 + b*x +c =0\" (second order of polynomial equation in a single variable x) x = [ -b +/- sqrt(b^2 - 4ac) ] / 2a Declaration public static double[] SolveQuadratic(double a, double b, double c) Parameters Type Name Description System.Double a System.Double b System.Double c Returns Type Description System.Double [] ToString() Create a nice human-readable summary of all the important data contained in the model object. This is especially useful for unit-testing and development. Declaration public override string ToString() Returns Type Description System.String Overrides System.Object.ToString() WarmStart(Double[], Double) Warm-starting(not implemented) Declaration public void WarmStart(double[] inputs, double output) Parameters Type Name Description System.Double [] inputs System.Double output Implements ISimulatableModel"
  },
  "api/TimeSeriesAnalysis.Dynamic.DefaultProcessModelIdentifier.html": {
    "href": "api/TimeSeriesAnalysis.Dynamic.DefaultProcessModelIdentifier.html",
    "title": "Class DefaultProcessModelIdentifier | TimeSeriesAnalysis reference documentation",
    "keywords": "Class DefaultProcessModelIdentifier Identifier of the \"Default\" process model - a dynamic process model with time-constant, time-delay, linear process gain and optional (nonlinear)curvature process gains. This model class is sufficent for real-world linear or weakly nonlinear dynamic systems, yet also introduces the fewest possible parameters to describe the system in an attempt to avoiding over-fitting/over-parametrization The \"default\" process model is linear-in-paramters, so that it can be solved by linear regression and identification should thus be both fast and stable. Time-delay is an integer parameter, and finding the time-delay alongside continous paramters turns the identification problem into a linear mixed-integer problem. The time delay identification is done by splitting the time-delay estimation from continous parameter identification, turning the solver into a sequential optimization solver. This logic to re-run estimation for multiple time-delays and selecting the best estiamte of time delay is deferred to ProcessTimeDelayIdentifier TimeSeriesAnalysis.Dynamic.ProcessTimeDelayIdentifier Inheritance System.Object DefaultProcessModelIdentifier Inherited Members System.Object.ToString() System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.ReferenceEquals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() Namespace : TimeSeriesAnalysis.Dynamic Assembly : TimeSeriesAnalysis.dll Syntax public class DefaultProcessModelIdentifier Constructors DefaultProcessModelIdentifier() Default Constructor Declaration public DefaultProcessModelIdentifier() Methods Identify(ref SubProcessDataSet, Double[]) Identifies the \"Default\" process model that best fits the dataSet given Declaration public DefaultProcessModel Identify(ref SubProcessDataSet dataSet, double[] u0 = null) Parameters Type Name Description SubProcessDataSet dataSet The dataset containing the ymeas and U that is to be fitted against, a new y_sim is also added System.Double [] u0 Optionally sets the local working point for the inputs around which the model is to be designed(can be set to null ) Returns Type Description DefaultProcessModel the identified model parameters and some information about the fit"
  },
  "api/TimeSeriesAnalysis.Dynamic.DefaultProcessModelParameters.html": {
    "href": "api/TimeSeriesAnalysis.Dynamic.DefaultProcessModelParameters.html",
    "title": "Class DefaultProcessModelParameters | TimeSeriesAnalysis reference documentation",
    "keywords": "Class DefaultProcessModelParameters Parameters data class of the DefaultProcessModel Inheritance System.Object ModelParametersBaseClass DefaultProcessModelParameters Inherited Members ModelParametersBaseClass.WasAbleToIdentify ModelParametersBaseClass.FittingRsq ModelParametersBaseClass.FittingObjFunVal ModelParametersBaseClass.NFittingBadDataPoints ModelParametersBaseClass.NFittingTotalDataPoints ModelParametersBaseClass.GetFittingR2() ModelParametersBaseClass.GetFittingObjFunVal() ModelParametersBaseClass.AbleToIdentify() System.Object.ToString() System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.ReferenceEquals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() Namespace : TimeSeriesAnalysis.Dynamic Assembly : TimeSeriesAnalysis.dll Syntax public class DefaultProcessModelParameters : ModelParametersBaseClass Constructors DefaultProcessModelParameters() Declaration public DefaultProcessModelParameters() Fields SolverID Declaration public string SolverID Field Value Type Description System.String Y_max the maximum allowed output value(if set to NaN, no maximum is applied) Declaration public double Y_max Field Value Type Description System.Double Y_min The minimum allowed output value(if set to NaN, no minimum is applied) Declaration public double Y_min Field Value Type Description System.Double Properties Bias The constant bias that is added so that models and dataset match on average, this value will depend on U0 and other parameters. Declaration public double Bias { get; set; } Property Value Type Description System.Double Curvatures The nonlinear curvature of the process gain, this paramter is multiplied + Curvatures*((u-u0)/Unorm)^2. If value is null c> then no curvatures are added to the model Declaration public double[] Curvatures { get; set; } Property Value Type Description System.Double [] ProcessGains An array of gains that determine how much in the steady state each input change affects the output(multiplied with (u-u0)) Declaration public double[] ProcessGains { get; set; } Property Value Type Description System.Double [] TimeConstant_s A time constant in seconds, the time a 1. order linear system requires to do 63% of a step response. Set to zero to turn off time constant in model. Declaration public double TimeConstant_s { get; set; } Property Value Type Description System.Double TimeDelay_s The time delay in seconds.This number needs to be a multiple of the sampling rate. Set to zero to turn of time delay in model. Declaration public double TimeDelay_s { get; set; } Property Value Type Description System.Double U0 The working point of the model, the value of each U around which the model is localized. If value is null c> then no U0 is used in the model Declaration public double[] U0 { get; set; } Property Value Type Description System.Double [] UNorm A \"normal range\" of U that is used in the nonlinear curvature term ((u-u0)/Unorm)^2. If value is null c> then no Unorm is used in the model Declaration public double[] UNorm { get; set; } Property Value Type Description System.Double [] Methods AddWarning(ProcessIdentWarnings) Declaration public void AddWarning(ProcessIdentWarnings warning) Parameters Type Name Description ProcessIdentWarnings warning GetWarningList() Declaration public List<ProcessIdentWarnings> GetWarningList() Returns Type Description System.Collections.Generic.List < ProcessIdentWarnings >"
  },
  "api/TimeSeriesAnalysis.Dynamic.HighPass.html": {
    "href": "api/TimeSeriesAnalysis.Dynamic.HighPass.html",
    "title": "Class HighPass | TimeSeriesAnalysis reference documentation",
    "keywords": "Class HighPass A high-pass recursive time-series filter based on LowPass . This filter is in a recursive(feedback) IIR form that is simple to implement, has few coefficients, requires litte memory and computation. This filter is causal, meaning that for calculating the filtered value at time k it does not use future values such as k+1 , but this is at the expense of introducing a time-shift/phase-shift. LowPass BandPass MovingAvg Inheritance System.Object HighPass Inherited Members System.Object.ToString() System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.ReferenceEquals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() Namespace : TimeSeriesAnalysis.Dynamic Assembly : TimeSeriesAnalysis.dll Syntax public class HighPass Constructors HighPass(Double, Double) Constructor Declaration public HighPass(double TimeBase_s, double nanValue = -9999) Parameters Type Name Description System.Double TimeBase_s time base/sampling time in seconds of data to be fed filter System.Double nanValue value of input signal to be ignored/treated as NaN Methods Filter(Double, Double, Int32, Boolean) Adds a single data point to the filter Declaration public double Filter(double signal, double FilterTc_s, int order = 1, bool doReset = false) Parameters Type Name Description System.Double signal data point System.Double FilterTc_s filter time constant in seconds System.Int32 order filter order, eitehr 1 or 2 is supported System.Boolean doReset usually false, setting to true causes filter to reset to the value of signal Returns Type Description System.Double Filter(Double[], Double, Int32) Filter an entire time-series in one command Declaration public double[] Filter(double[] signal, double FilterTc_s, int order = 1) Parameters Type Name Description System.Double [] signal the vector of the entire time-series to be filtered System.Double FilterTc_s filter time constant System.Int32 order filter order, either 1 or 2 Returns Type Description System.Double [] a vector of the filtered time-series"
  },
  "api/TimeSeriesAnalysis.Dynamic.html": {
    "href": "api/TimeSeriesAnalysis.Dynamic.html",
    "title": "Namespace TimeSeriesAnalysis.Dynamic | TimeSeriesAnalysis reference documentation",
    "keywords": "Namespace TimeSeriesAnalysis.Dynamic Classes BandPass Numerical band-pass filter based on LowPass This filter is in a recursive(feedback) IIR form that is simple to implement, has few coefficients, requires litte memory and computation. This filter is causal, meaning that for calculating the filtered value at time k it does not use future values such as k+1 , but this is at the expense of introducing a time-shift/phase-shift. LowPass HighPass MovingAvg ConnectionParser Class that tracks which model is connected to which in a set of models. This is important when traversing the models when simulating with the ProcessSimulator , as these models need to be run in a specific order DefaultProcessModel Simulatable \"default\" process model. This is a model that can be either dynamic or static, have one or multiple inputs and can be either linear in inputs or have inputs nonlinearity described by a polynominal. Dynamics can be either 1.order time-constant, time-delay or both. The model also supports \"additive\" signals added to its output(intended for modeling disturbances.) The model is designed to lend itesel well to identificaiton from industrial time-series datasets, and is supported by the accompanying identificaiton method DefaultProcessModelIdentifier . This model is also intended to be co-simulated with PIDModel by ProcessSimulator to study process control feedback loops. It is assumed that for most unit processes in industrial process control systems can be described sufficiently by this model, and thus that larger plants can be modeled by connecting unit models based on this model structure. It would be possible to extend this model to also describe second-order dynamics along the same principles by the intorduction of one additional paramters in future work. DefaultProcessModelParameters DefaultProcessModelIdentifier PIDModel ProcessSimulator DefaultProcessModelIdentifier Identifier of the \"Default\" process model - a dynamic process model with time-constant, time-delay, linear process gain and optional (nonlinear)curvature process gains. This model class is sufficent for real-world linear or weakly nonlinear dynamic systems, yet also introduces the fewest possible parameters to describe the system in an attempt to avoiding over-fitting/over-parametrization The \"default\" process model is linear-in-paramters, so that it can be solved by linear regression and identification should thus be both fast and stable. Time-delay is an integer parameter, and finding the time-delay alongside continous paramters turns the identification problem into a linear mixed-integer problem. The time delay identification is done by splitting the time-delay estimation from continous parameter identification, turning the solver into a sequential optimization solver. This logic to re-run estimation for multiple time-delays and selecting the best estiamte of time delay is deferred to ProcessTimeDelayIdentifier TimeSeriesAnalysis.Dynamic.ProcessTimeDelayIdentifier DefaultProcessModelParameters Parameters data class of the DefaultProcessModel HighPass A high-pass recursive time-series filter based on LowPass . This filter is in a recursive(feedback) IIR form that is simple to implement, has few coefficients, requires litte memory and computation. This filter is causal, meaning that for calculating the filtered value at time k it does not use future values such as k+1 , but this is at the expense of introducing a time-shift/phase-shift. LowPass BandPass MovingAvg LowPass Low-pass filtering of time-series. This filter is in a recursive(feedback) IIR form that is simple to implement, has few coefficients, requires litte memory and computation. This filter is causal, meaning that for calcuating the filtered value at time k it does not use future values such as k+1 , but this is at the expense of introducing a time-shift/phase-shift. HighPass BandPass MovingAvg ModelBaseClass Abstract base class that contins common functionality across all models which are to implement ISimulatableModel ModelParametersBaseClass MovingAvg Moving-average low-pass filter This filter is causal, meaning that for calculating the filtered value at time k it does not use future values such as k+1 , this is at the expense of introducing a time-shift/phase-shift. This is a finite-impulse-response type filter. An alterntive to this filter is LowPass , which is infinite-impulse-repsonse, and also requires less working memory(this filter needs to hold a buffer equal to bufferSize , but LowPass only needs to keep its last value in memory). LowPass will have less phase-shift/time-shift, because it places most weight on the last datapoint, whereas this filter will weight all data points in its buffer equally and thus responds sluggish. The advantage of this filter is that it allows you to control precisely how many past values are weighted. LowPass HighPass BandPass PIDAntiSurgeParams Class that contains special pid-controller parameters for anti-surge controllers PIDModel PIDcontroller PIDcontroller Proporitional-Integral-Derivative(PID) controller that supports first and second order low pass filtering of process variable anti-windup bumpless transfer between auto and manual mode \"warmstarting\" -bumpless startup feedforward scaling of input and output values gain scheduling of Kp gain scheduling of Ti \"kicking\" as is usually applied to compressor recycling controllers/anti-surge min select/max select (also referred to as high select or low select: (multiple pid-controllers controlling the same output switch between auto and tracking mode) By design decision, this class should be kept relativly simple in terms of coding patterns, so that it is possible to hand-port this class to other languages (c++/c/Structured Text/Labview/Matlab etc). To simulate PID-control, use the wrapper class PIDModel, as it wraps this class and impelments the ISimulatableModel interface needed to simulate with ProcessSimulator PIDModel PIDfeedForward Parameters describing PID-controller parameters for feed-forward PIDModel PIDcontroller PIDgainScheduling Parameters describing PID-controller parameters for gain-scheduling PIDModel PIDcontroller PIDModel Simulatable industrial PID-controller This class is as a wrapper for PIDcontroller class, that implements ISimulatableModel . To simulate minimum or maximum select controllers, combine this class with Select blocks. The controller paramters belong to different aspects of the controller like, tuning, scaling, gain-scheduling, feedforward and anti-surge are adjusted have been collected into a number of data-classes, linked below: PIDModelParameters PIDAntiSurgeParams PIDfeedForward PIDgainScheduling PIDStatus PIDscaling PIDtuning PIDModelParameters Parameters of the PIDModel PIDModel PIDcontroller PIDscaling Parameters describing PID-controller parameters for scaling PIDModel PIDcontroller PIDtuning Parameters describing PID-controller tuning (Kp,Ti,Td) PIDModel PIDcontroller ProcessSimulator Simulates larger \"plant-models\" that is built up connected sub-models, that each implement ISimulatableModel To set up a simulation, first connect models, and then add external input signals. This class handles information about which model is connected to which, and handles callig sub-models in the correct order with the correct input signals. By default, the model attempts to start in steady-state, intalization handled by ProcessSimulatorInitalizer (this requires no user interaction) The building blocks of plant models are PIDModel , DefaultProcessModel and Select DefaultProcessModel PIDModel ProcessSimulatorInitalizer Select ProcessSimulatorInitalizer Intializes a simulator in the first data point Currently, only initalizing to steady-state is supported. By design choice, this class traverses the models by logic to initialize the plant model rather than using mathematical programming/matrix solvers. Select Simulatable select block This block can function either as \"minimum\" or \"maximum\" selector. It can be used either for enforcing ranges in plant simulations, but also for simulating \"min select\" or \"max selct\" pid-control by combining with PIDModel SubProcessDataSet The data for a porition of a process, containg only one output and one or multiple inputs that influence it SubProcessSimulator Simulate any subprocess model that has implemented the IProcessModel interface. This class relies on depencency injection and interfaces, so that the the specifics of how models outputs are calculated should be encapsulated in the passed model objects. This class should not be static, as it is to be used as a type for MultiProcessSimulator TimeDelay Delays a signal by a specific number of time steps, keeping an internal buffer of delayed values between iterations. This is a reasuble class for providing time-delay functionality to simulatable models. TimeSeriesDataSet A class that holds time-series data for a number of tags This is the return data class of the ProcessSimulator Interfaces ISimulatableModel Generic interface that any process model needs to implement if it is to be simulated by ProcessSimulator . Enums PIDStatus Enum to classify the status output of PidController.cs ProcessIdentWarnings Enum of recognized warning or error states during identification of process model ProcessModelType Enum of recognized types of unit-models. This type is used to set the unit model unique identifier and is also used in internal logic in the large-scale dynamic simulations ProcessTimeDelayIdentWarnings Enum of recognized warning or error states during identification of time delays SelectType An enum of the type of Select model SignalType Enum of types of signals that ProcessSimulator must differentiate between SubProcessDataSetWarnings Enum of recognized warning or error states during identification of process model"
  },
  "api/TimeSeriesAnalysis.Dynamic.ISimulatableModel.html": {
    "href": "api/TimeSeriesAnalysis.Dynamic.ISimulatableModel.html",
    "title": "Interface ISimulatableModel | TimeSeriesAnalysis reference documentation",
    "keywords": "Interface ISimulatableModel Generic interface that any process model needs to implement if it is to be simulated by ProcessSimulator . Namespace : TimeSeriesAnalysis.Dynamic Assembly : TimeSeriesAnalysis.dll Syntax public interface ISimulatableModel Methods AddSignalToOutput(String) Add an additive signal to the output Declaration void AddSignalToOutput(string additiveInputID) Parameters Type Name Description System.String additiveInputID GetAdditiveInputIDs() Get additive input IDs Declaration string[] GetAdditiveInputIDs() Returns Type Description System.String [] GetBothKindsOfInputIDs() Get both additive and model input IDs Declaration string[] GetBothKindsOfInputIDs() Returns Type Description System.String [] GetID() An unique name of the process model Declaration string GetID() Returns Type Description System.String GetLengthOfInputVector() Get the length of the input vector Declaration int GetLengthOfInputVector() Returns Type Description System.Int32 GetModelInputIDs() Return the inputIDs that are \"internal\" i.e. related to the model and internal state x, but not \"additive\" Declaration string[] GetModelInputIDs() Returns Type Description System.String [] GetOutputID() Get the output ID Declaration string GetOutputID() Returns Type Description System.String GetOutputSignalType() Get the type of the output signal Declaration SignalType GetOutputSignalType() Returns Type Description SignalType GetProcessModelType() Returns the type of process model Declaration ProcessModelType GetProcessModelType() Returns Type Description ProcessModelType GetSteadyStateInput(Double, Int32, Double[]) Calculates the value u0 of u that at steady-state will give the output value y0. This method is used when starting a method at steady-state. Declaration double? GetSteadyStateInput(double y0, int inputIdx = 0, double[] givenInputValues = null) Parameters Type Name Description System.Double y0 value of y for which to find matching u0 System.Int32 inputIdx index of input(only applicable if multiple inputs) System.Double [] givenInputValues for multip-input systems, all values except one must be given to calculate the steady-state u0 Returns Type Description System.Nullable < System.Double > GetSteadyStateOutput(Double[]) Get the steady state value of the model output Declaration double? GetSteadyStateOutput(double[] u0) Parameters Type Name Description System.Double [] u0 vector of inputs for which the steady state is to be calculated Returns Type Description System.Nullable < System.Double > the steady-state value, if it is not possible to calculate, a null is returned Iterate(Double[], Double) Iterate the process model one timestep forward Declaration double Iterate(double[] inputsU, double badDataID = -9999) Parameters Type Name Description System.Double [] inputsU a 2d array of inputs, one row for each time step, or null if model is autonomous System.Double badDataID is a special reserverd value of inputs U that is to be treated as NaN Returns Type Description System.Double the value of the state x of the process model at the new time step(be aware that if a disturbance is defined, they need ot be added to states to get y_sim ) SetInputIDs(String[], Nullable<Int32>) Set the input IDs Declaration bool SetInputIDs(string[] manipulatedVariablesU_stringIDs, int? index = null) Parameters Type Name Description System.String [] manipulatedVariablesU_stringIDs System.Nullable < System.Int32 > index Returns Type Description System.Boolean SetOutputID(String) Set the output ID Declaration void SetOutputID(string outputID) Parameters Type Name Description System.String outputID WarmStart(Double[], Double) If possible, set the internal state of the model so that the given inputs give the given output Declaration void WarmStart(double[] inputs, double output) Parameters Type Name Description System.Double [] inputs System.Double output"
  },
  "api/TimeSeriesAnalysis.Dynamic.LowPass.html": {
    "href": "api/TimeSeriesAnalysis.Dynamic.LowPass.html",
    "title": "Class LowPass | TimeSeriesAnalysis reference documentation",
    "keywords": "Class LowPass Low-pass filtering of time-series. This filter is in a recursive(feedback) IIR form that is simple to implement, has few coefficients, requires litte memory and computation. This filter is causal, meaning that for calcuating the filtered value at time k it does not use future values such as k+1 , but this is at the expense of introducing a time-shift/phase-shift. HighPass BandPass MovingAvg Inheritance System.Object LowPass Inherited Members System.Object.ToString() System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.ReferenceEquals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() Namespace : TimeSeriesAnalysis.Dynamic Assembly : TimeSeriesAnalysis.dll Syntax public class LowPass Constructors LowPass(Double, Double) Constructor Declaration public LowPass(double TimeBase_s, double nanValue = -9999) Parameters Type Name Description System.Double TimeBase_s The time base, the time interval between each time step of the dataset, in seconds System.Double nanValue Methods Filter(Double, Double, Int32, Boolean) Adds a single data point to the filter Declaration public double Filter(double signal, double FilterTc_s, int order = 1, bool doReset = false) Parameters Type Name Description System.Double signal data point System.Double FilterTc_s filter time constant in seconds System.Int32 order filter order, either 1 or 2 is supported System.Boolean doReset usually false, setting to true causes filter to reset to the value of signal Returns Type Description System.Double Filter(Double[], Double, Int32) Filter an entire time-series in one command Declaration public double[] Filter(double[] signal, double FilterTc_s, int order = 1) Parameters Type Name Description System.Double [] signal the vector of the entire time-series to be filtered System.Double FilterTc_s filter time constant System.Int32 order filter order, either 1 or 2 Returns Type Description System.Double [] a vector of the filtered time-series"
  },
  "api/TimeSeriesAnalysis.Dynamic.ModelBaseClass.html": {
    "href": "api/TimeSeriesAnalysis.Dynamic.ModelBaseClass.html",
    "title": "Class ModelBaseClass | TimeSeriesAnalysis reference documentation",
    "keywords": "Class ModelBaseClass Abstract base class that contins common functionality across all models which are to implement ISimulatableModel Inheritance System.Object ModelBaseClass DefaultProcessModel PIDModel Select Inherited Members System.Object.ToString() System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.ReferenceEquals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() Namespace : TimeSeriesAnalysis.Dynamic Assembly : TimeSeriesAnalysis.dll Syntax public abstract class ModelBaseClass Methods AddSignalToOutput(String) Add an additive signal to the output Declaration public void AddSignalToOutput(string additiveInputID) Parameters Type Name Description System.String additiveInputID ID of signal to add GetAdditiveInputIDs() Get the DIs of any additive inputs that are included in model Declaration public string[] GetAdditiveInputIDs() Returns Type Description System.String [] returns null if no additive inputs are defined. GetBothKindsOfInputIDs() Gets IDS both of model inputs and additive model outputs Declaration public string[] GetBothKindsOfInputIDs() Returns Type Description System.String [] GetID() Get the ID of the model Declaration public string GetID() Returns Type Description System.String GetLengthOfInputVector() Get the length of the output vector Declaration public virtual int GetLengthOfInputVector() Returns Type Description System.Int32 GetModelInputIDs() Get the type of the process model Declaration public string[] GetModelInputIDs() Returns Type Description System.String [] GetOutputID() returns the output ID Declaration public string GetOutputID() Returns Type Description System.String may return null if output is not set GetOutputSignalType() Get the type of the output signal Declaration public abstract SignalType GetOutputSignalType() Returns Type Description SignalType GetProcessModelType() Get the type of the process model Declaration public ProcessModelType GetProcessModelType() Returns Type Description ProcessModelType SetID(String) Set the ID of the model Declaration public void SetID(string ID) Parameters Type Name Description System.String ID SetInputIDs(String[], Nullable<Int32>) Set the stringIDs of the one or more manipulated variables U that enter model. This method may append/lengthen the inputIDs Declaration public bool SetInputIDs(string[] U_stringIDs, int? idx = null) Parameters Type Name Description System.String [] U_stringIDs System.Nullable < System.Int32 > idx if non-null, this is the index of the element in U to set (U_stringIDs should then have just one element) Returns Type Description System.Boolean SetOutputID(String) Set the ID of the output Declaration public void SetOutputID(string outputID) Parameters Type Name Description System.String outputID SetProcessModelType(ProcessModelType) Set the type of the process model Declaration public void SetProcessModelType(ProcessModelType newType) Parameters Type Name Description ProcessModelType newType"
  },
  "api/TimeSeriesAnalysis.Dynamic.ModelParametersBaseClass.html": {
    "href": "api/TimeSeriesAnalysis.Dynamic.ModelParametersBaseClass.html",
    "title": "Class ModelParametersBaseClass | TimeSeriesAnalysis reference documentation",
    "keywords": "Class ModelParametersBaseClass Inheritance System.Object ModelParametersBaseClass DefaultProcessModelParameters PIDModelParameters Inherited Members System.Object.ToString() System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.ReferenceEquals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() Namespace : TimeSeriesAnalysis.Dynamic Assembly : TimeSeriesAnalysis.dll Syntax public abstract class ModelParametersBaseClass Properties FittingObjFunVal Declaration public double FittingObjFunVal { get; set; } Property Value Type Description System.Double FittingRsq Declaration public double FittingRsq { get; set; } Property Value Type Description System.Double NFittingBadDataPoints Declaration public double NFittingBadDataPoints { get; set; } Property Value Type Description System.Double NFittingTotalDataPoints Declaration public double NFittingTotalDataPoints { get; set; } Property Value Type Description System.Double WasAbleToIdentify Declaration public bool WasAbleToIdentify { get; set; } Property Value Type Description System.Boolean Methods AbleToIdentify() Declaration public bool AbleToIdentify() Returns Type Description System.Boolean GetFittingObjFunVal() Declaration public double GetFittingObjFunVal() Returns Type Description System.Double GetFittingR2() Declaration public double GetFittingR2() Returns Type Description System.Double"
  },
  "api/TimeSeriesAnalysis.Dynamic.MovingAvg.html": {
    "href": "api/TimeSeriesAnalysis.Dynamic.MovingAvg.html",
    "title": "Class MovingAvg | TimeSeriesAnalysis reference documentation",
    "keywords": "Class MovingAvg Moving-average low-pass filter This filter is causal, meaning that for calculating the filtered value at time k it does not use future values such as k+1 , this is at the expense of introducing a time-shift/phase-shift. This is a finite-impulse-response type filter. An alterntive to this filter is LowPass , which is infinite-impulse-repsonse, and also requires less working memory(this filter needs to hold a buffer equal to bufferSize , but LowPass only needs to keep its last value in memory). LowPass will have less phase-shift/time-shift, because it places most weight on the last datapoint, whereas this filter will weight all data points in its buffer equally and thus responds sluggish. The advantage of this filter is that it allows you to control precisely how many past values are weighted. LowPass HighPass BandPass Inheritance System.Object MovingAvg Inherited Members System.Object.ToString() System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.ReferenceEquals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() Namespace : TimeSeriesAnalysis.Dynamic Assembly : TimeSeriesAnalysis.dll Syntax public class MovingAvg Constructors MovingAvg(Int32) Constructor Declaration public MovingAvg(int bufferSize) Parameters Type Name Description System.Int32 bufferSize the number of samples to average, which determines the size of the buffer to create Methods Filter(Double) Add value to the moving-average filter. Declaration public double Filter(double signal) Parameters Type Name Description System.Double signal the scalar value to be added Returns Type Description System.Double the output of the filter, given the new value Filter(Double[]) Run filter over a vector of values Declaration public double[] Filter(double[] signal) Parameters Type Name Description System.Double [] signal vector of values to be filtered Returns Type Description System.Double [] the moving-averge filtered version of values"
  },
  "api/TimeSeriesAnalysis.Dynamic.PIDAntiSurgeParams.html": {
    "href": "api/TimeSeriesAnalysis.Dynamic.PIDAntiSurgeParams.html",
    "title": "Class PIDAntiSurgeParams | TimeSeriesAnalysis reference documentation",
    "keywords": "Class PIDAntiSurgeParams Class that contains special pid-controller parameters for anti-surge controllers PIDModel PIDcontroller Inheritance System.Object PIDAntiSurgeParams Inherited Members System.Object.ToString() System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.ReferenceEquals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() Namespace : TimeSeriesAnalysis.Dynamic Assembly : TimeSeriesAnalysis.dll Syntax public class PIDAntiSurgeParams Constructors PIDAntiSurgeParams(Double, Nullable<Double>, Int32, Double) Constructor Declaration public PIDAntiSurgeParams(double kickPrc, double? ffRampDownRatePrcPerMin, int nKicksFound = 0, double kickBelowThresholdE = -5) Parameters Type Name Description System.Double kickPrc System.Nullable < System.Double > ffRampDownRatePrcPerMin System.Int32 nKicksFound System.Double kickBelowThresholdE Fields ffRampDownRatePrcPerMin after a kick, valve closure will be rate-limited. Declaration public double? ffRampDownRatePrcPerMin Field Value Type Description System.Nullable < System.Double > kickBelowThresholdE if kick is \"ctrldev\" below this value (often zero) Declaration public double kickBelowThresholdE Field Value Type Description System.Double kickPrcPerSec how many percent to kick controller open if it closes Declaration public double kickPrcPerSec Field Value Type Description System.Double nKicksFound Kicks counter Declaration public int nKicksFound Field Value Type Description System.Int32"
  },
  "api/TimeSeriesAnalysis.Dynamic.PIDcontroller.html": {
    "href": "api/TimeSeriesAnalysis.Dynamic.PIDcontroller.html",
    "title": "Class PIDcontroller | TimeSeriesAnalysis reference documentation",
    "keywords": "Class PIDcontroller Proporitional-Integral-Derivative(PID) controller that supports first and second order low pass filtering of process variable anti-windup bumpless transfer between auto and manual mode \"warmstarting\" -bumpless startup feedforward scaling of input and output values gain scheduling of Kp gain scheduling of Ti \"kicking\" as is usually applied to compressor recycling controllers/anti-surge min select/max select (also referred to as high select or low select: (multiple pid-controllers controlling the same output switch between auto and tracking mode) By design decision, this class should be kept relativly simple in terms of coding patterns, so that it is possible to hand-port this class to other languages (c++/c/Structured Text/Labview/Matlab etc). To simulate PID-control, use the wrapper class PIDModel, as it wraps this class and impelments the ISimulatableModel interface needed to simulate with ProcessSimulator PIDModel Inheritance System.Object PIDcontroller Inherited Members System.Object.ToString() System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.ReferenceEquals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() Namespace : TimeSeriesAnalysis.Dynamic Assembly : TimeSeriesAnalysis.dll Syntax public class PIDcontroller Constructors PIDcontroller(Double, Double, Double, Double, Double) Constructor Declaration public PIDcontroller(double TimeBase_s, double Kp = 1, double Ti = 50, double Td = 0, double nanValue = -9999) Parameters Type Name Description System.Double TimeBase_s System.Double Kp System.Double Ti System.Double Td System.Double nanValue Methods GetControllerStatus() Returns a status code, to determine if controller is in manual, auto or in tracking(relevant for split range controllers.) Declaration public PIDStatus GetControllerStatus() Returns Type Description PIDStatus GetFeedForward() Get the feedforward parameters of the controller Declaration public PIDfeedForward GetFeedForward() Returns Type Description PIDfeedForward GetGainScehduling(PIDgainScheduling) Get the gain scheduling settings of the controller Declaration public PIDgainScheduling GetGainScehduling(PIDgainScheduling gainSchedulingObj) Parameters Type Name Description PIDgainScheduling gainSchedulingObj Returns Type Description PIDgainScheduling GetScaling() Get the object that contains scaling information Declaration public PIDscaling GetScaling() Returns Type Description PIDscaling GetTimeBase() Sets the length of time in seconds between each iteration of the controller, i.e. the \"clock time\" or \"time base\". This is very important to set correctly for the controller to function properly. Normally the clock time is set only once during intalization. Declaration public double GetTimeBase() Returns Type Description System.Double GetTrackingCutoff() Get the tracking cutoff parameter Declaration public double GetTrackingCutoff() Returns Type Description System.Double GetTrackingOffset() Returns the tracking offset of the controller, the offset that a non-active controller will add or subtract from its output when inactive in a split range control scheme Declaration public double GetTrackingOffset() Returns Type Description System.Double GetUIfInAuto() Returns the value of the output u that the controller would give if it was in auto. This is useful when considering turning on a controller that is in manual to see that the controller gives a sensible output. Call \"iterate\" first to update the internals of the controller. Declaration public double GetUIfInAuto() Returns Type Description System.Double GetUWithoutTracking() Split range controllers add an offset to the output u for inactive or \"tracking\" controllers. This function returns the \"raw\" u without tracking, which can be useful for initalizing simulations with split range control. Declaration public double GetUWithoutTracking() Returns Type Description System.Double Iterate(Double, Double, Nullable<Double>, Nullable<Double>, Nullable<Double>) Calculates the next u[k] output of the controller given the most recent process value and setpoint value, and optionally also including the tracking signal (only applicable if this is a split range controller) and optionally the gainScehduling variable if controller is to gain-schedule Declaration public double Iterate(double y_process_abs, double y_set_abs, double? uTrackSignal = null, double? gainSchedulingVariable = null, double? feedForwardVariable = null) Parameters Type Name Description System.Double y_process_abs System.Double y_set_abs System.Nullable < System.Double > uTrackSignal System.Nullable < System.Double > gainSchedulingVariable System.Nullable < System.Double > feedForwardVariable Returns Type Description System.Double Iterate(Double[], Double[], Double[]) Calculates an entire output vector u given vector of processes and setpoints (and optionally a tracking signal for split range) This method is useful for back-testing against historic data. Declaration public double[] Iterate(double[] y_process_abs, double[] y_set_abs, double[] uTrackSignal = null) Parameters Type Name Description System.Double [] y_process_abs System.Double [] y_set_abs System.Double [] uTrackSignal Returns Type Description System.Double [] SetAntiSurgeParams(PIDAntiSurgeParams) Sets the anti-surge \"kick\" paramters of the controller Declaration public void SetAntiSurgeParams(PIDAntiSurgeParams antiSurgeParams) Parameters Type Name Description PIDAntiSurgeParams antiSurgeParams SetAutoMode() Set the control to autoamtic mode (i.e. u varies based on inputs and settings) (use SetManualMode to switch back) Declaration public void SetAutoMode() SetFeedForward(PIDfeedForward) Set the feedforward of the controller Re-calling this setter to update Declaration public void SetFeedForward(PIDfeedForward feedForwardObj) Parameters Type Name Description PIDfeedForward feedForwardObj SetGainScehduling(PIDgainScheduling) Set the gain scheduling of the controller (by default controller has no gain-scheduling) Re-calling this setter to update gain-scheduling Declaration public void SetGainScehduling(PIDgainScheduling gainSchedulingObj) Parameters Type Name Description PIDgainScheduling gainSchedulingObj SetKp(Double) Sets the Proportional gain(P) of the controller Declaration public void SetKp(double Kp) Parameters Type Name Description System.Double Kp SetManualMode() Set the control to manual mode (i.e. constant u). Will cause a bumpless transfer.(use SetAutoMode to switch back) Declaration public void SetManualMode() SetManualOutput(Double) Set the manual output of the model (will only be used if set) Declaration public void SetManualOutput(double uManual) Parameters Type Name Description System.Double uManual SetScaling(PIDscaling) Gives a PIDscaling object that specifies how input and output is to be scaled. Declaration public void SetScaling(PIDscaling pidScaling) Parameters Type Name Description PIDscaling pidScaling SetTd(Double) Sets the differential(D) time contant of the controller in seconds Declaration public void SetTd(double Td_seconds) Parameters Type Name Description System.Double Td_seconds SetTi(Double) Sets the Integral(I) time contant of the controller in seconds Declaration public void SetTi(double Ti_seconds) Parameters Type Name Description System.Double Ti_seconds SetTrackingOffset(Double, Double) Set the offset that is to be added or subtracte to a split range controller that is inactive or tracking. If this value is above zero, then the controller is MIN SELECT, if this value is negative then the controller is assumed MAX SELECT if this vlaue is zero, then trakcking will not work properly as controller will be unable to determine if its output was selected by looking at the tracking signal. Declaration public void SetTrackingOffset(double uTrackingOffset, double uTrackingCutoff = 0.5) Parameters Type Name Description System.Double uTrackingOffset System.Double uTrackingCutoff SetU0ForPcontrol(Double) For proportional-only controllers (P-controllers), a u0 offset to be added to u is specified by this method. Declaration public void SetU0ForPcontrol(double u0) Parameters Type Name Description System.Double u0 SetYFilter(Double, Int32) Sets the filter time constant in seconds and the filter order (1. or 2. order supported) of low-pass filter to be applied to the process measurement y Declaration public void SetYFilter(double filterTimeConstant_s, int filterOrder = 1) Parameters Type Name Description System.Double filterTimeConstant_s System.Int32 filterOrder WarmStart(Double, Double, Double) Initalizes the controller internal state(integral term) to be steady at the given process value and output value, useful to avoid bumps when staring controller Declaration public void WarmStart(double y_process_abs, double y_set_abs, double u_abs) Parameters Type Name Description System.Double y_process_abs System.Double y_set_abs System.Double u_abs"
  },
  "api/TimeSeriesAnalysis.Dynamic.PIDfeedForward.html": {
    "href": "api/TimeSeriesAnalysis.Dynamic.PIDfeedForward.html",
    "title": "Class PIDfeedForward | TimeSeriesAnalysis reference documentation",
    "keywords": "Class PIDfeedForward Parameters describing PID-controller parameters for feed-forward PIDModel PIDcontroller Inheritance System.Object PIDfeedForward Inherited Members System.Object.ToString() System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.ReferenceEquals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() Namespace : TimeSeriesAnalysis.Dynamic Assembly : TimeSeriesAnalysis.dll Syntax public class PIDfeedForward Fields FF_Gain feed-forward gain. If variable is zero then no feed-forward is added to output. Declaration public double FF_Gain Field Value Type Description System.Double FF_HP_Tc_s feed-forward high-pass time constant in seconds(should be smaller than FF_HP_Tc_s or zero.) Declaration public double FF_HP_Tc_s Field Value Type Description System.Double FF_LP_Tc_s feed-forward low-pass time constant in seconds (should be larger than FF_HP_Tc_s or zero.) Declaration public double FF_LP_Tc_s Field Value Type Description System.Double FFHP_filter_order feed-forward high pass filter order (0, 1 or 2) Declaration public int FFHP_filter_order Field Value Type Description System.Int32 FFLP_filter_order feed-forward low pass filter order (0, 1 or 2) Declaration public int FFLP_filter_order Field Value Type Description System.Int32 isFFActive if true, then the feed-forward term is added to the output Declaration public bool isFFActive Field Value Type Description System.Boolean"
  },
  "api/TimeSeriesAnalysis.Dynamic.PIDgainScheduling.html": {
    "href": "api/TimeSeriesAnalysis.Dynamic.PIDgainScheduling.html",
    "title": "Class PIDgainScheduling | TimeSeriesAnalysis reference documentation",
    "keywords": "Class PIDgainScheduling Parameters describing PID-controller parameters for gain-scheduling PIDModel PIDcontroller Inheritance System.Object PIDgainScheduling Inherited Members System.Object.ToString() System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.ReferenceEquals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() Namespace : TimeSeriesAnalysis.Dynamic Assembly : TimeSeriesAnalysis.dll Syntax public class PIDgainScheduling Constructors PIDgainScheduling() Constructor(disable gain-scheduling by default) Declaration public PIDgainScheduling() PIDgainScheduling(Double, Double) Constructor that enables gain-scheduling filter (but gain-scheduling still disabled) Declaration public PIDgainScheduling(double TimeStep_s, double GSVariableLP_Tc_s) Parameters Type Name Description System.Double TimeStep_s System.Double GSVariableLP_Tc_s Fields GS_Kp_1 KP(proportional term) @ GsVariable=GS_x_1 Declaration public double GS_Kp_1 Field Value Type Description System.Double GS_Kp_2 KP(proportional term) @ GsVariable=GS_x_2 Declaration public double GS_Kp_2 Field Value Type Description System.Double GS_Kp_Max KP(proportional term) @ GsVariable=GS_x_Max Declaration public double GS_Kp_Max Field Value Type Description System.Double GS_Kp_Min KP(proportional term) @ GsVariable=GS_x_Min Declaration public double GS_Kp_Min Field Value Type Description System.Double GS_Ti_1 Ti(integral effect) @ GsVariable=GS_x_1 Declaration public double GS_Ti_1 Field Value Type Description System.Double GS_Ti_2 Ti(integral effect) @ GsVariable=GS_x_2 Declaration public double GS_Ti_2 Field Value Type Description System.Double GS_Ti_Max Ti(integral effect) @ GsVariable=GS_x_Max Declaration public double GS_Ti_Max Field Value Type Description System.Double GS_Ti_Min Ti(integral effect) @ GsVariable=GS_x_Min Declaration public double GS_Ti_Min Field Value Type Description System.Double GS_x_1 Gain-sheduling(x) variable x1,x=GsVariable Declaration public double GS_x_1 Field Value Type Description System.Double GS_x_2 Gain-sheduling(x) variable x2,x=GsVariable Declaration public double GS_x_2 Field Value Type Description System.Double GS_x_Max Gain-sheduling(x) variable maximum Declaration public double GS_x_Max Field Value Type Description System.Double GS_x_Min Gain-sheduling(x) variable minimum Declaration public double GS_x_Min Field Value Type Description System.Double GSActive_b if TRUE then the gainScheduling variable and gain-scheduling inputs are used Declaration public bool GSActive_b Field Value Type Description System.Boolean GSActiveTi_b if TRUE then the gainScheduling is also done on Ti Declaration public bool GSActiveTi_b Field Value Type Description System.Boolean"
  },
  "api/TimeSeriesAnalysis.Dynamic.PIDModel.html": {
    "href": "api/TimeSeriesAnalysis.Dynamic.PIDModel.html",
    "title": "Class PIDModel | TimeSeriesAnalysis reference documentation",
    "keywords": "Class PIDModel Simulatable industrial PID-controller This class is as a wrapper for PIDcontroller class, that implements ISimulatableModel . To simulate minimum or maximum select controllers, combine this class with Select blocks. The controller paramters belong to different aspects of the controller like, tuning, scaling, gain-scheduling, feedforward and anti-surge are adjusted have been collected into a number of data-classes, linked below: PIDModelParameters PIDAntiSurgeParams PIDfeedForward PIDgainScheduling PIDStatus PIDscaling PIDtuning Inheritance System.Object ModelBaseClass PIDModel Implements ISimulatableModel Inherited Members ModelBaseClass.GetID() ModelBaseClass.SetID(String) ModelBaseClass.SetProcessModelType(ProcessModelType) ModelBaseClass.GetProcessModelType() ModelBaseClass.SetInputIDs(String[], Nullable<Int32>) ModelBaseClass.AddSignalToOutput(String) ModelBaseClass.GetModelInputIDs() ModelBaseClass.GetAdditiveInputIDs() ModelBaseClass.GetBothKindsOfInputIDs() ModelBaseClass.SetOutputID(String) ModelBaseClass.GetOutputID() System.Object.ToString() System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.ReferenceEquals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() Namespace : TimeSeriesAnalysis.Dynamic Assembly : TimeSeriesAnalysis.dll Syntax public class PIDModel : ModelBaseClass, ISimulatableModel Constructors PIDModel(PIDModelParameters, Int32, String) Constructor Declaration public PIDModel(PIDModelParameters pidParameters, int timeBase_s, string ID = \"not_named\") Parameters Type Name Description PIDModelParameters pidParameters object containing the paramters of the controller System.Int32 timeBase_s sampling time, a steady time between each call to Iterate System.String ID Each controller shoudl be given a unique ID Methods GetLengthOfInputVector() Get number of inputs (between 2 and 4) first input is always ymeas, second input is y_setpoint, optionally, input 3 is track signal and input 4 is gain scheduling variable Declaration public override int GetLengthOfInputVector() Returns Type Description System.Int32 Overrides ModelBaseClass.GetLengthOfInputVector() GetModelParameters() Get the model parameters Declaration public PIDModelParameters GetModelParameters() Returns Type Description PIDModelParameters the parameters object of the model GetOutputSignalType() Return the type of the output signal Declaration public override SignalType GetOutputSignalType() Returns Type Description SignalType Overrides ModelBaseClass.GetOutputSignalType() GetSteadyStateInput(Double, Int32, Double[]) [Method not currently implemented] Declaration public double? GetSteadyStateInput(double y0, int inputIdx = 0, double[] givenInputValues = null) Parameters Type Name Description System.Double y0 System.Int32 inputIdx System.Double [] givenInputValues Returns Type Description System.Nullable < System.Double > GetSteadyStateOutput(Double[]) NOT IMPLEMENTED/NOT APPLICABLE Declaration public double? GetSteadyStateOutput(double[] u0) Parameters Type Name Description System.Double [] u0 Returns Type Description System.Nullable < System.Double > Iterate(Double[], Double) Iterate the PID controller one step Declaration public double Iterate(double[] inputs, double badDataID = -9999) Parameters Type Name Description System.Double [] inputs is a vector of length 2, 3 or 4. First value is y_process_abs , second value is y_set_abs , optional third value is uTrackSignal , optional fourth value is gainSchedulingVariable System.Double badDataID value of inputs that is to be treated as NaN Returns Type Description System.Double the output u of the pid-controller. If not enough inputs, it returns NaN SetManualOutput(Double) Set the desired manual output fo controller. This output will only be applied if controller is in MANUAL mode. Declaration public void SetManualOutput(double manualOutput_prc) Parameters Type Name Description System.Double manualOutput_prc SetToAutoMode() Set controller in auto Declaration public void SetToAutoMode() SetToManualMode() Set controller in auto Declaration public void SetToManualMode() WarmStart(Double, Double, Double) Initalizes the controller internal state(integral term) to be steady at the given process value and output value, useful to avoid bumps when staring controller Declaration public void WarmStart(double y_process_abs, double y_set, double u) Parameters Type Name Description System.Double y_process_abs System.Double y_set System.Double u WarmStart(Double[], Double) Initalizes the controller internal state(integral term) to be steady at the given process value and output value, useful to avoid bumps when staring controller Declaration public void WarmStart(double[] inputs, double output) Parameters Type Name Description System.Double [] inputs System.Double output Implements ISimulatableModel"
  },
  "api/TimeSeriesAnalysis.Dynamic.PIDModelParameters.html": {
    "href": "api/TimeSeriesAnalysis.Dynamic.PIDModelParameters.html",
    "title": "Class PIDModelParameters | TimeSeriesAnalysis reference documentation",
    "keywords": "Class PIDModelParameters Parameters of the PIDModel PIDModel PIDcontroller Inheritance System.Object ModelParametersBaseClass PIDModelParameters Inherited Members ModelParametersBaseClass.WasAbleToIdentify ModelParametersBaseClass.FittingRsq ModelParametersBaseClass.FittingObjFunVal ModelParametersBaseClass.NFittingBadDataPoints ModelParametersBaseClass.NFittingTotalDataPoints ModelParametersBaseClass.GetFittingR2() ModelParametersBaseClass.GetFittingObjFunVal() ModelParametersBaseClass.AbleToIdentify() System.Object.ToString() System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.ReferenceEquals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() Namespace : TimeSeriesAnalysis.Dynamic Assembly : TimeSeriesAnalysis.dll Syntax public class PIDModelParameters : ModelParametersBaseClass Properties AntiSugeParams PID anti-surge paramters objet. This is optional, set to null if not anti-surge PID Declaration public PIDAntiSurgeParams AntiSugeParams { get; set; } Property Value Type Description PIDAntiSurgeParams FeedForward Feed-forward parameters object. This is optional, set to null when feedforward is not in use. Declaration public PIDfeedForward FeedForward { get; set; } Property Value Type Description PIDfeedForward GainScheduling Gain-scheduling object. This is optional, set to null gain-scheduling is not in use. Declaration public PIDgainScheduling GainScheduling { get; set; } Property Value Type Description PIDgainScheduling Kp Proportional gain of controller Declaration public double Kp { get; set; } Property Value Type Description System.Double NanValue If the PID-controller is to be protected from a specific value that is used to identify bad or missing data, specify here Declaration public double NanValue { get; set; } Property Value Type Description System.Double Scaling PID-scaling object. This is optional, set to null to use unscaled PID. Declaration public PIDscaling Scaling { get; set; } Property Value Type Description PIDscaling Td_s Derivative term time constant[in seconds], 0 = no derivative term Declaration public double Td_s { get; set; } Property Value Type Description System.Double Ti_s Integral time constant [in seconds], 0 = no integral term Declaration public double Ti_s { get; set; } Property Value Type Description System.Double"
  },
  "api/TimeSeriesAnalysis.Dynamic.PIDscaling.html": {
    "href": "api/TimeSeriesAnalysis.Dynamic.PIDscaling.html",
    "title": "Class PIDscaling | TimeSeriesAnalysis reference documentation",
    "keywords": "Class PIDscaling Parameters describing PID-controller parameters for scaling PIDModel PIDcontroller Inheritance System.Object PIDscaling Inherited Members System.Object.ToString() System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.ReferenceEquals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() Namespace : TimeSeriesAnalysis.Dynamic Assembly : TimeSeriesAnalysis.dll Syntax public class PIDscaling Constructors PIDscaling() Constructor Declaration public PIDscaling() PIDscaling(Double, Double, Double, Double, Boolean) Constructor Declaration public PIDscaling(double y_min, double y_max, double u_min, double u_max, bool isKpScalingKpOn) Parameters Type Name Description System.Double y_min System.Double y_max System.Double u_min System.Double u_max System.Boolean isKpScalingKpOn Methods GetKpScalingFactor() Get a scaling factor to convert and unscaled Kp Declaration public double GetKpScalingFactor() Returns Type Description System.Double GetUmax() Get the maximum U Declaration public double GetUmax() Returns Type Description System.Double GetUmin() Get the minimum U Declaration public double GetUmin() Returns Type Description System.Double GetUScaleFactor() Get the scaling factor of U Declaration public double GetUScaleFactor() Returns Type Description System.Double GetYmax() Get the maximum Y Declaration public double GetYmax() Returns Type Description System.Double GetYmin() Get the minumum Y Declaration public double GetYmin() Returns Type Description System.Double GetYScaleFactor() Get the scaling factor for Y Declaration public double GetYScaleFactor() Returns Type Description System.Double IsDefault() Ask if scaling is at defautl values Declaration public bool IsDefault() Returns Type Description System.Boolean IsEstimated() Ask if the scaling is estimated from data or given a priori Declaration public bool IsEstimated() Returns Type Description System.Boolean IsKpScalingOn() Ask if scaling of Kp is active Declaration public bool IsKpScalingOn() Returns Type Description System.Boolean ScaleYValue(Double) Get the scaled version of an absolute y Declaration public double ScaleYValue(double y_abs) Parameters Type Name Description System.Double y_abs Returns Type Description System.Double Set(Double, Double, Double, Double, Boolean) Set scaling Declaration public void Set(double y_min, double y_max, double u_min, double u_max, bool isKpScalingKpOn) Parameters Type Name Description System.Double y_min System.Double y_max System.Double u_min System.Double u_max System.Boolean isKpScalingKpOn SetDefault() Set scaling to default Declaration public void SetDefault() SetEstimatedUminUmax(Double, Double) Set the estimated u_min and u_max (if it is not known, but guessed from data) Declaration public void SetEstimatedUminUmax(double u_min, double u_max) Parameters Type Name Description System.Double u_min System.Double u_max SetKpScalingOn(Boolean) Turn scaling on or off Declaration public void SetKpScalingOn(bool isKpScalingKpOn) Parameters Type Name Description System.Boolean isKpScalingKpOn"
  },
  "api/TimeSeriesAnalysis.Dynamic.PIDStatus.html": {
    "href": "api/TimeSeriesAnalysis.Dynamic.PIDStatus.html",
    "title": "Enum PIDStatus | TimeSeriesAnalysis reference documentation",
    "keywords": "Enum PIDStatus Enum to classify the status output of PidController.cs Namespace : TimeSeriesAnalysis.Dynamic Assembly : TimeSeriesAnalysis.dll Syntax public enum PIDStatus Fields Name Description AUTO Controller is in automatic mode(u varies) MANUAL Controller in in manual mode (u is constant) TRACKING Controller is in Tracking, i.e. it is in automatic, but its output goes to a select block which has selected another controller"
  },
  "api/TimeSeriesAnalysis.Dynamic.PIDtuning.html": {
    "href": "api/TimeSeriesAnalysis.Dynamic.PIDtuning.html",
    "title": "Class PIDtuning | TimeSeriesAnalysis reference documentation",
    "keywords": "Class PIDtuning Parameters describing PID-controller tuning (Kp,Ti,Td) PIDModel PIDcontroller Inheritance System.Object PIDtuning Inherited Members System.Object.ToString() System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.ReferenceEquals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() Namespace : TimeSeriesAnalysis.Dynamic Assembly : TimeSeriesAnalysis.dll Syntax public class PIDtuning Constructors PIDtuning(Double, Double, Boolean) Initalize tuning of Kp and Ti and if controller is reversed. Declaration public PIDtuning(double Kp, double Ti, bool isReversed = false) Parameters Type Name Description System.Double Kp System.Double Ti System.Boolean isReversed PIDtuning(Double, Double, Double, Boolean) Initalize tuning,Ti and Td are expected to be in seconds, and if Kp sign is to be reversed Declaration public PIDtuning(double Kp, double Ti, double Td = 0, bool isReversed = false) Parameters Type Name Description System.Double Kp System.Double Ti System.Double Td System.Boolean isReversed Methods GetKp() Gets the Kp, including the sign(accounts for pid-controller being set to reverese Kp sign) Declaration public double GetKp() Returns Type Description System.Double GetTd() Gets the Td in seoncds Declaration public double GetTd() Returns Type Description System.Double GetTi() Gets the Ti in seoncds Declaration public double GetTi() Returns Type Description System.Double IsReversed() Returns true if the K sign is to be reversed Declaration public bool IsReversed() Returns Type Description System.Boolean SetReversed() Specifies that Kp is to be reversed (By default Kp is not reversed) Declaration public void SetReversed()"
  },
  "api/TimeSeriesAnalysis.Dynamic.ProcessIdentWarnings.html": {
    "href": "api/TimeSeriesAnalysis.Dynamic.ProcessIdentWarnings.html",
    "title": "Enum ProcessIdentWarnings | TimeSeriesAnalysis reference documentation",
    "keywords": "Enum ProcessIdentWarnings Enum of recognized warning or error states during identification of process model Namespace : TimeSeriesAnalysis.Dynamic Assembly : TimeSeriesAnalysis.dll Syntax public enum ProcessIdentWarnings Fields Name Description DataSetVeryShortComparedtoTMax The dataset is time span is very short compared to the maximal time-constant given as input to the algorithm Nothing No errors or warnings NotPossibleToIdentify It was not possible to identify the ReEstimateBiasFailed Re-estimating bias method returned null, so the bias from the intial estimation is used, be careful the bias estimate may be off! RegressionProblemFailedToYieldSolution TimeConstantEstimateNotConsistent Time constant estimates vary significantly across dataset, indicating that something is wrong TimeConstantEstimateTooBig Estimation returned an enourmous time constant, this is an indication of something is wrong TimeConstantNotIdentifiable Time constant is not identifiable from dataset TimeDelayAtMaximumConstraint The time delay which gave the lowest objective function is the biggest allowed time delay consider increasing this limit or if something is wrong TimeDelayInternalInconsistencyBetweenObjFunAndUncertainty When considering different time delays internally, you expect the \"best\" to have both the lowest objective functino and the lowest paramter uncertainty but for some reason this is not the case"
  },
  "api/TimeSeriesAnalysis.Dynamic.ProcessModelType.html": {
    "href": "api/TimeSeriesAnalysis.Dynamic.ProcessModelType.html",
    "title": "Enum ProcessModelType | TimeSeriesAnalysis reference documentation",
    "keywords": "Enum ProcessModelType Enum of recognized types of unit-models. This type is used to set the unit model unique identifier and is also used in internal logic in the large-scale dynamic simulations Namespace : TimeSeriesAnalysis.Dynamic Assembly : TimeSeriesAnalysis.dll Syntax public enum ProcessModelType Fields Name Description Disturbance Disturbance model PID PID-controller model Select Select-block SubProcess SubProcess model (a \"normal\" unit process) UnTyped Type is not set"
  },
  "api/TimeSeriesAnalysis.Dynamic.ProcessSimulator.html": {
    "href": "api/TimeSeriesAnalysis.Dynamic.ProcessSimulator.html",
    "title": "Class ProcessSimulator | TimeSeriesAnalysis reference documentation",
    "keywords": "Class ProcessSimulator Simulates larger \"plant-models\" that is built up connected sub-models, that each implement ISimulatableModel To set up a simulation, first connect models, and then add external input signals. This class handles information about which model is connected to which, and handles callig sub-models in the correct order with the correct input signals. By default, the model attempts to start in steady-state, intalization handled by ProcessSimulatorInitalizer (this requires no user interaction) The building blocks of plant models are PIDModel , DefaultProcessModel and Select DefaultProcessModel PIDModel ProcessSimulatorInitalizer Select Inheritance System.Object ProcessSimulator Inherited Members System.Object.ToString() System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.ReferenceEquals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() Namespace : TimeSeriesAnalysis.Dynamic Assembly : TimeSeriesAnalysis.dll Syntax public class ProcessSimulator Constructors ProcessSimulator(Int32, List<ISimulatableModel>) Constructor Declaration public ProcessSimulator(int timeBase_s, List<ISimulatableModel> processModelList) Parameters Type Name Description System.Int32 timeBase_s System.Collections.Generic.List < ISimulatableModel > processModelList A list of process models, each implementing ISimulatableModel Methods AddSignal(ISimulatableModel, SignalType, Double[], Int32) Both connects and adds data to signal that is to be inputted into a specific sub-model, Declaration public string AddSignal(ISimulatableModel model, SignalType type, double[] values, int index = 0) Parameters Type Name Description ISimulatableModel model SignalType type System.Double [] values System.Int32 index the index of the signal, this is only needed if this is an input to a multip-input model Returns Type Description System.String ConnectModels(ISimulatableModel, ISimulatableModel, Nullable<Int32>) Connect the output of the upstream model to the input of the downstream model Declaration public string ConnectModels(ISimulatableModel upstreamModel, ISimulatableModel downstreamModel, int? inputIndex = null) Parameters Type Name Description ISimulatableModel upstreamModel the upstream model, meaning the model whose output will be connected ISimulatableModel downstreamModel the downstream model, meaning the model whose input will be connected System.Nullable < System.Int32 > inputIndex input index of the downstream model to connect to (default is first input) Returns Type Description System.String returns the signal id if all is ok, otherwise null. ConnectModelToOutput(ISimulatableModel, ISimulatableModel) Add a disturbance model to the output a given model Declaration public bool ConnectModelToOutput(ISimulatableModel disturbanceModel, ISimulatableModel model) Parameters Type Name Description ISimulatableModel disturbanceModel ISimulatableModel model Returns Type Description System.Boolean ConnectSignal(String, ISimulatableModel, Int32) Connect an existing signal with a given signalID to a new model Declaration public bool ConnectSignal(string signalID, ISimulatableModel model, int idx) Parameters Type Name Description System.String signalID ISimulatableModel model System.Int32 idx Returns Type Description System.Boolean GetConnections() Get ConnenectionParser object Declaration public ConnectionParser GetConnections() Returns Type Description ConnectionParser GetExternalSignals() Get a TimeSeriesDataSet of all external signals of model Declaration public TimeSeriesDataSet GetExternalSignals() Returns Type Description TimeSeriesDataSet GetModels() Get dictionary of all models Declaration public Dictionary<string, ISimulatableModel> GetModels() Returns Type Description System.Collections.Generic.Dictionary < System.String , ISimulatableModel > Simulate(out TimeSeriesDataSet) Perform a dynamic simulation of the model provided, given the specified connections and external signals Declaration public bool Simulate(out TimeSeriesDataSet simData) Parameters Type Name Description TimeSeriesDataSet simData the simulated data set to be outputted(includes the external signals) Returns Type Description System.Boolean"
  },
  "api/TimeSeriesAnalysis.Dynamic.ProcessSimulatorInitalizer.html": {
    "href": "api/TimeSeriesAnalysis.Dynamic.ProcessSimulatorInitalizer.html",
    "title": "Class ProcessSimulatorInitalizer | TimeSeriesAnalysis reference documentation",
    "keywords": "Class ProcessSimulatorInitalizer Intializes a simulator in the first data point Currently, only initalizing to steady-state is supported. By design choice, this class traverses the models by logic to initialize the plant model rather than using mathematical programming/matrix solvers. Inheritance System.Object ProcessSimulatorInitalizer Inherited Members System.Object.ToString() System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.ReferenceEquals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() Namespace : TimeSeriesAnalysis.Dynamic Assembly : TimeSeriesAnalysis.dll Syntax public class ProcessSimulatorInitalizer Constructors ProcessSimulatorInitalizer(ProcessSimulator) Constructor Declaration public ProcessSimulatorInitalizer(ProcessSimulator simulator) Parameters Type Name Description ProcessSimulator simulator simulator object that already includes connections,models and signals to be simulated Methods ToSteadyState(ref TimeSeriesDataSet) Initalize the empty datasets to their steady-state values Declaration public bool ToSteadyState(ref TimeSeriesDataSet simData) Parameters Type Name Description TimeSeriesDataSet simData simulation dataset containing only the external signals. The new simulated variables are added to this variable with initial values. Returns Type Description System.Boolean"
  },
  "api/TimeSeriesAnalysis.Dynamic.ProcessTimeDelayIdentWarnings.html": {
    "href": "api/TimeSeriesAnalysis.Dynamic.ProcessTimeDelayIdentWarnings.html",
    "title": "Enum ProcessTimeDelayIdentWarnings | TimeSeriesAnalysis reference documentation",
    "keywords": "Enum ProcessTimeDelayIdentWarnings Enum of recognized warning or error states during identification of time delays Namespace : TimeSeriesAnalysis.Dynamic Assembly : TimeSeriesAnalysis.dll Syntax public enum ProcessTimeDelayIdentWarnings Fields Name Description NonConvexObjectiveFunctionSolutionSpace There are other good time delay estimates based on objective function value that are not near the best value This is an indication that something is wrong. NonConvexRsquaredSolutionSpace There are other good time delay estimates based on Rsquared that are not near the best value This is an indication that something is wrong. Nothing No errors or warnings NoUniqueObjectiveFunctionMinima There are several eqvivalently good time delay estiamtes when judged by objective function value. NoUniqueRsquaredMinima There are several eqvivalently good time delay estiamtes when judged by Rsquared. SomeModelRunsFailedToFindSolution Warning that some of the model runs (i.e. for certain time delays) failed to yield a solution. This could be because there is very little information in the dataset, and if most of the information is at the very start this warning can arise as to test longer and longer time delays, a shorter and shorter portion of the dataset is used(some data at the very start needs to be \"cut off\")"
  },
  "api/TimeSeriesAnalysis.Dynamic.Select.html": {
    "href": "api/TimeSeriesAnalysis.Dynamic.Select.html",
    "title": "Class Select | TimeSeriesAnalysis reference documentation",
    "keywords": "Class Select Simulatable select block This block can function either as \"minimum\" or \"maximum\" selector. It can be used either for enforcing ranges in plant simulations, but also for simulating \"min select\" or \"max selct\" pid-control by combining with PIDModel Inheritance System.Object ModelBaseClass Select Implements ISimulatableModel Inherited Members ModelBaseClass.GetID() ModelBaseClass.SetID(String) ModelBaseClass.SetProcessModelType(ProcessModelType) ModelBaseClass.GetProcessModelType() ModelBaseClass.SetInputIDs(String[], Nullable<Int32>) ModelBaseClass.AddSignalToOutput(String) ModelBaseClass.GetModelInputIDs() ModelBaseClass.GetAdditiveInputIDs() ModelBaseClass.GetBothKindsOfInputIDs() ModelBaseClass.SetOutputID(String) ModelBaseClass.GetOutputID() ModelBaseClass.GetLengthOfInputVector() System.Object.ToString() System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.ReferenceEquals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() Namespace : TimeSeriesAnalysis.Dynamic Assembly : TimeSeriesAnalysis.dll Syntax public class Select : ModelBaseClass, ISimulatableModel Constructors Select(SelectType, String) Constructor Declaration public Select(SelectType type, string ID) Parameters Type Name Description SelectType type System.String ID Select(SelectType, String, Double, Double) Constructor with thresholds for range Declaration public Select(SelectType type, string ID, double threshold1, double threshold2) Parameters Type Name Description SelectType type System.String ID System.Double threshold1 System.Double threshold2 Methods GetOutputSignalType() Gives the type of the output signal Declaration public override SignalType GetOutputSignalType() Returns Type Description SignalType Overrides ModelBaseClass.GetOutputSignalType() GetSteadyStateInput(Double, Int32, Double[]) Declaration public double? GetSteadyStateInput(double y0, int inputIdx = 0, double[] givenInputValues = null) Parameters Type Name Description System.Double y0 System.Int32 inputIdx System.Double [] givenInputValues Returns Type Description System.Nullable < System.Double > GetSteadyStateOutput(Double[]) Get the steady state value of the model output Declaration public double? GetSteadyStateOutput(double[] u0) Parameters Type Name Description System.Double [] u0 vector of inputs for which the steady state is to be calculated Returns Type Description System.Nullable < System.Double > the steady-state value, if it is not possible to calculate, a null is returned Iterate(Double[], Double) Iterate simulation Declaration public double Iterate(double[] inputsU, double badDataID = -9999) Parameters Type Name Description System.Double [] inputsU System.Double badDataID Returns Type Description System.Double WarmStart(Double[], Double) Declaration public void WarmStart(double[] inputs, double output) Parameters Type Name Description System.Double [] inputs System.Double output Implements ISimulatableModel"
  },
  "api/TimeSeriesAnalysis.Dynamic.SelectType.html": {
    "href": "api/TimeSeriesAnalysis.Dynamic.SelectType.html",
    "title": "Enum SelectType | TimeSeriesAnalysis reference documentation",
    "keywords": "Enum SelectType An enum of the type of Select model Namespace : TimeSeriesAnalysis.Dynamic Assembly : TimeSeriesAnalysis.dll Syntax public enum SelectType Fields Name Description MAX Max-select MIN Min-select NOT_SET This value should not occur RANGE Range: Forces signal to stay above a given minimum and below a given maximum"
  },
  "api/TimeSeriesAnalysis.Dynamic.SignalType.html": {
    "href": "api/TimeSeriesAnalysis.Dynamic.SignalType.html",
    "title": "Enum SignalType | TimeSeriesAnalysis reference documentation",
    "keywords": "Enum SignalType Enum of types of signals that ProcessSimulator must differentiate between Namespace : TimeSeriesAnalysis.Dynamic Assembly : TimeSeriesAnalysis.dll Syntax public enum SignalType Fields Name Description Disturbance_D The disturbance on the output of a \"Process\" External_U An input to a model that is not from a simulated PID-controller NonPIDInternal_U An input to a model that is an output of another process-model Output_Y_sim The simulated output of a \"Process\" PID_U The output/manipulated variable of a PID-controller SelectorOut The output of a select block Setpoint_Yset Setpoint of a PID-controller Unset Unset, should not occur"
  },
  "api/TimeSeriesAnalysis.Dynamic.SubProcessDataSet.html": {
    "href": "api/TimeSeriesAnalysis.Dynamic.SubProcessDataSet.html",
    "title": "Class SubProcessDataSet | TimeSeriesAnalysis reference documentation",
    "keywords": "Class SubProcessDataSet The data for a porition of a process, containg only one output and one or multiple inputs that influence it Inheritance System.Object SubProcessDataSet Inherited Members System.Object.ToString() System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.ReferenceEquals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() Namespace : TimeSeriesAnalysis.Dynamic Assembly : TimeSeriesAnalysis.dll Syntax public class SubProcessDataSet Constructors SubProcessDataSet(Double, Double[,], Double[], String) Constructor for dta set with inputs U , i.e. where a relationship that at least partially explains y_meas is konwn Declaration public SubProcessDataSet(double timeBase_s, double[, ] U, double[] y_meas = null, string name = null) Parameters Type Name Description System.Double timeBase_s the time base in seconds System.Double [,] U The number of rows of the 2D-array U determines the duration dataset System.Double [] y_meas the measured output of the system, can be null System.String name optional internal name of dataset SubProcessDataSet(Double, Int32, String) Constructor for data set without inputs - for \"autonomous\" processes such as sinusoids, rand walks or other disturbancs. Declaration public SubProcessDataSet(double timeBase_s, int numDataPoints, string name = null) Parameters Type Name Description System.Double timeBase_s the time base in seconds System.Int32 numDataPoints the desired nubmer of datapoints of the dataset System.String name optional internal name of dataset Fields t0 Declaration public DateTime t0 Field Value Type Description System.DateTime Properties BadDataID Some systems for storing data do not support \"NaN\", but instead some other magic value is reserved for indicating that a value is bad or missing. Declaration public double BadDataID { get; set; } Property Value Type Description System.Double D Declaration public double[] D { get; set; } Property Value Type Description System.Double [] NumDataPoints Declaration public int NumDataPoints { get; } Property Value Type Description System.Int32 ProcessName Declaration public string ProcessName { get; } Property Value Type Description System.String TimeBase_s Declaration public double TimeBase_s { get; set; } Property Value Type Description System.Double Times Declaration public DateTime[] Times { get; } Property Value Type Description System.DateTime [] U Declaration public double[, ] U { get; set; } Property Value Type Description System.Double [,] U_sim Declaration public double[, ] U_sim { get; set; } Property Value Type Description System.Double [,] warnings Declaration public List<SubProcessDataSetWarnings> warnings { get; set; } Property Value Type Description System.Collections.Generic.List < SubProcessDataSetWarnings > Y_meas Declaration public double[] Y_meas { get; set; } Property Value Type Description System.Double [] Y_setpoint If subprocess includes a PID-controller, this value should be non-null Declaration public double[] Y_setpoint { get; set; } Property Value Type Description System.Double [] Y_sim Declaration public double[] Y_sim { get; set; } Property Value Type Description System.Double [] Methods GetAverageU() Get the average value of each input in the dataset. This is useful when defining model local around a working point. Declaration public double[] GetAverageU() Returns Type Description System.Double [] an array of averages, each corrsponding to one column of U. Returns null if it was not possible to calculate averages GetTimeSpan() Get the time spanned by the dataset Declaration public TimeSpan GetTimeSpan() Returns Type Description System.TimeSpan The time spanned by the dataset"
  },
  "api/TimeSeriesAnalysis.Dynamic.SubProcessDataSetWarnings.html": {
    "href": "api/TimeSeriesAnalysis.Dynamic.SubProcessDataSetWarnings.html",
    "title": "Enum SubProcessDataSetWarnings | TimeSeriesAnalysis reference documentation",
    "keywords": "Enum SubProcessDataSetWarnings Enum of recognized warning or error states during identification of process model Namespace : TimeSeriesAnalysis.Dynamic Assembly : TimeSeriesAnalysis.dll Syntax public enum SubProcessDataSetWarnings Fields Name Description FailedToInitializePIDcontroller Failed to initalize the PID-controller Nothing No errors or warnings"
  },
  "api/TimeSeriesAnalysis.Dynamic.SubProcessSimulator.html": {
    "href": "api/TimeSeriesAnalysis.Dynamic.SubProcessSimulator.html",
    "title": "Class SubProcessSimulator | TimeSeriesAnalysis reference documentation",
    "keywords": "Class SubProcessSimulator Simulate any subprocess model that has implemented the IProcessModel interface. This class relies on depencency injection and interfaces, so that the the specifics of how models outputs are calculated should be encapsulated in the passed model objects. This class should not be static, as it is to be used as a type for MultiProcessSimulator Inheritance System.Object SubProcessSimulator Inherited Members System.Object.ToString() System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.ReferenceEquals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() Namespace : TimeSeriesAnalysis.Dynamic Assembly : TimeSeriesAnalysis.dll Syntax public class SubProcessSimulator Constructors SubProcessSimulator(ISimulatableModel) Declaration public SubProcessSimulator(ISimulatableModel model) Parameters Type Name Description ISimulatableModel model Methods CoSimulateProcessAndPID(PIDModel, ref SubProcessDataSet, Boolean) Co-simulate a process model and pid-controller Declaration public bool CoSimulateProcessAndPID(PIDModel pid, ref SubProcessDataSet processDataSet, bool writeResultToYmeasInsteadOfYsim = false) Parameters Type Name Description PIDModel pid the SubProcessDataSet processDataSet the process will read the .Disturbance and .TimeBase_s , and write simulated inputs to .U and .Y_sim System.Boolean writeResultToYmeasInsteadOfYsim write data to processDataSet.Y_meas instead of processDataSet.Y_sim Returns Type Description System.Boolean Returns true if able to simulate, otherwise false (simulation is written into processDataSet ) EmulateYmeas(ref SubProcessDataSet, Double) Simulation is written to ymeas instead of ysim. This is useful when creating generic datasets for testing/test driven development. Declaration public void EmulateYmeas(ref SubProcessDataSet processDataSet, double noiseAmplitude = 0) Parameters Type Name Description SubProcessDataSet processDataSet System.Double noiseAmplitude optionally adds noise to the \"measured\" y (for testing purposes) Simulate(ref SubProcessDataSet, Boolean, Boolean) Simulates the output of the model based on the processDataSet.U provided, by default the output is written back to processDataSet.Y_sim or processDataSet.Y_meas By default this method adds to Y_sim o Y_meas if they already contain values. Declaration public double[] Simulate(ref SubProcessDataSet processDataSet, bool writeResultToYmeasInsteadOfYsim = false, bool doOverwriteY = false) Parameters Type Name Description SubProcessDataSet processDataSet dataset containing the inputs U to be simulated System.Boolean writeResultToYmeasInsteadOfYsim if true , output is written to processDataSet.ymeas instead of processDataSet.ysim System.Boolean doOverwriteY (default is false)if true , output overwrites any data in processDataSet.ymeas or processDataSet.ysim Returns Type Description System.Double [] Returns the simulate y if able to simulate,otherwise null"
  },
  "api/TimeSeriesAnalysis.Dynamic.TimeDelay.html": {
    "href": "api/TimeSeriesAnalysis.Dynamic.TimeDelay.html",
    "title": "Class TimeDelay | TimeSeriesAnalysis reference documentation",
    "keywords": "Class TimeDelay Delays a signal by a specific number of time steps, keeping an internal buffer of delayed values between iterations. This is a reasuble class for providing time-delay functionality to simulatable models. Inheritance System.Object TimeDelay Inherited Members System.Object.ToString() System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.ReferenceEquals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() Namespace : TimeSeriesAnalysis.Dynamic Assembly : TimeSeriesAnalysis.dll Syntax public class TimeDelay Constructors TimeDelay(Double, Double) Initalize Declaration public TimeDelay(double timeBase_s, double timeDelay_s) Parameters Type Name Description System.Double timeBase_s the simulation time interval between each subsequent call to Delay (in seconds) System.Double timeDelay_s the time delay to be simulated(in seconds). Note that the time delay will be rounded up to neares whole number factor of timeBase_s Methods Delay(Double) Delays output by a certain number of time steps Declaration public double Delay(double inputSignal) Parameters Type Name Description System.Double inputSignal input signal to be delayed Returns Type Description System.Double a version of inputSignal that is delayed"
  },
  "api/TimeSeriesAnalysis.Dynamic.TimeSeriesDataSet.html": {
    "href": "api/TimeSeriesAnalysis.Dynamic.TimeSeriesDataSet.html",
    "title": "Class TimeSeriesDataSet | TimeSeriesAnalysis reference documentation",
    "keywords": "Class TimeSeriesDataSet A class that holds time-series data for a number of tags This is the return data class of the ProcessSimulator Inheritance System.Object TimeSeriesDataSet Inherited Members System.Object.ToString() System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.ReferenceEquals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() Namespace : TimeSeriesAnalysis.Dynamic Assembly : TimeSeriesAnalysis.dll Syntax public class TimeSeriesDataSet Constructors TimeSeriesDataSet(Int32) Constructor Declaration public TimeSeriesDataSet(int timeBase_s) Parameters Type Name Description System.Int32 timeBase_s TimeSeriesDataSet(Int32, TimeSeriesDataSet) Constructor Declaration public TimeSeriesDataSet(int timeBase_s, TimeSeriesDataSet inputDataSet) Parameters Type Name Description System.Int32 timeBase_s TimeSeriesDataSet inputDataSet Methods AddDataPoint(String, Int32, Double) Add a single data point Declaration public bool AddDataPoint(string signalID, int idx, double value) Parameters Type Name Description System.String signalID System.Int32 idx System.Double value Returns Type Description System.Boolean returns false if signal does not already exist or if index is beyond dataset size AddSet(TimeSeriesDataSet) Adds all signals in a given set to this set Declaration public bool AddSet(TimeSeriesDataSet inputDataSet) Parameters Type Name Description TimeSeriesDataSet inputDataSet Returns Type Description System.Boolean AddTimeSeries(String, Double[]) Add an entire time-series to the dataset Declaration public bool AddTimeSeries(string signalName, double[] values) Parameters Type Name Description System.String signalName System.Double [] values Returns Type Description System.Boolean AddTimeSeries(String, SignalType, Double[], Int32) Add an entire time-series to the dataset, without specifying the signalID explicitly Declaration public string AddTimeSeries(string processID, SignalType type, double[] values, int index = 0) Parameters Type Name Description System.String processID SignalType type System.Double [] values System.Int32 index Returns Type Description System.String ContainsSignal(String) Determine if a specific signal is in the dataset Declaration public bool ContainsSignal(string signalID) Parameters Type Name Description System.String signalID Returns Type Description System.Boolean GetData(String[], Int32) Get Data for multiple signals at a specific time index Declaration public double[] GetData(string[] signalNames, int timeIdx) Parameters Type Name Description System.String [] signalNames System.Int32 timeIdx Returns Type Description System.Double [] May return null if an error occured GetLength() Get the length in samples of the data set Declaration public int? GetLength() Returns Type Description System.Nullable < System.Int32 > GetSignalNames() Get the names of all the singals Declaration public string[] GetSignalNames() Returns Type Description System.String [] GetSimStatus() Returns the simualtion status Declaration public bool GetSimStatus() Returns Type Description System.Boolean GetValues(String) Get the values of a specific signal Declaration public double[] GetValues(string signalName) Parameters Type Name Description System.String signalName Returns Type Description System.Double [] GetValues(String, SignalType, Int32) Get the values of a specific signal Declaration public double[] GetValues(string processID, SignalType signalType, int index = 0) Parameters Type Name Description System.String processID SignalType signalType System.Int32 index Returns Type Description System.Double [] SetSimStatus(Boolean) Set the termination status of the simualtion Declaration public bool SetSimStatus(bool didSimulationTerminateOk) Parameters Type Name Description System.Boolean didSimulationTerminateOk Returns Type Description System.Boolean returns the same status given in"
  },
  "api/TimeSeriesAnalysis.html": {
    "href": "api/TimeSeriesAnalysis.html",
    "title": "Namespace TimeSeriesAnalysis | TimeSeriesAnalysis reference documentation",
    "keywords": "Namespace TimeSeriesAnalysis Classes Array2D Non-generic 2D-array methods Array2D<T> Generic array operations that can be done on arrays of any type, for operators specific to numerical arrays(matrices) see Matrix.cs Array2DExtensionMethods Extension methods based on Array2D Matrix Operations for treating 2D-arrays as mathetmatical matrices RegressionResults Class that holds the results of a run of Vec.Regress . Shared Globals Should only be used for logging, setting/getting configurations. Vec Utility functions and operations for treating arrays as mathetmatical vectors. This class considers doubles, methods that require comparisons cannot be easily ported to generic (Vec) Vec<T> Class for generic methods on any type T that treat arrays as vectors (sorting,slicing,concatenating). For mathematical methods on vectors of doubles and integers, look into non-generic sister class \"Vec\". VecExtensionMethods Utility functions and operations for treating arrays as mathetmatical vectors Enums VectorFindValueType Input to Vec.FindValues which specifies the criteria of the search VectorSortType Input to Vec.Sort that specifies how values are to be sorted"
  },
  "api/TimeSeriesAnalysis.Matrix.html": {
    "href": "api/TimeSeriesAnalysis.Matrix.html",
    "title": "Class Matrix | TimeSeriesAnalysis reference documentation",
    "keywords": "Class Matrix Operations for treating 2D-arrays as mathetmatical matrices Inheritance System.Object Matrix Inherited Members System.Object.ToString() System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.ReferenceEquals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() Namespace : TimeSeriesAnalysis Assembly : TimeSeriesAnalysis.dll Syntax public static class Matrix Methods AppendRow(Double[,], Double[]) Appends another row onto an existing matrix. Returns null if this was not possible(ie. dimnesions dont agree). Declaration public static double[, ] AppendRow(double[, ] matrix, double[] newRowVec) Parameters Type Name Description System.Double [,] matrix System.Double [] newRowVec Returns Type Description System.Double [,] ComponentMult(Double[,], Double[], Int32) Multipliy either entire matrix or single row(optional third input) by a vector (returns a matrix) Declaration public static double[, ] ComponentMult(double[, ] matrix, double[] vector, int singleMatrixRowToMult = -1) Parameters Type Name Description System.Double [,] matrix System.Double [] vector System.Int32 singleMatrixRowToMult Returns Type Description System.Double [,] Mult(Double[,], Double, Int32) Multipliy either entire matrix or single row(optional third input) by a scalar Declaration public static double[, ] Mult(double[, ] matrix, double scalar, int singleMatrixRowToMult = -1) Parameters Type Name Description System.Double [,] matrix System.Double scalar System.Int32 singleMatrixRowToMult Returns Type Description System.Double [,] Mult(Double[,], Double[]) Multipliy either entire matrix or single row(optional third input) by a vector (returns vector) Declaration public static double[] Mult(double[, ] matrix, double[] vector) Parameters Type Name Description System.Double [,] matrix System.Double [] vector Returns Type Description System.Double [] ReplaceColumn(Double[,], Int32, Double[]) Replace a single column of a matrix Declaration public static double[, ] ReplaceColumn(double[, ] matrix, int colIndex, double[] newColVec) Parameters Type Name Description System.Double [,] matrix System.Int32 colIndex System.Double [] newColVec Returns Type Description System.Double [,] ReplaceRow(Double[,], Int32, Double[]) Replace a single row of a matrix Declaration public static double[, ] ReplaceRow(double[, ] matrix, int rowIndex, double[] newRowVec) Parameters Type Name Description System.Double [,] matrix System.Int32 rowIndex System.Double [] newRowVec Returns Type Description System.Double [,]"
  },
  "api/TimeSeriesAnalysis.RegressionResults.html": {
    "href": "api/TimeSeriesAnalysis.RegressionResults.html",
    "title": "Class RegressionResults | TimeSeriesAnalysis reference documentation",
    "keywords": "Class RegressionResults Class that holds the results of a run of Vec.Regress . Inheritance System.Object RegressionResults Inherited Members System.Object.ToString() System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.ReferenceEquals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() Namespace : TimeSeriesAnalysis Assembly : TimeSeriesAnalysis.dll Syntax public class RegressionResults Constructors RegressionResults() Default constructor, sets all values to null or zero. Declaration public RegressionResults() Properties AbleToIdentify True if able to identify, otherwise false Declaration public bool AbleToIdentify { get; set; } Property Value Type Description System.Boolean Bias The bias term of the linear regression Declaration public double Bias { get; set; } Property Value Type Description System.Double Gains The gains of the linear regression Declaration public double[] Gains { get; set; } Property Value Type Description System.Double [] NfittingBadDataPoints Number of bad data point ignored in the fitting data set Declaration public int NfittingBadDataPoints { get; set; } Property Value Type Description System.Int32 NfittingTotalDataPoints Total number of data points in the fitting data set Declaration public int NfittingTotalDataPoints { get; set; } Property Value Type Description System.Int32 ObjectiveFunctionValue The value of the objective function after regression Declaration public double ObjectiveFunctionValue { get; set; } Property Value Type Description System.Double Param All regression paramters, first the gains, then the bias term. Declaration public double[] Param { get; set; } Property Value Type Description System.Double [] Param95prcConfInterval The 95 percent confidence intervals of parameters Declaration public double[] Param95prcConfInterval { get; set; } Property Value Type Description System.Double [] Rsq R2-root-means-squared between Y and Y_modelled for the tuning dataset(a value between 0 and 100, higher is better) Declaration public double Rsq { get; set; } Property Value Type Description System.Double VarCovarMatrix The variance/covariance matrix of the regression run Declaration public double[][] VarCovarMatrix { get; set; } Property Value Type Description System.Double [][] Y_modelled The modelled output Declaration public double[] Y_modelled { get; set; } Property Value Type Description System.Double []"
  },
  "api/TimeSeriesAnalysis.Shared.html": {
    "href": "api/TimeSeriesAnalysis.Shared.html",
    "title": "Class Shared | TimeSeriesAnalysis reference documentation",
    "keywords": "Class Shared Globals Should only be used for logging, setting/getting configurations. Inheritance System.Object Shared Inherited Members System.Object.ToString() System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.ReferenceEquals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() Namespace : TimeSeriesAnalysis Assembly : TimeSeriesAnalysis.dll Syntax public class Shared Methods DisablePlots() Disables all plotting Declaration public static void DisablePlots() EnablePlots() Enables all plotting Declaration public static void EnablePlots() GetParserObj() Returns the ParserFeedback object, which can be used to add loglines for info,warnings or errors Declaration public static ParserFeedback GetParserObj() Returns Type Description ParserFeedback the Parserfeedback object Examples Example usage: Shared.GetParserObj().AddWarning(\"This is a warning that can be shown on the console, written to file, or both\"); IsPlottingEnabled() Queries if plotting is enabled or not Declaration public static bool IsPlottingEnabled() Returns Type Description System.Boolean"
  },
  "api/TimeSeriesAnalysis.Utility.CSV.html": {
    "href": "api/TimeSeriesAnalysis.Utility.CSV.html",
    "title": "Class CSV | TimeSeriesAnalysis reference documentation",
    "keywords": "Class CSV IO Utility class for loading time-series data from a plain text comma-separated variable(CSV) file Inheritance System.Object CSV Inherited Members System.Object.ToString() System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.ReferenceEquals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() Namespace : TimeSeriesAnalysis.Utility Assembly : TimeSeriesAnalysis.dll Syntax public class CSV Methods LoadDataFromCSV(String, Char, out Double[,], out String[], out String[,]) Load time-series data from a CSV-file into variables for further processing Declaration public static bool LoadDataFromCSV(string filename, char separator, out double[, ] doubleData, out string[] variableNames, out string[, ] stringData) Parameters Type Name Description System.String filename path of file to be loaded System.Char separator separator character used to separate data in file System.Double [,] doubleData (output) the returned 2D array where each column is the data for one variable System.String [] variableNames (output) an array of the variable names in doubleData System.String [,] stringData (output)the raw data of the entire csv-file in a 2D array, only needed if parsing of other two variables has failed, and useful for retireving timestamps Returns Type Description System.Boolean LoadDataFromCSV(String, out Double[,], out String[], out String[,]) Load time-series data from a CSV-file into variables for further processing (using the default \";\" separator) Declaration public static bool LoadDataFromCSV(string filename, out double[, ] doubleData, out string[] variableNames, out string[, ] stringData) Parameters Type Name Description System.String filename path of file to be loaded System.Double [,] doubleData (output) the returned 2D array where each column is the data for one variable System.String [] variableNames (output) an array of the variable names in doubleData System.String [,] stringData (output)the raw data of the entire csv-file in a 2D array, only needed if parsing of other two variables has failed, and useful for retireving timestamps Returns Type Description System.Boolean RobustParseDouble(String, out Double) Loading string data into a double value. Declaration public static bool RobustParseDouble(string str, out double value) Parameters Type Name Description System.String str the string to be parsed System.Double value (output) is the value of the parsed double(if successfully parsed) Returns Type Description System.Boolean The method returns true if succesful, otherwise it returns false."
  },
  "api/TimeSeriesAnalysis.Utility.html": {
    "href": "api/TimeSeriesAnalysis.Utility.html",
    "title": "Namespace TimeSeriesAnalysis.Utility | TimeSeriesAnalysis reference documentation",
    "keywords": "Namespace TimeSeriesAnalysis.Utility Classes CSV IO Utility class for loading time-series data from a plain text comma-separated variable(CSV) file ParserFeedback Utility class is responsible for collecting feedback lines, such as warnings,error or info text to either the console window, visual-studio output/debug window, to a file structure or all. The class makes it easy to switch between displaying output to a console while debugging while to outputting to file when code moves to a server. Suitable for collecting debugging info from services that run many cases repeatedly. log levels: INFO,WARN,ERROR,FATAL (no debug messages here) Plot Static methods for plotting one or more time-series across one or more y-axes and one or more subplots by opening up Chrome calling a set of JavaScript plotting methods based on plotly.js Time-series are written as CSV-files to a specific folder on disk plotDataPath , before starting a chrome-window that loads a specific \"localhost\" plotlyURL that reads said CSV-files and initates an in-browser plot using plotly.js. For this method to work you need to be running a web server such as IIS that serves up a \"localhost\" plotlyURL as described in the documentation. If you sometimes need to disable plots (for instance if plotting code is included in unit tests) see Plot4Test Plot4Test Version of Plot class where plots code can be Enabled()/Disabled() programatically. This allows you to keep all your \"Plot\" calls in your unit tests and turn them on as needed to debug a single test, while avoid being overwhelmed with plots if for instance re-running all unit tests. SignificantDigits Utility class to round double variables to a given nubmer of signficant digits. StringToFileWriter IO Utility class to write to file that implements IDisposable interface. Suggest to use this objects of this class within the using keyword so that file-resources are automatically freed in case your code is terminated before it has completed. TimeSeriesCreator Class for static methods create different types of time-series for testing. UnixTime Utility class to work with unix time stamps Structs ParserFeedbackLogLine Struct for each log message of ParserFeedback Enums ParserfeedbackMessageLevel Enum to set the log level of ParserFeedback"
  },
  "api/TimeSeriesAnalysis.Utility.ParserFeedback.html": {
    "href": "api/TimeSeriesAnalysis.Utility.ParserFeedback.html",
    "title": "Class ParserFeedback | TimeSeriesAnalysis reference documentation",
    "keywords": "Class ParserFeedback Utility class is responsible for collecting feedback lines, such as warnings,error or info text to either the console window, visual-studio output/debug window, to a file structure or all. The class makes it easy to switch between displaying output to a console while debugging while to outputting to file when code moves to a server. Suitable for collecting debugging info from services that run many cases repeatedly. log levels: INFO,WARN,ERROR,FATAL (no debug messages here) Inheritance System.Object ParserFeedback Inherited Members System.Object.ToString() System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.ReferenceEquals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() Namespace : TimeSeriesAnalysis.Utility Assembly : TimeSeriesAnalysis.dll Syntax public class ParserFeedback Constructors ParserFeedback(Boolean) Constructor Declaration public ParserFeedback(bool doOutputAlsoToConsole = false) Parameters Type Name Description System.Boolean doOutputAlsoToConsole Methods AddError(String) Add an error message Declaration public void AddError(string message) Parameters Type Name Description System.String message AddFatalError(String) Adds a fatal error Declaration public void AddFatalError(string message) Parameters Type Name Description System.String message AddInfo(String) Adds an info message Declaration public void AddInfo(string message) Parameters Type Name Description System.String message AddWarning(String) Adds a warning Declaration public void AddWarning(string message) Parameters Type Name Description System.String message Close() Flushes all messages to file and closes file handlers. Declaration public void Close() CloseCaseLogFile() Close a log file belong to a perticular case Declaration public void CloseCaseLogFile() CreateCaseLogFile(String, Int32) Creates a new empty log file for a specific case name. Calling this function before StoreMessage will cause all messages to be copied to it. Declaration public void CreateCaseLogFile(string caseName, int caseNum) Parameters Type Name Description System.String caseName System.Int32 caseNum CreateCommonHTMLfile() Creates a html file, where is \"case\" is presented in an iframe- useful for quickly viewing many cases Needs SetCaseArray to be called first Declaration public void CreateCommonHTMLfile() CreateCommonLogFile(String) Creates a new empty log file and, resets counters etc. This is a \"common\" file if no cases are specificed Declaration public void CreateCommonLogFile(string loggDir) Parameters Type Name Description System.String loggDir EnableConsoleOutput(Boolean) Enable (or disable) console output - i.e. writing messages directly to screen (useful for debugging, but leave off if running on a server) Declaration public void EnableConsoleOutput(bool doEnable = true) Parameters Type Name Description System.Boolean doEnable EnableDebugOutput(Boolean) Enables or disables the output to Visual Studio debug window and to console out Declaration public void EnableDebugOutput(bool doEnable = true) Parameters Type Name Description System.Boolean doEnable GetFirstErrorOrWarning() Intended for unit tests, get the first error or warning message Declaration public string GetFirstErrorOrWarning() Returns Type Description System.String GetListOfAllLogLinesAtOrAboveLevel(ParserfeedbackMessageLevel) Returns all log lines at or above a specified level Declaration public List<string> GetListOfAllLogLinesAtOrAboveLevel(ParserfeedbackMessageLevel desiredLevel = ParserfeedbackMessageLevel.warn) Parameters Type Name Description ParserfeedbackMessageLevel desiredLevel Returns Type Description System.Collections.Generic.List < System.String > GetListOfAllLogLinesAtOrBelowLevel(ParserfeedbackMessageLevel) Returns all log lines at or belowe a specified level Declaration public List<string> GetListOfAllLogLinesAtOrBelowLevel(ParserfeedbackMessageLevel desiredLevel = ParserfeedbackMessageLevel.warn) Parameters Type Name Description ParserfeedbackMessageLevel desiredLevel Returns Type Description System.Collections.Generic.List < System.String > GetListOfAllLogLinesOfLevel(ParserfeedbackMessageLevel) Returns all log lines of a specified level Declaration public List<string> GetListOfAllLogLinesOfLevel(ParserfeedbackMessageLevel desiredLevel) Parameters Type Name Description ParserfeedbackMessageLevel desiredLevel Returns Type Description System.Collections.Generic.List < System.String > GetLogFilename() Returns the name of the current log file Declaration public string GetLogFilename() Returns Type Description System.String GetLogFilePath() Returns the path to which log files are written Declaration public string GetLogFilePath() Returns Type Description System.String IsNumberOfErrorsAndWarningsZero() For testing, this is a way to check that no errors or warnings have been given. Declaration public bool IsNumberOfErrorsAndWarningsZero() Returns Type Description System.Boolean ResetCounters() Reset all error and warning counters Declaration public void ResetCounters() SetCaseArray(String[]) If output is to be divided into multiple log files, set the names of each \"case\" Declaration public void SetCaseArray(string[] caseArray) Parameters Type Name Description System.String [] caseArray"
  },
  "api/TimeSeriesAnalysis.Utility.ParserFeedbackLogLine.html": {
    "href": "api/TimeSeriesAnalysis.Utility.ParserFeedbackLogLine.html",
    "title": "Struct ParserFeedbackLogLine | TimeSeriesAnalysis reference documentation",
    "keywords": "Struct ParserFeedbackLogLine Struct for each log message of ParserFeedback Inherited Members System.ValueType.Equals(System.Object) System.ValueType.GetHashCode() System.ValueType.ToString() System.Object.Equals(System.Object, System.Object) System.Object.ReferenceEquals(System.Object, System.Object) System.Object.GetType() Namespace : TimeSeriesAnalysis.Utility Assembly : TimeSeriesAnalysis.dll Syntax public struct ParserFeedbackLogLine Fields message Message Text Declaration public string message Field Value Type Description System.String messageLevel The level of the message Declaration public ParserfeedbackMessageLevel messageLevel Field Value Type Description ParserfeedbackMessageLevel time Time of message Declaration public DateTime time Field Value Type Description System.DateTime"
  },
  "api/TimeSeriesAnalysis.Utility.ParserfeedbackMessageLevel.html": {
    "href": "api/TimeSeriesAnalysis.Utility.ParserfeedbackMessageLevel.html",
    "title": "Enum ParserfeedbackMessageLevel | TimeSeriesAnalysis reference documentation",
    "keywords": "Enum ParserfeedbackMessageLevel Enum to set the log level of ParserFeedback Namespace : TimeSeriesAnalysis.Utility Assembly : TimeSeriesAnalysis.dll Syntax public enum ParserfeedbackMessageLevel Fields Name Description error Show error messages and above fatal Show only fatal error messages info Show information messages and above warn Show warning messages and above"
  },
  "api/TimeSeriesAnalysis.Utility.Plot.html": {
    "href": "api/TimeSeriesAnalysis.Utility.Plot.html",
    "title": "Class Plot | TimeSeriesAnalysis reference documentation",
    "keywords": "Class Plot Static methods for plotting one or more time-series across one or more y-axes and one or more subplots by opening up Chrome calling a set of JavaScript plotting methods based on plotly.js Time-series are written as CSV-files to a specific folder on disk plotDataPath , before starting a chrome-window that loads a specific \"localhost\" plotlyURL that reads said CSV-files and initates an in-browser plot using plotly.js. For this method to work you need to be running a web server such as IIS that serves up a \"localhost\" plotlyURL as described in the documentation. If you sometimes need to disable plots (for instance if plotting code is included in unit tests) see Plot4Test Inheritance System.Object Plot Inherited Members System.Object.ToString() System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.ReferenceEquals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() Namespace : TimeSeriesAnalysis.Utility Assembly : TimeSeriesAnalysis.dll Syntax public class Plot Methods FromList(List<Double[]>, List<String>, DateTime[], String, String, Boolean) Plot all variables in a list of doubles, that all have the same timestamps given by dataTimes Declaration public static string FromList(List<double[]> dataList, List<string> plotNames, DateTime[] dataTimes, string comment = null, string caseName = \"\", bool doStartChrome = true) Parameters Type Name Description System.Collections.Generic.List < System.Double []> dataList System.Collections.Generic.List < System.String > plotNames System.DateTime [] dataTimes common timestamps System.String comment System.String caseName System.Boolean doStartChrome Returns Type Description System.String FromList(List<Double[]>, List<String>, Int32, String, DateTime, String, Boolean) Plot values in a list of vectors dataList , when all vectors start at t0 and have a stedy sampling rate Declaration public static string FromList(List<double[]> dataList, List<string> plotNames, int dT_s, string comment = null, DateTime t0 = default(DateTime), string caseName = \"\", bool doStartChrome = true) Parameters Type Name Description System.Collections.Generic.List < System.Double []> dataList List of doubles, one entry for each time-series to be plotted System.Collections.Generic.List < System.String > plotNames List of string of unique names to describe each plot, prefixed by either \"y1=\"(top left),\"y2=\"(top right),\"y3=\"(bottom left) or \"y4=\"(bottom right) to denote what y-axis to plot the variable on System.Int32 dT_s the time between data samples in seconds System.String comment a comment that is shown in the plot System.DateTime t0 the DateTime of the first data point System.String caseName give each plot a casename if creating multiple plots with the re-occurring variable names System.Boolean doStartChrome By setting doStartChrome to false, you can skip opening up chrome, the link to figure will instead be returned Returns Type Description System.String The url of the resulting plot is returned FromList(List<(Double[], DateTime[])>, List<String>, String, String, Boolean) Plot data from a list of value-date tuples (each time-series can have unique time-vector with unique sampling) Declaration public static string FromList(List<(double[], DateTime[])> dataDateTupleList, List<string> plotNames, string comment = null, string caseName = \"\", bool doStartChrome = true) Parameters Type Name Description System.Collections.Generic.List < System.ValueTuple < System.Double [], System.DateTime []>> dataDateTupleList System.Collections.Generic.List < System.String > plotNames System.String comment System.String caseName System.Boolean doStartChrome Returns Type Description System.String"
  },
  "api/TimeSeriesAnalysis.Utility.Plot4Test.html": {
    "href": "api/TimeSeriesAnalysis.Utility.Plot4Test.html",
    "title": "Class Plot4Test | TimeSeriesAnalysis reference documentation",
    "keywords": "Class Plot4Test Version of Plot class where plots code can be Enabled()/Disabled() programatically. This allows you to keep all your \"Plot\" calls in your unit tests and turn them on as needed to debug a single test, while avoid being overwhelmed with plots if for instance re-running all unit tests. Inheritance System.Object Plot4Test Inherited Members System.Object.ToString() System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.ReferenceEquals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() Namespace : TimeSeriesAnalysis.Utility Assembly : TimeSeriesAnalysis.dll Syntax public class Plot4Test Constructors Plot4Test(Boolean, Int32) Determine wheter plots are to be enabled or disabled on. To further prevent thousands of plots from accidentally being created by this object a maximum number of plots is set, override as needed. Declaration public Plot4Test(bool enableByDefault = true, int maxNplots = 6) Parameters Type Name Description System.Boolean enableByDefault System.Int32 maxNplots Methods Disable() Disable all subsequent calls to plot using the same instance of this class. Declaration public void Disable() Enable() Enable all subsequent calls to plot using the same instance of this class. Declaration public void Enable() FromList(List<Double[]>, List<String>, Int32, String, DateTime, String, Boolean) Wrapper for Plot.FromList that Declaration public string FromList(List<double[]> dataList, List<string> plotNames, int dT_s, string comment = null, DateTime t0 = default(DateTime), string caseName = \"\", bool doStartChrome = true) Parameters Type Name Description System.Collections.Generic.List < System.Double []> dataList System.Collections.Generic.List < System.String > plotNames System.Int32 dT_s System.String comment System.DateTime t0 System.String caseName System.Boolean doStartChrome Returns Type Description System.String GetNumberOfPlotsMade() Gets the number of plots that have been written Declaration public int GetNumberOfPlotsMade() Returns Type Description System.Int32"
  },
  "api/TimeSeriesAnalysis.Utility.SignificantDigits.html": {
    "href": "api/TimeSeriesAnalysis.Utility.SignificantDigits.html",
    "title": "Class SignificantDigits | TimeSeriesAnalysis reference documentation",
    "keywords": "Class SignificantDigits Utility class to round double variables to a given nubmer of signficant digits. Inheritance System.Object SignificantDigits Inherited Members System.Object.ToString() System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.ReferenceEquals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() Namespace : TimeSeriesAnalysis.Utility Assembly : TimeSeriesAnalysis.dll Syntax public static class SignificantDigits Methods Format(Double, Int32) Rounds down to number of significant digits (26->20 if digits=1 for instance) Declaration public static double Format(double number, int digits) Parameters Type Name Description System.Double number System.Int32 digits Returns Type Description System.Double Format(Double, Int32, out Int32) Rounds down to number of significant digits (26->20 if digits=1 for instance) Declaration public static double Format(double number, int digits, out int exponent) Parameters Type Name Description System.Double number System.Int32 digits System.Int32 exponent Returns Type Description System.Double GetSciFormat(Double, out Double, out Int32) Returns number in scientific format with coefficient and exponential paramters Declaration public static void GetSciFormat(double number, out double coeff, out int exp) Parameters Type Name Description System.Double number System.Double coeff System.Int32 exp SciToDouble(Double, Int32) Converts a scientific number on the format coeff*10^exp to a double Declaration public static double SciToDouble(double coeff, int exp) Parameters Type Name Description System.Double coeff coefficient System.Int32 exp exponent Returns Type Description System.Double converted double"
  },
  "api/TimeSeriesAnalysis.Utility.StringToFileWriter.html": {
    "href": "api/TimeSeriesAnalysis.Utility.StringToFileWriter.html",
    "title": "Class StringToFileWriter | TimeSeriesAnalysis reference documentation",
    "keywords": "Class StringToFileWriter IO Utility class to write to file that implements IDisposable interface. Suggest to use this objects of this class within the using keyword so that file-resources are automatically freed in case your code is terminated before it has completed. Inheritance System.Object StringToFileWriter Implements System.IDisposable Inherited Members System.Object.ToString() System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.ReferenceEquals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() Namespace : TimeSeriesAnalysis.Utility Assembly : TimeSeriesAnalysis.dll Syntax public class StringToFileWriter : IDisposable Constructors StringToFileWriter(String) Constructor with local encodign Declaration public StringToFileWriter(string filename) Parameters Type Name Description System.String filename StringToFileWriter(String, Encoding) Constructor with specific encoding Declaration public StringToFileWriter(string filename, Encoding encoding) Parameters Type Name Description System.String filename file to be creates System.Text.Encoding encoding text encoding format Methods Close() Close file handles Declaration public void Close() CreateDirectoryStructure(String) creates directory on path if it does not exist Declaration public void CreateDirectoryStructure(string FilePath) Parameters Type Name Description System.String FilePath Dispose() Disposes Declaration public void Dispose() Dispose(Boolean) Dispose Declaration protected virtual void Dispose(bool disposing) Parameters Type Name Description System.Boolean disposing Write(String) Write a single line of text Declaration public void Write(string text) Parameters Type Name Description System.String text Implements System.IDisposable"
  },
  "api/TimeSeriesAnalysis.Utility.TimeSeriesCreator.html": {
    "href": "api/TimeSeriesAnalysis.Utility.TimeSeriesCreator.html",
    "title": "Class TimeSeriesCreator | TimeSeriesAnalysis reference documentation",
    "keywords": "Class TimeSeriesCreator Class for static methods create different types of time-series for testing. Inheritance System.Object TimeSeriesCreator Inherited Members System.Object.ToString() System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.ReferenceEquals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() Namespace : TimeSeriesAnalysis.Utility Assembly : TimeSeriesAnalysis.dll Syntax public static class TimeSeriesCreator Methods CreateDateStampArray(DateTime, Int32, Int32) Create an array of DateTimes starting at t0 of length N and with sampling interval dT_s Declaration public static DateTime[] CreateDateStampArray(DateTime t0, int dT_s, int N) Parameters Type Name Description System.DateTime t0 first datetime in the array to be created System.Int32 dT_s sampling internval System.Int32 N number of desired data points Returns Type Description System.DateTime [] Sinus(Double, Double, Int32, Int32) Create an array representing a sinus Declaration public static double[] Sinus(double amplitude, double sinusPeriod_s, int dT_s, int N) Parameters Type Name Description System.Double amplitude amplitud of sinus System.Double sinusPeriod_s time for a complete 360 degree period of the sinus in seconds System.Int32 dT_s the timebase System.Int32 N number of desired data point in return array Returns Type Description System.Double [] an array continaing the specified sinus Step(Int32, Int32, Double, Double) Create a step change vector of a given length N starting at value val1 and ending at val2 , step occuring at index stepStartIdx Declaration public static double[] Step(int stepStartIdx, int N, double val1, double val2) Parameters Type Name Description System.Int32 stepStartIdx index of step System.Int32 N total time series length System.Double val1 value before step System.Double val2 value after step Returns Type Description System.Double [] created vector, or null if inputs make no sense TwoSteps(Int32, Int32, Int32, Double, Double, Double) Create a time-series with two step changes Declaration public static double[] TwoSteps(int step1StartIdx, int step2StartIdx, int N, double val1, double val2, double val3) Parameters Type Name Description System.Int32 step1StartIdx index of first step change System.Int32 step2StartIdx index of second step change System.Int32 N System.Double val1 value before steps System.Double val2 value of first step System.Double val3 value of second step Returns Type Description System.Double []"
  },
  "api/TimeSeriesAnalysis.Utility.UnixTime.html": {
    "href": "api/TimeSeriesAnalysis.Utility.UnixTime.html",
    "title": "Class UnixTime | TimeSeriesAnalysis reference documentation",
    "keywords": "Class UnixTime Utility class to work with unix time stamps Inheritance System.Object UnixTime Inherited Members System.Object.ToString() System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.ReferenceEquals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() Namespace : TimeSeriesAnalysis.Utility Assembly : TimeSeriesAnalysis.dll Syntax public class UnixTime Methods ConvertFromUnixTimestamp(Double) Converts a unix timestamp into a DateTime Declaration public static DateTime ConvertFromUnixTimestamp(double timestamp) Parameters Type Name Description System.Double timestamp the double time stamp to be converted Returns Type Description System.DateTime a converted DateTime object ConvertToUnixTimestamp(DateTime) Converts a DateTime into a unix timestamp Declaration public static double ConvertToUnixTimestamp(DateTime date) Parameters Type Name Description System.DateTime date Returns Type Description System.Double A unix time stamp double GetNowUnixTime() Returns the Unix time of the current UTC-time. Declaration public static double GetNowUnixTime() Returns Type Description System.Double"
  },
  "api/TimeSeriesAnalysis.Vec.html": {
    "href": "api/TimeSeriesAnalysis.Vec.html",
    "title": "Class Vec | TimeSeriesAnalysis reference documentation",
    "keywords": "Class Vec Utility functions and operations for treating arrays as mathetmatical vectors. This class considers doubles, methods that require comparisons cannot be easily ported to generic (Vec) Inheritance System.Object Vec Inherited Members System.Object.ToString() System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.ReferenceEquals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() Namespace : TimeSeriesAnalysis Assembly : TimeSeriesAnalysis.dll Syntax public class Vec Constructors Vec(Double, Double) Constructor Declaration public Vec(double nanValue = -9999, double valuteToReturnElementIsNaN = NaN) Parameters Type Name Description System.Double nanValue inputs values matching this value are treated as \"NaN\" and are excluded from all calculations System.Double valuteToReturnElementIsNaN value to return in elementwise calculations to indiate Nan output Methods Abs(Double[]) returns an array where each value is the absolute value of array1 Declaration public double[] Abs(double[] array1) Parameters Type Name Description System.Double [] array1 Returns Type Description System.Double [] Add(Double[], Double) elementwise addition of val2 to array1 Declaration public double[] Add(double[] array1, double val2) Parameters Type Name Description System.Double [] array1 System.Double val2 Returns Type Description System.Double [] Add(Double[], Double[]) returns an array which is the elementwise addition of array1 and array2 Declaration public double[] Add(double[] array1, double[] array2) Parameters Type Name Description System.Double [] array1 System.Double [] array2 Returns Type Description System.Double [] Add(Int32[], Int32) elementwise addition of val2 to array1 Declaration public int[] Add(int[] array1, int val2) Parameters Type Name Description System.Int32 [] array1 System.Int32 val2 Returns Type Description System.Int32 [] AppendTrailingIndices(List<Int32>) When filtering out bad data before identification, before fitting data to difference equations that depend both y[k] and y[k-1] it will some times be neccessary, to append the trailing indices for instance on Declaration public static List<int> AppendTrailingIndices(List<int> indiceArray) Parameters Type Name Description System.Collections.Generic.List < System.Int32 > indiceArray Returns Type Description System.Collections.Generic.List < System.Int32 > ContainsBadData(Double[]) Returns true f array contains a \"-9999\" or NaN indicating missing data Declaration public bool ContainsBadData(double[] x) Parameters Type Name Description System.Double [] x Returns Type Description System.Boolean Cov(Double[], Double[], Boolean) returns the co-variance of two arrays(interpreted as \"vectors\") Declaration public double Cov(double[] array1, double[] array2, bool doNormalize = false) Parameters Type Name Description System.Double [] array1 System.Double [] array2 System.Boolean doNormalize Returns Type Description System.Double Deserialize(String) de-serializes a single vector/array (written by serialize) Declaration public static double[] Deserialize(string fileName) Parameters Type Name Description System.String fileName Returns Type Description System.Double [] Diff(Double[]) returns an array of the difference between every neighbhoring item in array Declaration public double[] Diff(double[] array) Parameters Type Name Description System.Double [] array Returns Type Description System.Double [] Div(Double[], Double) Divides an vector by a scalar value Declaration public double[] Div(double[] vector, double scalar) Parameters Type Name Description System.Double [] vector System.Double scalar Returns Type Description System.Double [] an vector of values representing the array didived by a scalar. In case of NaN inputs or divide-by-zero NaN elements are returned. Div(Double[], Double[]) Divides two vectors of equal length Declaration public double[] Div(double[] vector1, double[] vector2) Parameters Type Name Description System.Double [] vector1 System.Double [] vector2 Returns Type Description System.Double [] an vector of values representing the array didived by a scalar. In case of NaN inputs or divide-by-zero NaN elements are returned FindValues(Double[], Double, VectorFindValueType) return the indices of elements in the array that have certain relation to value given type (bigger,smaller,equal etc.) Also capable of finding NaN values Declaration public List<int> FindValues(double[] vec, double value, VectorFindValueType type) Parameters Type Name Description System.Double [] vec System.Double value VectorFindValueType type Returns Type Description System.Collections.Generic.List < System.Int32 > InverseIndices(Int32, List<Int32>) given a list of sorted indeces and a desired vector size N, returns the indices that are not in \"sortedIndices\" i.e. of the \"other vectors Declaration public static List<int> InverseIndices(int N, List<int> sortedIndices) Parameters Type Name Description System.Int32 N System.Collections.Generic.List < System.Int32 > sortedIndices Returns Type Description System.Collections.Generic.List < System.Int32 > IsAllNaN(Double[]) Returns true if all elements in array are \"-9999\" or Double.NaN Declaration public bool IsAllNaN(double[] array) Parameters Type Name Description System.Double [] array Returns Type Description System.Boolean IsAllValue(Double[], Double) Returns true if all elements in array are the specific value Declaration public static bool IsAllValue(double[] array, double value = 0) Parameters Type Name Description System.Double [] array System.Double value Returns Type Description System.Boolean MakeIndexArray(Int32, Int32) creates a monotonically increasing integer (11.12.13...) array starting at startValue and ending at endValue Declaration public static int[] MakeIndexArray(int startValue, int endValue) Parameters Type Name Description System.Int32 startValue System.Int32 endValue Returns Type Description System.Int32 [] Max(Double[]) Returns maximum value of array Declaration public double Max(double[] array) Parameters Type Name Description System.Double [] array Returns Type Description System.Double Max(Double[], Double) Returns element-wise maximum of array element and value Declaration public double[] Max(double[] array, double value) Parameters Type Name Description System.Double [] array System.Double value Returns Type Description System.Double [] Max(Double[], Double[]) Returns maximum value of two array as new array Declaration public double[] Max(double[] array1, double[] array2) Parameters Type Name Description System.Double [] array1 System.Double [] array2 Returns Type Description System.Double [] Max(Double[], Int32, Int32) Returns maximum value of array between indices startInd and endInd Declaration public double Max(double[] array, int startInd, int endInd) Parameters Type Name Description System.Double [] array System.Int32 startInd System.Int32 endInd Returns Type Description System.Double Max(Double[], out Int32) Returns maximum value of array and index of maximum value Declaration public double Max(double[] array, out int ind) Parameters Type Name Description System.Double [] array System.Int32 ind Returns Type Description System.Double Mean(Double[]) returns the mean value of array1 Declaration public double? Mean(double[] array1) Parameters Type Name Description System.Double [] array1 Returns Type Description System.Nullable < System.Double > Min(Double[]) Minimum value of array Declaration public double Min(double[] array) Parameters Type Name Description System.Double [] array Returns Type Description System.Double Min(Double[], Double) Returns element-wise minimum of array element and value Declaration public double[] Min(double[] array, double value) Parameters Type Name Description System.Double [] array System.Double value Returns Type Description System.Double [] Min(Double[], Double[]) Returns minimum value of two array as new array Declaration public static double[] Min(double[] array1, double[] array2) Parameters Type Name Description System.Double [] array1 System.Double [] array2 Returns Type Description System.Double [] Min(Double[], out Int32) Returns minimum value of array and index of maximum value Declaration public double Min(double[] array, out int ind) Parameters Type Name Description System.Double [] array System.Int32 ind Returns Type Description System.Double Mult(Double[], Double) elementwise multipliation of val2 to array1 Declaration public double[] Mult(double[] array1, double val2) Parameters Type Name Description System.Double [] array1 System.Double val2 Returns Type Description System.Double [] Multiply(Double[], Double[]) elementwise multiplication of array1 and array2, assuming they are same size Declaration public double[] Multiply(double[] array1, double[] array2) Parameters Type Name Description System.Double [] array1 System.Double [] array2 Returns Type Description System.Double [] Rand(Int32, Double, Double, Nullable<Int32>) Create a vector of random numbers Declaration public static double[] Rand(int N, double minValue = 0, double maxValue = 1, int? seed = null) Parameters Type Name Description System.Int32 N the number of samples of the returned array System.Double minValue lower end of random number range System.Double maxValue higher end of random number range System.Nullable < System.Int32 > seed optionally, give in a seed number, this makes random sequence repeatable Returns Type Description System.Double [] an array of size N of random numbers between minValue and maxValue Range(Double[]) Returns range of an array, the difference between minimum and maximum Declaration public double Range(double[] array) Parameters Type Name Description System.Double [] array Returns Type Description System.Double Regress(Double[], Double[][], Int32[]) Linear regression Declaration public RegressionResults Regress(double[] Y, double[][] X, int[] yIndToIgnore = null) Parameters Type Name Description System.Double [] Y vector of responve variable values (to be modelled) System.Double [][] X jagged 2D matrix of of mainpulated values/independent values/regressors used to explain Y System.Int32 [] yIndToIgnore (optional) a list of the indices of values in Y to ignore in regression. By default it is null Returns Type Description RegressionResults an object of the RegressionResult class with the paramters, as well as some statistics on the fit and uncertainty thereof. Regress(Double[], Double[,], Int32[]) Linear regression Declaration public RegressionResults Regress(double[] Y, double[, ] X, int[] yIndToIgnore = null) Parameters Type Name Description System.Double [] Y vector of responve variable values (to be modelled) System.Double [,] X 2D matrix of of mainpulated values/independent values/regressors used to explain Y System.Int32 [] yIndToIgnore (optional) a list of the indices of values in Y to ignore in regression. By default it is null Returns Type Description RegressionResults an object of the RegressionResult class with the paramters, as well as some statistics on the fit and uncertainty thereof. ReplaceIndWithValue(Double[], List<Int32>, Double) Replace certain values in an array with a new value. Declaration public static double[] ReplaceIndWithValue(double[] array, List<int> indList, double valueToReplaceWith) Parameters Type Name Description System.Double [] array the array to be replaces System.Collections.Generic.List < System.Int32 > indList list of all the indices of all data points in array to be replaced System.Double valueToReplaceWith the new value to use in place of old values. Returns Type Description System.Double [] A copy of the original array with the values repalced as specified ReplaceValuesAbove(Double[], Double, Double) Replace values below a threshold in an array with a new value Declaration public static double[] ReplaceValuesAbove(double[] array, double threshold, double valueToReplaceWith) Parameters Type Name Description System.Double [] array System.Double threshold System.Double valueToReplaceWith Returns Type Description System.Double [] ReplaceValuesBelow(Double[], Double, Double) Replace all values above a certain threshold in array with a new value Declaration public static double[] ReplaceValuesBelow(double[] array, double threshold, double valueToReplaceWith) Parameters Type Name Description System.Double [] array System.Double threshold System.Double valueToReplaceWith Returns Type Description System.Double [] RSquared(Double[], Double[], List<Int32>) R-squared R-squared (R2) is a statistical measure that represents the proportion of the variance for a dependent variable that's explained by an independent variable or variables in a regression model. Whereas correlation explains the strength of the relationship between an independent and dependent variable, R-squared explains to what extent the variance of one variable explains the variance of the second variable. So, if the R2 of a model is 0.50 , then approximately half of the observed variation can be explained by the model's inputs. Declaration public double RSquared(double[] vector1, double[] vector2, List<int> indToIgnoreExt = null) Parameters Type Name Description System.Double [] vector1 first vector System.Double [] vector2 second vector System.Collections.Generic.List < System.Int32 > indToIgnoreExt optionally: indices to be ignored(for instance bad values) Returns Type Description System.Double R2 squared, a value between -1 and 1 . If an error occured, Double.PositiveInfinity is returned SelfSumOfAbsErr(Double[]) sum of absolute error of the vector compared to itself Declaration public double SelfSumOfAbsErr(double[] vec) Parameters Type Name Description System.Double [] vec Returns Type Description System.Double SelfSumOfSquareErr(Double[]) sum of square error of the vector compared to itself Declaration public double SelfSumOfSquareErr(double[] vec) Parameters Type Name Description System.Double [] vec Returns Type Description System.Double Serialize(Double[], String) serializes a single vector/array to a file for persistent storage to a human-readable text format Vector data can then be retreived by companion method Deserialize Declaration public static bool Serialize(double[] vector, string fileName) Parameters Type Name Description System.Double [] vector vector to be written to afile System.String fileName the file name (or path) of the file to which the vector is to serialized to Returns Type Description System.Boolean Subtract(Double[], Double) elementwise subtraction of val2 from array1 Declaration public double[] Subtract(double[] array1, double val2) Parameters Type Name Description System.Double [] array1 System.Double val2 Returns Type Description System.Double [] Subtract(Double[], Double[]) elementwise subtraction of array1 and array2, assuming they are same size Declaration public double[] Subtract(double[] array1, double[] array2) Parameters Type Name Description System.Double [] array1 System.Double [] array2 Returns Type Description System.Double [] Subtract(Int32[], Int32) subtracts val2 from array2 elements Declaration public int[] Subtract(int[] array1, int val2) Parameters Type Name Description System.Int32 [] array1 System.Int32 val2 Returns Type Description System.Int32 [] Sum(Double[]) returns the sum of array1 Declaration public double? Sum(double[] array1) Parameters Type Name Description System.Double [] array1 Returns Type Description System.Nullable < System.Double > SumOfAbsErr(Double[], Double[], Int32) The sum of absolute errors (|a1-a2|) between array1 and array2 Declaration public double SumOfAbsErr(double[] array1, double[] array2, int indexOffset = -1) Parameters Type Name Description System.Double [] array1 System.Double [] array2 System.Int32 indexOffset Returns Type Description System.Double SumOfSquareErr(Double[], Double, Boolean) sum of square error of the vector compared to a constant. by defautl the return value is normalized by dividing by, this normalization can be turned off Declaration public static double SumOfSquareErr(double[] vec, double constant, bool doNormalization = true) Parameters Type Name Description System.Double [] vec System.Double constant System.Boolean doNormalization Returns Type Description System.Double SumOfSquareErr(Double[], Double[], Int32, Boolean, List<Int32>) The sum of square errors (a1-a2)^2 between array1 and array2 . Declaration public double SumOfSquareErr(double[] array1, double[] array2, int ymodOffset = -1, bool divByN = true, List<int> indToIgnore = null) Parameters Type Name Description System.Double [] array1 System.Double [] array2 System.Int32 ymodOffset System.Boolean divByN if true, the result is normalized by the number of good values System.Collections.Generic.List < System.Int32 > indToIgnore optionally a list of indices of array1 to ignore Returns Type Description System.Double ToString(Double[], Int32, String) Create a compact string of vector with a certain number of significant digits and a chosen divider Declaration public static string ToString(double[] array, int nSignificantDigits, string dividerStr = \";\") Parameters Type Name Description System.Double [] array System.Int32 nSignificantDigits System.String dividerStr Returns Type Description System.String Union(List<Int32>, List<Int32>) returns the union of array1 and array2, a list of elements that are in either vector Declaration public static List<int> Union(List<int> vec1, List<int> vec2) Parameters Type Name Description System.Collections.Generic.List < System.Int32 > vec1 System.Collections.Generic.List < System.Int32 > vec2 Returns Type Description System.Collections.Generic.List < System.Int32 > Var(Double[], Boolean) returns the variance of the array (always apositive number) Declaration public double Var(double[] array1, bool doNormalize = false) Parameters Type Name Description System.Double [] array1 System.Boolean doNormalize Returns Type Description System.Double"
  },
  "api/TimeSeriesAnalysis.Vec-1.html": {
    "href": "api/TimeSeriesAnalysis.Vec-1.html",
    "title": "Class Vec<T> | TimeSeriesAnalysis reference documentation",
    "keywords": "Class Vec<T> Class for generic methods on any type T that treat arrays as vectors (sorting,slicing,concatenating). For mathematical methods on vectors of doubles and integers, look into non-generic sister class \"Vec\". Inheritance System.Object Vec<T> Inherited Members System.Object.ToString() System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.ReferenceEquals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() Namespace : TimeSeriesAnalysis Assembly : TimeSeriesAnalysis.dll Syntax public static class Vec<T> Type Parameters Name Description T type, such as double, int or DateTime Methods Concat(T[], T) concatenates the value y to the end of array x Declaration public static T[] Concat(T[] x, T y) Parameters Type Name Description T[] x T y Returns Type Description T[] Concat(T[], T[]) concatenates arrays x and y into a new larger array Declaration public static T[] Concat(T[] x, T[] y) Parameters Type Name Description T[] x T[] y Returns Type Description T[] Fill(T, Int32) creates an array of size N where every element has value value Declaration public static T[] Fill(T value, int N) Parameters Type Name Description T value System.Int32 N Returns Type Description T[] GetIndicesOfValues(List<T>, List<T>) Get the indices of vec1 values that are present in vec2 Declaration public static List<int> GetIndicesOfValues(List<T> vec1, List<T> vec2) Parameters Type Name Description System.Collections.Generic.List <T> vec1 The results are related to the positions in this vector System.Collections.Generic.List <T> vec2 vec1 is compared to this vector Returns Type Description System.Collections.Generic.List < System.Int32 > GetValuesAtIndices(T[], List<Int32>) returns an array of the values that are in array at the indeices given by indices list Declaration public static T[] GetValuesAtIndices(T[] array, List<int> indices) Parameters Type Name Description T[] array System.Collections.Generic.List < System.Int32 > indices Returns Type Description T[] Intersect(List<T>, List<T>) returns the intersection of array1 and array2, a list of elements that are in both vectors Declaration public static List<T> Intersect(List<T> vec1, List<T> vec2) Parameters Type Name Description System.Collections.Generic.List <T> vec1 System.Collections.Generic.List <T> vec2 Returns Type Description System.Collections.Generic.List <T> Intersect(List<List<T>>) returns the intersection of a number of arrays Declaration public static List<T> Intersect(List<List<T>> lists) Parameters Type Name Description System.Collections.Generic.List < System.Collections.Generic.List <T>> lists Returns Type Description System.Collections.Generic.List <T> ReplaceIndWithValuesPrior(Double[], List<Int32>) replaces all the vaules in array with indices in indList with the last good value prior to that index. Declaration public static double[] ReplaceIndWithValuesPrior(double[] array, List<int> indList) Parameters Type Name Description System.Double [] array System.Collections.Generic.List < System.Int32 > indList Returns Type Description System.Double [] Sort(T[], VectorSortType) Sort a vector Declaration public static T[] Sort(T[] vec, VectorSortType sortType) Parameters Type Name Description T[] vec vector to be sorted VectorSortType sortType the type of sorting Returns Type Description T[] indices of vec in sorted order Sort(T[], VectorSortType, out Int32[]) Sort the vector Declaration public static T[] Sort(T[] vec, VectorSortType sortType, out int[] idx) Parameters Type Name Description T[] vec VectorSortType sortType System.Int32 [] idx Returns Type Description T[] SubArray(T[], Int32, Int32) returns the portion of array1 starting and indStart, and ending at indEnd(or at the end if third paramter is omitted) Declaration public static T[] SubArray(T[] array1, int indStart, int indEnd = -9999) Parameters Type Name Description T[] array1 System.Int32 indStart System.Int32 indEnd Returns Type Description T[]"
  },
  "api/TimeSeriesAnalysis.VecExtensionMethods.html": {
    "href": "api/TimeSeriesAnalysis.VecExtensionMethods.html",
    "title": "Class VecExtensionMethods | TimeSeriesAnalysis reference documentation",
    "keywords": "Class VecExtensionMethods Utility functions and operations for treating arrays as mathetmatical vectors Inheritance System.Object VecExtensionMethods Inherited Members System.Object.ToString() System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.ReferenceEquals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() Namespace : TimeSeriesAnalysis Assembly : TimeSeriesAnalysis.dll Syntax public static class VecExtensionMethods Methods Add(Double[], Double, Double) Add a scalar to vector Declaration public static double[] Add(this double[] array, double scalar, double nanValue = -9999) Parameters Type Name Description System.Double [] array System.Double scalar System.Double nanValue Returns Type Description System.Double [] Mult(Double[], Double, Double) Multiply vector by a scalar Declaration public static double[] Mult(this double[] array, double scalar, double nanValue = -9999) Parameters Type Name Description System.Double [] array System.Double scalar System.Double nanValue Returns Type Description System.Double [] Sub(Double[], Double[], Double) Elementwise subtraction of two arrays of same size Declaration public static double[] Sub(this double[] array1, double[] array2, double nanValue = -9999) Parameters Type Name Description System.Double [] array1 System.Double [] array2 System.Double nanValue Returns Type Description System.Double [] ToString(Double[], Int32, String) Create a compact string of vector with a certain number of significant digits and a chosen divider Declaration public static string ToString(this double[] array, int nSignificantDigits, string dividerStr = \";\") Parameters Type Name Description System.Double [] array System.Int32 nSignificantDigits System.String dividerStr Returns Type Description System.String"
  },
  "api/TimeSeriesAnalysis.VectorFindValueType.html": {
    "href": "api/TimeSeriesAnalysis.VectorFindValueType.html",
    "title": "Enum VectorFindValueType | TimeSeriesAnalysis reference documentation",
    "keywords": "Enum VectorFindValueType Input to Vec.FindValues which specifies the criteria of the search Namespace : TimeSeriesAnalysis Assembly : TimeSeriesAnalysis.dll Syntax public enum VectorFindValueType Fields Name Description BiggerOrEqual \">=\" : Find values which are bigger than or equal BiggerThan \">\" : Find values which are bigger than Equal \"==\": Find values which are equal NaN Find values that are Double.NaN NotNaN Find values that are NOT Double.NaN SmallerOrEqual Find values which are smaller than or equal SmallerThan Find values which are smaller than"
  },
  "api/TimeSeriesAnalysis.VectorSortType.html": {
    "href": "api/TimeSeriesAnalysis.VectorSortType.html",
    "title": "Enum VectorSortType | TimeSeriesAnalysis reference documentation",
    "keywords": "Enum VectorSortType Input to Vec.Sort that specifies how values are to be sorted Namespace : TimeSeriesAnalysis Assembly : TimeSeriesAnalysis.dll Syntax public enum VectorSortType Fields Name Description Ascending Sort in ascending order (smallest first) Descending Sort in descending order (biggest first)"
  },
  "articles/accord.html": {
    "href": "articles/accord.html",
    "title": "Accord.NET | TimeSeriesAnalysis reference documentation",
    "keywords": "Accord.NET This library is built on top of the excellent Accord.NET framework . Accord.NET is licensed under the \"GNU Lesser Public License v2.1\". It can be used in commercial applications \"as long as you are only linking unmodified .dll files and mention in your software and relevant source material that you are using this framework\" - like I am doing right here. The main author of Accord.NET has also stated that \"any files in the project that have only my name on the headers are now available under the MIT license.\" . He has also stated \"If anyone would like, feel free to grab the framework and tear it apart, grab the parts that worked better for you and fork it!\" Thanks to the developers of Accord.NET for a great framework! Development of Accord.NET has stopped at version 3.8.0, but I see this as no reason to worry, as the methods that are used are very stable - actually, you would not expect a mathematics library to need to continue development indefinitely. In versions 1.x of TimeSeriesAnalysis , Accord.NET is only used inside Vec.Regress , and so removing the dependency to Accord.NET would only require this one method to be ported. Accord.NET has implemented classification , clustering , kernel methods and hypothesis testing that may become useful in future work within data-mining and building larger scale models toward version 2.x . Note It is also possible to bulid on top of ML.NET in development toward version 2.0."
  },
  "articles/dependencies.html": {
    "href": "articles/dependencies.html",
    "title": "Dependencies | TimeSeriesAnalysis reference documentation",
    "keywords": "Dependencies By principle this library will only add dependency to external libraries that are under permissive open-source licenses that allow commercial use ."
  },
  "articles/dynsim.html": {
    "href": "articles/dynsim.html",
    "title": "Dynamic simulation | TimeSeriesAnalysis reference documentation",
    "keywords": "Dynamic simulation The building block of the dynamic simulation are referred to as subprocesses where subsystem has has a scalar output Y a scalar disturbance input D (not directly manipulated) a scalar or vector of manipulated variables U . A standard PID-control loop can be implemented as a subsystem: or it can simply be a single-input or multiple input to single output process model without feedback: . The aim of the dynamic simulation is to support dynamic simulation of entire process sections. A process is in general any set of subprocesses The point of co-simulating set of subprocesses is that they may be connected for instance subprocesses connected in series subprocesses that are connected in process-feedback loops subprocesses that are controlled by PID-controllers, and combinations of the above"
  },
  "articles/ex_filtering.html": {
    "href": "articles/ex_filtering.html",
    "title": "Example 3 : Filtering | TimeSeriesAnalysis reference documentation",
    "keywords": "Example 3 : Filtering TimeSeriesAnalysis includes basic recursive filtering through the classes LowPass , HighPass and BandPass . To illustrate their capabilities, we create an artificial dataset which is made of two sinusoids sinus1 and sinus2 of different amplitudes and frequencies. Sinuses are implemented in a TimeSeriesCreator.Sinus . Now, we want to define a LowPass and HighPass filter that can separate out the high-frequency and low-frequency sinuses, and this is mainly a matter of choosing appropriate filter time constants of either filter. sinus1 has an period of 400 seconds, and thus goes from maximum to minimum amplitude in about ~200 seconds. Remembering that a first-order system by rule-of-thumb will take about 5 time-constants to implement 99% of a change, motivates a time constant of 200/5=40 seconds for the low-pass filter. By a similar logic,as sinus2 has a period of 25 seconds will go from maximum to minimum amplitude in about 12 seconds, thus motivating a filter time-constant of about ~3 seconds. The example code(runnable through the Test Explorer ): int timeBase_s = 1; int nStepsDuration = 2000; var sinus1 = TimeSeriesCreator.Sinus(10, 400, timeBase_s, nStepsDuration); var sinus2 = TimeSeriesCreator.Sinus( 1, 25, timeBase_s, nStepsDuration); var y_sim = (new Vec()).Add(sinus1,sinus2); var lpFilter = new LowPass(timeBase_s); var lpFiltered = lpFilter.Filter(y_sim, 40,1); var hpFilter = new HighPass(timeBase_s); var hpFiltered = hpFilter.Filter(y_sim, 3,1); Plot.FromList(new List<double[]> { y_sim, lpFiltered, hpFiltered }, new List<string> { \"y1=y\",\"y3=y_lowpass\",\"y3=y_highpass\" }, timeBase_s); Running the above code results in the below plot. In the top plot y that is two sinusoids overlayed. The below plot shows the high pass- and low pass-filtered versions of y and by the naked eye you can see that the filters have approximately managed to capture and separate out the two components. Note If you look closely, you will notice that y_highpass and y_lowpass sinusoids are delayed slightly in comparison to y , and also that the amplitudes of the two signals do not completely match the originals. This is due to the phase-shift and attenuation causes by the recursive filters, and is good to be aware of. It would be possible to get even smoother filtered signals by increasing the filter order from 1 to 2 for either filter, but the penalty would be increased phase-shift."
  },
  "articles/ex_filtering_python.html": {
    "href": "articles/ex_filtering_python.html",
    "title": "Example 3 : Filtering | TimeSeriesAnalysis reference documentation",
    "keywords": "Example 3 : Filtering import sys import clr import matplotlib.pyplot as plt assembly_path = r\"C:\\Appl\\PythonNETtest\\tsabuild\" sys.path.append(assembly_path) clr.AddReference(\"System\") clr.AddReference(\"System.Collections\") clr.AddReference(\"TimeSeriesAnalysis\") from TimeSeriesAnalysis import Vec from TimeSeriesAnalysis.Dynamic import HighPass, LowPass from TimeSeriesAnalysis.Utility import TimeSeriesCreator timeBase_s = 1 nStepsDuration = 2000 sinus1 = TimeSeriesCreator.Sinus(10, 400, timeBase_s, nStepsDuration) sinus2 = TimeSeriesCreator.Sinus(1, 25, timeBase_s, nStepsDuration) y_sim = Vec().Add(sinus1, sinus2) lpFilter = LowPass(timeBase_s) lpFiltered = lpFilter.Filter(y_sim, 40.0, 1) hpFilter = HighPass(timeBase_s) hpFiltered = hpFilter.Filter(y_sim, 3.0, 1) fig, (ax1, ax2) = plt.subplots(2, 1, sharex=True) fig.suptitle(\"Example 3: Filtering\") # Plot generated dataset ax1.plot(list(y_sim), label=\"y_sim\", color=\"C0\") ax1.grid() ax1.legend(loc=\"upper right\") # Plot filtered dataset ax2.plot(list(lpFiltered), label=\"y_lowpass\", color=\"C1\") ax2.plot(list(hpFiltered), label=\"y_highpass\", color=\"C2\") ax2.grid() ax2.legend(loc=\"upper right\") plt.show()"
  },
  "articles/ex_hello_world.html": {
    "href": "articles/ex_hello_world.html",
    "title": "Example 1 : A simple \"hello world\" | TimeSeriesAnalysis reference documentation",
    "keywords": "Example 1 : A simple \"hello world\" Consider the example ex1_hello_world in Examples.cs : Shared.GetParserObj().EnableConsoleOutput(); int timeBase_s = 1; double filterTc_s = 10; double[] input = TimeSeriesCreator.Step(11, 60, 0, 1); LowPass lp = new LowPass(timeBase_s); var output = lp.Filter(input, filterTc_s); Plot.FromList(new List<double[]> { input, output}, new List<string> { \"y1=V1_input\",\"y1=V2_output\"}, timeBase_s, \"ex1_hello_world\", new DateTime(2020, 1, 1, 0, 0, 0)); Which when run should creates the following plot. The line int dT_s = 1; specifies the sampling time , i.e. the number of seconds between each sample in the time-series, and both LowPass and Plot require this information to correctly interpret the time-series. The time-constant of the filter, expressed in seconds, is set by the line double filterTc_s = 10; . The concept of the time-constant is very central in the domain of filters, control and dynamic systems. A time constant by a loose definition the time it takes for a linear system to reach 67% of its next steady-state. In this example, a step change in input at time t=10s, has reached output=0.67 sometime between t=[21s,22s]. Another useful rule of thumb, is that a a linear system has reached to within 99% of it new steady-state by five times the time constant , so in this case output exceeds 0.99 by t=59s . The next line creates an array of doubles that describes the input to the filter. By means of Vec.Concat and Vec.Fill , this input is initialized to first 11 samples of of the value 0, followed by 50 samples of the value one, a step-change , another important concept in the analysis of dynamic systems. double[] input = Vec<double>.Concat(Vec<double>.Fill(0, 11),Vec<double>.Fill(1, 50)); The input array is filtered by a low-pass filter and, the resulting output is the second time-series vector considered in this example. LowPass lp = new LowPass(dT_s); var output = lp.Filter(input, filterTc_s); The final action in this example is to plot the two time-series together: Plot.FromList(new List<double[]> { input, output}, new List<string> { \"y1=input\",\"y1=output\"}, dT_s, \"ex1_hello_world\", new DateTime(2020, 1, 1, 0, 0, 0)); The first input to this method is the variables to plot as a List of doubles: new List<double[]> { input, output} . The Plot.FromList command can in principle handle any number of inputs in this manner. The second variable determines what axes the variable is to be plotted on and what names to give each time-series trend in the legend . The prefix y1= indicates that the variable is to be plotted on the left axes of the first subplot. The string \"ex1_hello_world\" is displayed as the plot title, and new DateTime(2020, 1, 1, 0, 0, 0) determines that the plot is to start at midnight on on the first day of 2020. Note Try changing new List<string> { \"y1=input\",\"y1=output\"} to new List<string> { \"y1=input\",\"y2=output\"} and notice how output is now plotted on the right axes. Then try new List<string> { \"y1=input\",\"y3=output\"} and notice output is now plotted on a second subplot below the input . Note This is an example of transient data, as the variable output is in a transient state for a significant part of the dataset. Note Try dragging and zooming the plot, and using the scooter to reading the exact time and value off the output variable in each time step in the transient. Notice that the plot.ly library provides an interactive menu of to the top right of the screen. Note The path for this example is http://localhost/plotly/index.html#y1=V1_input;y1=V2_output;comment=ex1_hello_world;casename:ex1_hello_world If for whatever reason chrome does not start automatically on your computer, you can still open the plot manually if you have set up a local web server and paths correctly. Plot.FromList also outputs the url after the pound(\"#\"), so in this case changing the final line to var url = Plot.FromList... would set the variable url to y1=V1_input;y1=V2_output;comment=ex1_hello_world;casename:ex1_hello_world ."
  },
  "articles/ex_hello_world_python.html": {
    "href": "articles/ex_hello_world_python.html",
    "title": "Example 1 : A simple \"hello world\" | TimeSeriesAnalysis reference documentation",
    "keywords": "Example 1 : A simple \"hello world\" import sys import clr import matplotlib.pyplot as plt assembly_path = r\"C:\\Appl\\TimeSeriesAnalysisBuild\" sys.path.append(assembly_path) clr.AddReference(\"TimeSeriesAnalysis\") clr.AddReference(\"System.Collections\") clr.AddReference(\"System\") from TimeSeriesAnalysis.Dynamic import LowPass from TimeSeriesAnalysis.Utility import TimeSeriesCreator timeBase_s = 1 filterTc_s = 10.0 input = TimeSeriesCreator.Step(11, 60, 0, 1) lp = LowPass(timeBase_s) output = lp.Filter(input, filterTc_s) plt.plot(list(input), label=\"input\") plt.plot(list(output), label=\"output\") plt.grid() plt.legend(loc=\"right\") plt.title(\"Example 1: Hello World\") plt.show()"
  },
  "articles/ex_linreg.html": {
    "href": "articles/ex_linreg.html",
    "title": "Example 2 : Linear regression example | TimeSeriesAnalysis reference documentation",
    "keywords": "Example 2 : Linear regression example In this example, a synthetic dataset is created with the help of helper methods from TimeSeriesAnalysis , then Vec.Regress is used to do linear regression on the dataset to determine the parameters which best describe the relationship between inputs u1,u2,u3 and output y . Vec.Rand is used to add noise to the dataset, Vec.Mult is used to multiply vector and scalars The code: double[] true_gains = {1,2,3}; double true_bias = 5; double noiseAmplitude = 0.1; double[] u1 = TimeSeriesCreator.Step(11, 61, 0, 1); double[] u2 = TimeSeriesCreator.Step(31, 61, 1, 2); double[] u3 = TimeSeriesCreator.Step(21, 61, 1,-1); double[] y = new double[u1.Length]; double[] noise = (new Vec()).Mult(Vec.Rand(u1.Length, -1,1,0),noiseAmplitude); for (int k = 0; k < u1.Length; k++) { y[k] = true_gains[0] * u1[k] + true_gains[1] * u2[k] + true_gains[2] * u3[k] + true_bias + noise[k]; } Plot.FromList(new List<double[]> { y, u1, u2, u3 }, new List<string> { \"y1=y1\", \"y3=u1\", \"y3=u2\", \"y3=u3\" }, 1); double[][] U = new double[][] { u1, u2, u3 }; var results = (new Vec()).Regress(y, U); TestContext.WriteLine(Vec.ToString(results.Param, 3)); TestContext.WriteLine(SignificantDigits.Format(results.Rsq, 3)); Plot.FromList(new List<double[]>() { y, results.Y_modelled }, new List<string>() { \"y1=y_meas\", \"y1=y_mod\" }, 1); The dataset : Note The above is an example of how to plot time-series on multiple y-axes, which is extremely useful to visualize input/output relationships. The resulting modeled y_modelled compared to y : The estimated parameters (rounded to three significant digits) returned are: [1.02;2.01;3.02;5.01] which is very close to the true values: [1;2;3;5] Note The returned vector of parameters will be slightly dependent on the seed number given to Vec.Rand() , but if the inputs U have enough excitation , the significance should be minimal. The returned Rsquare is 99,9 , indicating that in this case the model describes variations in the dataset very well, as should be expected in this case, as we have generated the dataset from a linear model that has the same structure as that used by Vec.Regress with the same inputs, and all three inputs vary enough and interdependently of each other."
  },
  "articles/ex_linreg_python.html": {
    "href": "articles/ex_linreg_python.html",
    "title": "Example 2 : Linear regression example | TimeSeriesAnalysis reference documentation",
    "keywords": "Example 2 : Linear regression example import sys import clr import matplotlib.pyplot as plt assembly_path = r\"C:\\Appl\\TimeSeriesAnalysisBuild\" sys.path.append(assembly_path) clr.AddReference(\"TimeSeriesAnalysis\") clr.AddReference(\"System.Collections\") from System import Array, DateTime, Double, String from System.Collections.Generic import List from TimeSeriesAnalysis import Vec from TimeSeriesAnalysis.Utility import Plot, TimeSeriesCreator true_gains = [1, 2, 3] true_bias = 5 noise_amplitude = 0.1 timeBase_s = 1 vec_sum = Vec().Add([1, 2], [3, 4]) u1 = TimeSeriesCreator.Step(11, 61, 0, 1) u2 = TimeSeriesCreator.Step(31, 61, 1, 2) u3 = TimeSeriesCreator.Step(21, 61, 1, -1) y = [] noise = Vec().Mult(Vec.Rand(u1.Length, -1, 1, 0), noise_amplitude) for k in range(u1.Length): y.append( true_gains[0] * u1[k] + true_gains[1] * u2[k] + true_gains[2] * u3[k] + true_bias + noise[k] ) U = Array[Array[Double]]([u1, u2, u3]) results = Vec().Regress(y, U) fig, (ax1, ax2) = plt.subplots(2, 1, sharex=True) fig.suptitle(\"Example 2: Model fitting\") ax1.plot(list(y), label=\"y1\") ax1.plot(list(u1), label=\"u1\") ax1.plot(list(u2), label=\"u2\") ax1.plot(list(u3), label=\"u3\") ax1.grid() ax1.legend(loc=\"upper right\") ax1.set_title(\"Dataset\") ax2.plot(list(y), label=\"y_meas\") ax2.plot(list(results.Y_modelled), label=\"y_mod\") ax2.grid() ax2.legend(loc=\"upper right\") ax2.set_title(\"Resulting model\") plt.show()"
  },
  "articles/ex_pid.html": {
    "href": "articles/ex_pid.html",
    "title": "Example 5 : Simulating a single PID-controller | TimeSeriesAnalysis reference documentation",
    "keywords": "Example 5 : Simulating a single PID-controller In this example, a step disturbance influences a linear subprocess that is controlled by a PID-controller toward a constant setpoint of y=50 , like depicted in the below figure: SubProcessSimulator.CoSimulateProcessAndPID co-simulates a single PID-controller/processes combination such as this. int timeBase_s = 1; int N = 500; var modelParameters = new DefaultProcessModelParameters { WasAbleToIdentify = true, TimeConstant_s = 10, ProcessGains = new double[] { 1 }, TimeDelay_s = 0, Bias = 5 }; var processModel = new DefaultProcessModel(modelParameters, timeBase_s); var pidParameters = new PIDModelParameters() { Kp = 0.5, Ti_s = 20 }; var pid = new PIDModel(pidParameters, timeBase_s); var dataSet = new SubProcessDataSet(timeBase_s,N); dataSet.D = TimeSeriesCreator.Step(N / 4, N, 0, 1); dataSet.Y_setpoint = TimeSeriesCreator.Constant(50,N); var simulator = new SubProcessSimulator(processModel); simulator.CoSimulateProcessAndPID( pid, ref dataSet); Plot.FromList(new List<double[]> { dataSet.Y_sim, dataSet.U_sim.GetColumn(0), dataSet.D }, new List<string> { \"y1=y_sim\", \"y3=u_pid\",\"y2=disturbance\" }, timeBase_s, \"ex5_results\"); The resulting dynamic simulation: Note that the PID-controller is able to bring the subprocess back to the setpoint despite the disturbance. The initial fast response of the proportional term Kp is seen in the plot of u_pid , followed by the gradual influence of the integral term Ti_s , as is expected. Note SubProcessSimulator ensures that the PID/model combination starts in steady-state , so there is no bump or transient in the start of the dataset. Note Normally in industrial settings, PID-controllers are scaled, scaling information can be included by the inputting a PIDscaling to the PIDModelParameters object on initialization. Note CoSimulateProcessAndPID is only intended for simple single-input/single-output pid/model systems. For more general simulation, use ProcessSimulator class."
  },
  "articles/ex_pid_python.html": {
    "href": "articles/ex_pid_python.html",
    "title": "Example 5 : Simulating a single PID-controller | TimeSeriesAnalysis reference documentation",
    "keywords": "Example 5 : Simulating a single PID-controller import sys import clr import matplotlib.pyplot as plt assembly_path = r\"C:\\Appl\\TimeSeriesAnalysisBuild\" sys.path.append(assembly_path) clr.AddReference(\"System\") clr.AddReference(\"System.Collections\") clr.AddReference(\"TimeSeriesAnalysis\") from TimeSeriesAnalysis.Dynamic import ( DefaultProcessModel, DefaultProcessModelParameters, PIDModel, PIDModelParameters, SubProcessDataSet, SubProcessSimulator, ) from TimeSeriesAnalysis.Utility import TimeSeriesCreator timeBase_s = 1.0 N = 500 modelParameters = DefaultProcessModelParameters() modelParameters.WasAbleToIdentify = True modelParameters.TimeConstant_s = 10.0 modelParameters.ProcessGains = [1.0] modelParameters.TimeDelay = 0.0 modelParameters.Bias = 5.0 processModel = DefaultProcessModel(modelParameters, timeBase_s) pidParameters = PIDModelParameters() pidParameters.Kp = 0.5 pidParameters.Ti_s = 20.0 pid = PIDModel(pidParameters, timeBase_s) dataSet = SubProcessDataSet(timeBase_s, N) dataSet.D = TimeSeriesCreator.Step(N / 4, N, 0, 1) dataSet.Y_setpoint = TimeSeriesCreator.Step(0, N, 50, 50) simulator = SubProcessSimulator(processModel) isOK, dataSet = simulator.CoSimulateProcessAndPID(pid, dataSet) fig, (ax1, ax2) = plt.subplots(2, 1, sharex=True) fig.suptitle(\"Example 5: PID-controller\") ax12 = ax1.twinx() l1 = ax1.plot(list(dataSet.Y_sim), label=\"y_sim\", color=\"C0\")[0] l12 = ax12.plot(list(dataSet.D), label=\"disturbance\", color=\"Black\")[0] l2 = ax2.plot(list(dataSet.U_sim), label=\"u_pid\", color=\"C1\")[0] ax1.grid() ax2.grid() ax1.legend([l1, l12, l2], [\"y_sim\", \"disturbance\", \"u_pid\"]) plt.show()"
  },
  "articles/ex_processsim.html": {
    "href": "articles/ex_processsim.html",
    "title": "Example 6 :Larger-scale dynamic process simulation | TimeSeriesAnalysis reference documentation",
    "keywords": "Example 6 :Larger-scale dynamic process simulation The last example illustrated one very simple \"process\" consisting of a single PID-controller and a single-input/single-output process model, which could be simulated using CoSimulateProcessAndPID . Most systems of interest are more complicated, as each each model may have more than one input, and there may be several different PID-controllers and several subprocess-models interacting. Simulation of these kinds of systems is done using the class ProessSimulator . To keep things familiar this example extends on the previous. The subprocess-model is extended to two inputs , one external input signal is added in addition to the pid-signal input as shown below: The second output is given a gain of 2 by adding a second process gain to modelParamters : ProcessGains = new double[] { 1,2 }, Then the process simulator class is initialized, it needs a list of all models classes that will be simulated: var processSim = new ProcessSimulator (timeBase_s, new List<ISimulatableModel> { pidModel, processModel }); Then the two models pidModel and processModel need to be given two connections to make the feedback loop: processSim.ConnectModels(processModel,pidModel); processSim.ConnectModels(pidModel, processModel, (int)INDEX.FIRST); Notice that since processModel now has two inputs, we need to specify which input the pidModel connects to. If you like, you can use the enum INDEX to produce more readable code, or just specify the integer directly. Similarly to the previous example, a disturbance with a step of amplitude 1 is added 1/4th of the way through the dataset is added to the process model: processSim.AddSignal(processModel, SignalType.Distubance_D,TimeSeriesCreator.Step(N/4,N,0,1)); and a constant setpoint of 50 is applied to the process model: processSim.AddSignal(pidModel, SignalType.Setpoint_Yset, TimeSeriesCreator.Constant(50, N)); Note SubProcessSimulator.CoSimulateProcessAndPID co-simulates a single PID-controller/processes combination such as this, if you set the below signal to zero, for instance by setting the value TimeSeriesCreator.Step(0,N) then the simulation in this example will replicate the previous simulation in the previous example exactly . Then to extend the example, add a step change from 0 to 1 in the external input: processSim.AddSignal(processModel, SignalType.External_U, TimeSeriesCreator.Step(N / 2, N, 0, 1), (int)INDEX.SECOND); making sure to apply this signal to the second input of the processModel . After all connections are made and signals added, then simulation is done using var isOk = processSim.Simulate(out TimeSeriesDataSet simData); This method outputs an object of the type TimeSeriesDataSet that stores all the time-series of the simulation, both the signals added above and the simulated values, which can be accessed through convenient getters. For example the simulated output of processModel can be extracted from simData like this: simData.GetValues(processModel.GetID(),SignalType.Output_Y_sim) Notice how AddSignal applies a SignalType to each signal, this is then used internally in Simulate , but is also used to make it easier to extract and interpret signals after the simulation. The entire code: public void Ex6_process_simulation() { int timeBase_s = 1; int N = 500; DefaultProcessModelParameters modelParameters = new DefaultProcessModelParameters { WasAbleToIdentify = true, TimeConstant_s = 10, ProcessGains = new double[] { 1,2 }, TimeDelay_s = 0, Bias = 5 }; DefaultProcessModel processModel = new DefaultProcessModel(modelParameters, timeBase_s,\"SubProcess1\"); var pidParameters = new PIDModelParameters() { Kp = 0.5, Ti_s = 20 }; var pidModel = new PIDModel(pidParameters, timeBase_s,\"PID1\"); var processSim = new ProcessSimulator (timeBase_s, new List<ISimulatableModel> { pidModel, processModel }); processSim.ConnectModels(processModel,pidModel); processSim.ConnectModels(pidModel,processModel,(int)INDEX.FIRST); processSim.AddSignal(processModel,SignalType.Disturbance_D, TimeSeriesCreator.Step(N/4,N,0,1)); processSim.AddSignal(pidModel,SignalType.Setpoint_Yset, TimeSeriesCreator.Constant(50,N)); processSim.AddSignal(processModel,SignalType.External_U, TimeSeriesCreator.Step(N/2,N,0,1),(int)INDEX.SECOND); var isOk = processSim.Simulate(out var simData); Plot.FromList(new List<double[]> { simData.GetValues(processModel.GetID(),SignalType.Output_Y_sim), simData.GetValues(processModel.GetID(),SignalType.Disturbance_D), simData.GetValues(processModel.GetID(),SignalType.External_U,(int)INDEX.SECOND), simData.GetValues(pidModel.GetID(),SignalType.PID_U) }, new List<string> { \"y1=y_sim\", \"y2=disturbance\", \"y2=u_external\",\"y3=u_pid\" }, timeBase_s, \"ex6_results\"); } The resulting dynamic simulation: The effect of the disturbance step entering 1/4th of the way through the dataset and then being rejected is seen, and is in fact exactly like in the previous example, but now a step change in the input is also seen half-way through the dataset. Note This example illustrates the work-flow that supports large-scale simulations, but the process example considered is still quite small. For examples of large-scale simulations, refer to the section on dynamic simulation."
  },
  "articles/ex_processsim_python.html": {
    "href": "articles/ex_processsim_python.html",
    "title": "Example 6 :Larger-scale dynamic process simulation | TimeSeriesAnalysis reference documentation",
    "keywords": "Example 6 :Larger-scale dynamic process simulation import sys import clr import matplotlib.pyplot as plt assembly_path = r\"C:\\Appl\\TimeSeriesAnalysisBuild\" sys.path.append(assembly_path) clr.AddReference(\"System\") clr.AddReference(\"System.Collections\") clr.AddReference(\"TimeSeriesAnalysis\") from System.Collections.Generic import List from TimeSeriesAnalysis.Dynamic import ( DefaultProcessModel, DefaultProcessModelParameters, ISimulatableModel, PIDModel, PIDModelParameters, ProcessSimulator, SignalType, TimeSeriesDataSet, ) from TimeSeriesAnalysis.Utility import TimeSeriesCreator timeBase_s = 1.0 N = 500 modelParameters = DefaultProcessModelParameters() modelParameters.WasAbleToIdentify = True modelParameters.TimeConstant_s = 10.0 modelParameters.ProcessGains = [1.0, 2.0] modelParameters.TimeDelay = 0.0 modelParameters.Bias = 5.0 process = DefaultProcessModel(modelParameters, timeBase_s, ID=\"SubProcess1\") pidParameters = PIDModelParameters() pidParameters.Kp = 0.5 pidParameters.Ti_s = 20.0 pid = PIDModel(pidParameters, timeBase_s, ID=\"PID1\") sim_models = List[ISimulatableModel]() sim_models.Add(pid) sim_models.Add(process) processSimulator = ProcessSimulator(timeBase_s, sim_models) processSimulator.ConnectModels(process, pid) processSimulator.ConnectModels(pid, process, 0) processSimulator.AddSignal(process, SignalType.Distubance_D, TimeSeriesCreator.Step(N/4, N, 0, 1)) processSimulator.AddSignal(pid, SignalType.Setpoint_Yset, TimeSeriesCreator.Step(0, N, 50, 50)) processSimulator.AddSignal(process, SignalType.External_U, TimeSeriesCreator.Step(N/2, N, 0, 1), 1) simData = TimeSeriesDataSet(int(timeBase_s)) isOK, simDataUpdated = processSimulator.Simulate(simData) fig, (ax1, ax2) = plt.subplots(2, 1, sharex=True) fig.suptitle(\"Example 6: Larger-scale dynamic process simulation\") ax12 = ax1.twinx() l1 = ax1.plot(list(simDataUpdated.GetValues(process.GetID(), SignalType.Output_Y_sim)), label=\"y_sim\", color=\"C0\")[0] l121 = ax12.plot(list(simDataUpdated.GetValues(process.GetID(), SignalType.Distubance_D)), label=\"disturbance\", color=\"C1\")[0] l122 = ax12.plot(list(simDataUpdated.GetValues(process.GetID(), SignalType.External_U, 1)), label=\"u_external\", color=\"Black\")[0] l2 = ax2.plot(list(simDataUpdated.GetValues(pid.GetID(), SignalType.PID_U)), label=\"u_pid\", color=\"C2\")[0] ax1.grid() ax2.grid() ax1.legend([l1, l121, l122, l2], [\"y_sim\", \"disturbance\", \"u_external\", \"u_pid\"]) plt.show()"
  },
  "articles/ex_sysid.html": {
    "href": "articles/ex_sysid.html",
    "title": "Example 4 : Fitting a dynamic model to transient data | TimeSeriesAnalysis reference documentation",
    "keywords": "Example 4 : Fitting a dynamic model to transient data In this example, it is shown how to use the built-in dynamic identification algorithm to find a dynamic model to describe a measured time-series depending on multiple inputs. This example considers an \"open-loop\" subprocess as shown below: . A synthetic dataset with two inputs u1 and u2 is created using ProcessSimulator and the DefaultProcessModel (the output y_meas depends linearly on the two inputs), and noise is added to the data. The advantage of a synthetic dataset is that we know the true underlying parameters, which is very useful for testing and validating methods. In this case the \"true\" time-delay of 5 seconds, time-constant of 15 seconds and process gains {1,2} are chosen. The aim of this example is to see how closely the DefaultProcessModelIdentifier is able to estimate these values. The code to create the dataset, do the identification and create the plots is shown below: int timeBase_s = 1; double noiseAmplitude = 0.05; var parameters = new DefaultProcessModelParameters { WasAbleToIdentify = true, TimeConstant_s = 15, ProcessGains = new double[] {1,2}, TimeDelay_s = 5, Bias = 5 }; var model = new DefaultProcessModel(parameters, timeBase_s); double[] u1 = TimeSeriesCreator.Step(40,200, 0, 1); double[] u2 = TimeSeriesCreator.Step(105,200, 2, 1); double[,] U = Array2D<double>.InitFromColumnList(new List<double[]>{u1 ,u2}); var dataSet = new SubProcessDataSet(timeBase_s,U); var simulator = new SubProcessSimulator(model); simulator.EmulateYmeas(ref dataSet, noiseAmplitude); Plot.FromList(new List<double[]> { dataSet.Y_meas, u1, u2 }, new List<string> { \"y1=y_meas\", \"y3=u1\", \"y3=u2\" }, timeBase_s,\"ex4_data\"); var modelId = new DefaultProcessModelIdentifier(); var identifiedModel = modelId.Identify(ref dataSet); Plot.FromList(new List<double[]> { identifiedModel.FittedDataSet.Y_meas, identifiedModel.FittedDataSet.Y_sim }, new List<string> { \"y1=y_meas\", \"y1=y_sim\"}, timeBase_s, \"ex4_results\"); Console.WriteLine(identifiedModel.ToString()); // compare dynamic to static identification var regResults = (new Vec()).Regress(dataSet.Y_meas, U); Plot.FromList(new List<double[]> { identifiedModel.FittedDataSet.Y_meas, identifiedModel.FittedDataSet.Y_sim,regResults.Y_modelled }, new List<string> { \"y1=y_meas\", \"y1=y_dynamic\",\"y1=y_static\" }, timeBase_s, \"ex4_static_vs_dynamic\"); Console.WriteLine(\"static model gains:\" + Vec.ToString(regResults.Gains,3)); The first plot shows the dataset, showing inputs u1 , u2 and output y : Notice of the time-delay and time-constant are clearly visible in this dataset . The resulting fit between model and dataset is shown below. The two time-series are virtually identical, except that the modeled output does not have any noise. The resulting console output gives more detail on the parameters found: DefaultProcessModel ------------------------- ABLE to identify TimeConstant : 14,1 sec TimeDelay : 5 sec ProcessGains : [0.958;1.96] ProcessCurvatures : null Bias : 8,87 u0 : [0.796;1.54] ------------------------- fitting objective : 0,3136 fitting R2: 84,27 fitting : no error or warnings Notice how the process gains [0.958;1.96] are fairly close to the true [1;2] , the time constant 14,1 sec is fairly close to the true 15 sec and the time delay is spot-on at 5 sec . R-squared (\"R2\") is ~84 out of 100 maximum, and this indicates a relatively good match of the model. R-squared could have been increased, and the even better estimates could have been obtained for a longer dataset, and by either including more steps in the data, or by fully allowing the first step response to reach steady-state before continuing with the second step. Reducing the noise also improves estimates and increases R2, but of course that is not an option in real-life. Comparsion: static versus dynamic model As an instructional example, the dynamic model above is compared to what is found by normal linear regression on this dataset. Linear regression is accomplished by Vec.Regress using the code below: // compare dynamic to static identification var regResults = Vec.Regress(dataSet.Y_meas, U); Plot.FromList(new List<double[]> { identifiedModel.FittedDataSet.Y_meas, identifiedModel.FittedDataSet.Y_sim,regResults.Y_modelled }, new List<string> { \"y1=y_meas\", \"y1=y_dynamic\",\"y1=y_static\" }, timeBase_s, \"ex4_static_vs_dynamic\"); Console.WriteLine(\"static model gains:\" + Vec.ToString(regResults.Gains,3)); The resulting plot, which compares the dynamic and static models is shown below: The model gains of the static model is [0.69;1.29] , which is not quite as close as the estimate [0.958;1.96] of the dynamic identification to the true values: [1;2] . Note This example illustrates an extremely important but slightly subtle lesson about the utility of dynamic identification: If your data is dynamic/transient, using dynamic identification will result in better estimates, also for stationary terms . This means that even if you are only interested in the static gains of a system, you would benefit from estimating gains using dynamic identification if your data has visible transients."
  },
  "articles/ex_sysid_python.html": {
    "href": "articles/ex_sysid_python.html",
    "title": "Example 4 : Fitting a dynamic model to transient data | TimeSeriesAnalysis reference documentation",
    "keywords": "Example 4 : Fitting a dynamic model to transient data import sys import clr import matplotlib.pyplot as plt assembly_path = r\"C:\\Appl\\PythonNETtest\\tsabuild\" sys.path.append(assembly_path) clr.AddReference(\"System\") clr.AddReference(\"System.Collections\") clr.AddReference(\"TimeSeriesAnalysis\") from System import Array, Double from System.Collections.Generic import List from TimeSeriesAnalysis import Array2D, Vec from TimeSeriesAnalysis.Dynamic import ( DefaultProcessModel, DefaultProcessModelIdentifier, DefaultProcessModelParameters, SubProcessDataSet, SubProcessSimulator, ) from TimeSeriesAnalysis.Utility import TimeSeriesCreator timeBase_s = 1.0 noiseAmplitude = 0.05 parameters = DefaultProcessModelParameters() parameters.WasAbleToIdentify = True parameters.TimeConstant_s = 15.0 parameters.ProcessGains = [1.0, 2.0] parameters.TimeDelay = 5.0 parameters.Bias = 5.0 model = DefaultProcessModel(parameters, timeBase_s, ID=\"not_named\") model.modelParameters = parameters model.timeBase_s = timeBase_s model.ID = \"not_named\" u1 = TimeSeriesCreator.Step(40, 200, 0, 1) u2 = TimeSeriesCreator.Step(105, 200, 2, 1) u_list = List[Array[Double]](range(2)) u_list.Add(u1) u_list.Add(u2) U = Array2D[Double].InitFromColumnList(u_list) dataSet = SubProcessDataSet(timeBase_s, U) simulator = SubProcessSimulator(model) simulator.EmulateYmeas(dataSet, noiseAmplitude) modelId = DefaultProcessModelIdentifier() identifiedModel, subprosDataSet = modelId.Identify(dataSet) regResults = Vec().Regress(dataSet.Y_meas, U) # Plot generated dataset fig, (ax1, ax2, ax3, ax4) = plt.subplots(4, 1, sharex=True) ax1.plot(list(dataSet.Y_meas), label=\"y_sim\", color=\"Black\") ax1.grid() ax1.legend(loc=\"upper right\") ax1.set_title(\"ex4_data\") ax2.plot(list(u1), label=\"u1\") ax2.plot(list(u2), label=\"u2\") ax2.grid() ax2.legend(loc=\"upper right\") # Plot fitted model ax3.plot(list(identifiedModel.FittedDataSet.Y_meas), label=\"y_meas\") ax3.plot(list(identifiedModel.FittedDataSet.Y_sim), label=\"y_sim\") ax3.grid() ax3.legend(loc=\"upper right\") ax3.set_title(\"ex4_results\") # Compared to static model found by linear regression ax4.plot(list(identifiedModel.FittedDataSet.Y_meas), label=\"y_meas\") ax4.plot(list(identifiedModel.FittedDataSet.Y_sim), label=\"y_sim\") ax4.plot(list(regResults.Y_modelled), label=\"y_static\") ax4.grid() ax4.legend(loc=\"upper right\") ax4.set_title(\"ex4_static_vs_dynamic\") plt.suptitle(\"Example 4: Model fitting\") plt.show()"
  },
  "articles/example_linreg.html": {
    "href": "articles/example_linreg.html",
    "title": "Example : realistic linear regression | TimeSeriesAnalysis reference documentation",
    "keywords": "Example : realistic linear regression This example uses a ficticious csv-file example.csv, that has column headers \"Time\",\"Var1\",\"Var2\",\"Var3\",\"Var4,\"Var5\",Var6\",\"Var7\". \"Var1\" is to be modelled by Var2 - Var6 as regressors, while Var7 is to be multiplied to Var2 - Var6 . The data contains some instances of -9999 which indicates bad data, and this is removed in preprocessing. A low-pass filter is used to imitate a time-constant in the system by smoothing the model inputs. Only the data starting after a specific t0 is to be used in the regression, so a subset of the raw data in the csv-file is given to regression. This example illustrates that by using the TimeSeriesAnalysis package, the complexity of the code required to do practical exploratory time-series analysis is comparable to what is normally accomplished by parsed languages such as Matlab, R or Python. using System; using System.Collections.Generic; using System.Linq; using TimeSeriesAnalysis; namespace SubseaPALL { class run { public static void Main() { CSV.loadDataFromCSV(@\"C:\\Appl\\ex1\\Data\\example.csv\", out double[,] data, out string[] variableNames,out string[,] stringData); int tInd = Array.IndexOf(variableNames, \"Time\"); DateTime[] dateTimes = stringData.GetColumnParsedAsDateTime(tInd, \"yyyy-MM-dd HH:mm:ss\"); TimeSpan span = dateTimes[1].Subtract(dateTimes[0]); int dT_s = (int)span.TotalSeconds; int t0Ind = 9476;// first instance DateTime t0 = dateTimes.ElementAt(t0Ind); int yInd = Array.IndexOf(variableNames, \"var1\"); //V1: use choke openings as inputs int u1Ind, u2Ind, u3Ind, u4Ind, u5Ind; u1Ind = Array.IndexOf(variableNames, \"var2\"); u2Ind = Array.IndexOf(variableNames, \"var3\"); u3Ind = Array.IndexOf(variableNames, \"var4\"); u4Ind = Array.IndexOf(variableNames, \"var5\"); u5Ind = Array.IndexOf(variableNames, \"var6\"); int u6ind = Array.IndexOf(variableNames, \"var7\"); int[] uIndArray = new int[] { u1Ind, u2Ind, u3Ind, u4Ind, u5Ind }; double[] y_raw = data.GetColumn(yInd); double[,] u_raw = data.GetColumns(uIndArray) ; double[] u6_raw = data.GetColumn(u6ind); // clip out desired chunk of data double[] y = y_raw.GetRowsAfterIndex(t0Ind); double[,] u = u_raw.GetRowsAfterIndex(t0Ind); double[] z_topside = u6_raw.GetRowsAfterIndex(t0Ind); // preprocessing - remove bad values List<int> yIndToIgnoreRaw = new List<int>(); for (int colInd = 0; colInd < u.GetNColumns(); colInd++) { List<int> badValInd = Vec.FindValues(u.GetColumn(colInd), -9999, FindValues.NaN); yIndToIgnoreRaw.AddRange(badValInd); } yIndToIgnoreRaw.AddRange(Vec.FindValues(y, -9999, FindValues.NaN)); yIndToIgnoreRaw.AddRange(Vec.FindValues(z_topside, -9999, FindValues.NaN)); List<int> yIndToIgnore =(List<int>)yIndToIgnoreRaw.Distinct().ToList(); // do scaling, input trickery and then regress u = u.Transpose(); double[] y_plot = Vec.ReplaceIndWithValuesPrior(y, yIndToIgnore);// -9999 destroys plot double[] u1_plot = Vec.ReplaceIndWithValuesPrior(u.GetRow(0), yIndToIgnore);// -9999 destroys plot double[] u2_plot = Vec.ReplaceIndWithValuesPrior(u.GetRow(1), yIndToIgnore);// -9999 destroys plot double[] u3_plot = Vec.ReplaceIndWithValuesPrior(u.GetRow(2), yIndToIgnore);// -9999 destroys plot double[] u4_plot = Vec.ReplaceIndWithValuesPrior(u.GetRow(3), yIndToIgnore);// -9999 destroys plot double[] u5_plot = Vec.ReplaceIndWithValuesPrior(u.GetRow(4), yIndToIgnore);// -9999 destroys plot double[] u6_plot = Vec.ReplaceIndWithValuesPrior(z_topside, yIndToIgnore);// -9999 destroys plot // temperature does not change much based on changes in the upper half of the range valve-opening rate, as flow rates also // do not change that much (valve flow vs. choke opening is nonlinear) double z_Max = 60; double z_MaxTopside = 80; u = Matrix.ReplaceRow(u,0, Vec.Min(u.GetRow(0), z_Max)); u = Matrix.ReplaceRow(u,1, Vec.Min(u.GetRow(1), z_Max)); u = Matrix.ReplaceRow(u,2, Vec.Min(u.GetRow(2), z_Max)); u = Matrix.ReplaceRow(u,3, Vec.Min(u.GetRow(3), z_Max)); u = Matrix.ReplaceRow(u,4, Vec.Min(u.GetRow(4), z_Max)); u = Matrix.Mult(u, 0.01); z_topside = Vec.Mult(Vec.Min(z_topside, z_MaxTopside), 0.01); z_topside = Vec.Mult(z_topside, 0.01); u = Matrix.Mult(u, z_topside); // lowpass filtering of inputs double TimeConstant_s = 1800;//73.24 LowPass filter = new LowPass(TimeConstant_s); u = Matrix.ReplaceRow(u, 0, filter.Filter(u.GetRow(0), TimeConstant_s)); u = Matrix.ReplaceRow(u, 1, filter.Filter(u.GetRow(1), TimeConstant_s)); u = Matrix.ReplaceRow(u, 2, filter.Filter(u.GetRow(2), TimeConstant_s)); u = Matrix.ReplaceRow(u, 3, filter.Filter(u.GetRow(3), TimeConstant_s)); u = Matrix.ReplaceRow(u, 4, filter.Filter(u.GetRow(4), TimeConstant_s)); if (u == null) { Console.WriteLine(\"u is null, something went wrong\"); return; } var uJaggedArray = u.Convert2DtoJagged(); double[] parameters = Vec.Regress(y, uJaggedArray, yIndToIgnore.ToArray(), out _, out double[] y_mod,out double Rsq); double[] e = Vec.Sub(y_plot, y_mod); //present results if (y_mod == null) { Console.WriteLine(\"something went wrong, regress returned null\"); } else { Plot.Six(u1_plot, u2_plot, u3_plot, u4_plot, u5_plot,u6_plot, dT_s,\"z_D1\", \"z_D2\", \"z_D3\", \"z_D4\",\"z_D5\",\"z_topside\",true,false,null,t0); Plot.Two(y_plot, y_mod, dT_s, \"T_Dtopside(meas)\", \"T_Dtopside(mod)\",true,false,\"Rsq\"+Rsq.ToString(\"#.##\"),t0); Plot.One(e,dT_s,\"avvik\",null, t0); } } } }"
  },
  "articles/examples.html": {
    "href": "articles/examples.html",
    "title": "Code examples | TimeSeriesAnalysis reference documentation",
    "keywords": "Code examples All examples are implemented in Examples.cs . Upon building the project, you can run and examine the examples from the Test Explorer as you would any unit test by right click>Run Test ."
  },
  "articles/getting_started.html": {
    "href": "articles/getting_started.html",
    "title": "| TimeSeriesAnalysis reference documentation",
    "keywords": ""
  },
  "articles/glossary.html": {
    "href": "articles/glossary.html",
    "title": "Glossary | TimeSeriesAnalysis reference documentation",
    "keywords": "Glossary Time base Time-base in this context is another expression for sampling time which is the inverse of the sampling rate . So a sampling frequency of 10 Hz , would mean a sampling time/time base of 0.1s . Linear versus non-linear systems A linear system refers to a system that can be described by a linear differential equation, i.e. its states are linear in the dependent variables u . A nonlinear is system is any system that is not linear. Example: If x is the system state, then dx/dt = b * u is linear while x = b * u + c * u^2 is non-linear State of a system So the state of a system is the values of a set of variables that together define the current condition of the system uniequly. Often in system identfication the system state is referred to as x . Note that the output y is not neccesarily the same as the state. If the system is described by the differential equation, then the state x is the solution of this equation set. Steady-state versus transient Steady-state in a differential equation is the condition that the differential terms are zero, so that the system remains at rest. Static versus dynamic A model is termed static if any changes in inputs fully propagete immediately the outputs. So a static model is a model with no transients , and thus has no time-constant or time-delay terms. Working point and local models Any nonlinear system can be approximated as linear around a working point . So a local model in this context is a model that is intended to mainly approximate the actual system close to a given value u0 of the manipulated variables. Depending on the degree of non-linearity, the working range aroundt the working point that the model is useful for will vary. Tuning dataset versus validation dataset The tuning dataset , also referred to as the fitted dataset is the actual set of data that the model was fitted against. It is common practice in system identifiation to evaluate models not on the fit to the tuning set but on a fresh set of data , and this fresh data set used for evaluation is referred to as the validation dataset ."
  },
  "articles/index.html": {
    "href": "articles/index.html",
    "title": "TimeSeriesAnalysis .NET class library | TimeSeriesAnalysis reference documentation",
    "keywords": "TimeSeriesAnalysis .NET class library At a glance TimeSeriesAnalysis is a library intended to support efficient test-driven development of time-series-based algorithms. Studying data with transients/dynamics, through dynamic model identification, dynamic simulation, filtering and PID-control is supported. The library aims to support mining of time-series data for advanced analytics. TimeSeriesAnalysis is a .NET class library for making it easy to work with time series in .NET framework (written in C# ). It handles typical tasks related to time-series analysis such as loading time-series data from CSV-files, manipulating time-series data as arrays and vectors, filtering out values by range, detecting and removing bad values, smoothing fitting static models to time-series data by linear regression(based on Accord.NET ), fitting dynamic models to time-series by custom methods that build on linear regression, and plotting times-series (in a browser window with plot.ly ). dynamic simulation of systems that may include interactions with PID-controllers (the library includes a reference PID-controller implementation). The aim of this library is to make the process of working with time series as easy as possible, and the resulting work flow should be comparable to working in Matlab , Python or R . This means that you can treat time series as vectors and matrices easily, without worrying about the arrays underneath, and perform operations like adding, subtracting, multiplying with vectors and matrices, as well as typical pre-processing tasks like selecting subsets of a larger dataset, removing spurious values, min/max range limits etc. The result is a that tasks that you would normally do in for instance Matlab due to the perceived simplicity offered by the language, can now be accomplished in about the same amount of code in C#/.NET . The benefit of doing this in C#/.NET that you get the benefits of a compiled type strict language, by writing your prototype code directly a language suitable for implementation, (unlike a prototype in some script languages). In some cases this may that you can avoid introducing Matlab code generator toolboxes which act as complex black-boxes, and often require expensive licenses. the resulting code does not require a paid license to run. you can easily extend your code to for instance run in parallel using the paralell.for functionality freely available in .NET, wheres this functionality may require a very expensive toolbox in a script language. Plotting capabilities Note This library is written to support test-driven development(TDD) of algorithms based on time-series, and to support the TDD workflow, it supports time-series plotting. This feature is extremely useful to visualize the results of of unit tests or acceptance tests, and this helps enormously with debugging. The unit tests of this repository, give an example of how you can use these plotting capabilities for your own testing. Plotting features supported one or two subplots(stacked vertically) one or two y-axes on either subplot support for zooming in the plot, subplots x-axes are linked when zooming ability to turn trends on/off, which will cause auto-zoom to update ability to hover over trends to inspect values currently up to six trends can be plotted on a page in total(this can be increased if there is interest) The plotting leverages the JavaScript framework plot.ly . Some JavaScript extensions have been made to this toolbox to allow time-series to seamlessly be exported from your .NET code to the browser. Consider the unit-test PlotUnitTests.SubplotPositionWorksOk() : The code below is used to generate four \"vectors\", arrays of doubles, with a step change in each. public void SubplotPositionWorksOk() { double[] input2 = Vec<double>.Concat(Vec<double>.Fill(0, 20), Vec<double>.Fill(2, 20)); double[] input1 = Vec<double>.Concat(Vec<double>.Fill(0, 10), Vec<double>.Fill(1, 30)); double[] input3 = Vec<double>.Concat(Vec<double>.Fill(0, 30), Vec<double>.Fill(1, 10)); double[] input4 = Vec<double>.Concat(Vec<double>.Fill(0, 35), Vec<double>.Fill(1, 5)); string plotURL = Plot.FromList(new List<double[]>{ input1,input2,input3,input4}, new List<string>{ \"y1=input1\",\"y2=input2\",\"y3=input3\",\"y4=input4\"},1, \"unit test\",new DateTime(2020,1,1, 0,0,0), \"Test_SubplotPositionWorksOk\"); } Note Note how the Vec.Fill() an Vec.Concat() of TimeSeriesAnalysis package is used in this example to create two vectors of a given length and value and concatenate them in a single line of code. The above code generates the following interactive plot in a Chrome-window(this window pops up automatically): This plot has two subplots (one top, one bottom). Each subplot has both a left and a right axis: the top subplot has axes y1 and y2 and the bottom subplot has axes y3 and y4 . By using the top left menu, it is possible to zoom and drag the plots, and the two subplots are linked , meaning when you zoom in one of them, the x-axes of the other plot will zoom as well. Moving the cursor over each plot allows the values to be browsed by an interactive scooter . By clicking on the variable names in the legend on the top left, it is possible to disable plotting selected variables. Note Multiple plots will cause Chrome to display them in multiple tabs. A large number of figures can be generated and sorted in this way."
  },
  "articles/intro.html": {
    "href": "articles/intro.html",
    "title": "Introduction | TimeSeriesAnalysis reference documentation",
    "keywords": "Introduction In this folder you will find detailed worked-though articles including code samples."
  },
  "articles/license.html": {
    "href": "articles/license.html",
    "title": "| TimeSeriesAnalysis reference documentation",
    "keywords": "MIT License Copyright (c) 2021 Equinor Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE."
  },
  "articles/matlab.html": {
    "href": "articles/matlab.html",
    "title": "Loading this library from MatLab | TimeSeriesAnalysis reference documentation",
    "keywords": "Loading this library from MatLab MatLab supports importing .NET assemblies(*.dlls) through the built-in NET.addAssembly() command. Note Once an assembly is loaded in MatLab , it cannot be unloaded except by restarting the program. Note Not all .NET features are supported in MatLab a list of limitiations is given in https://se.mathworks.com/help/matlab/matlab_external/limitations-to-net-support.html Step-by-step: Take a complete build of TimeSeriesAnalyis.dll and accompanying assemblies such as Accord.NET *.dlls and copy into your MatLab working directory such as C:\\Appl\\OneDrive\\Documents\\MATLAB (either build yourself or copy pre-built zip-file from https://github.com/equinor/TimeSeriesAnalysis/releases/ and unzip.) load the assembly with NET.addAssembly() : import the methods of the .NET assembly using the MatLab command import you can now directly call methods in the \"TimeSeriesAnalysis\" namespace (consult the API reference) A simple \"hello-world\" example: assembly = NET.addAssembly('C:\\Appl\\OneDrive\\Documents\\MATLAB\\TimeSeriesAnalysis.dll') import TimeSeriesAnalysis.* results = Vec.Add([1 2],[3 4]) will give as a result a Double[] where >> result(1) ans = 4 >> result(2) ans = 6 Calling >> assembly.Classes reveals the classes that Matlab has loaded: ans = 301 cell array {'TimeSeriesAnalysis.RegressionResults' } {'TimeSeriesAnalysis.Array2D' } {'TimeSeriesAnalysis.Array2DExtensionMethods' } {'TimeSeriesAnalysis.Matrix' } {'TimeSeriesAnalysis.Vec' } {'TimeSeriesAnalysis.VecExtensionMethods' } {'TimeSeriesAnalysis.Utility.CSV' } {'TimeSeriesAnalysis.Utility.StringToFileWriter' } {'TimeSeriesAnalysis.Utility.TimeSeriesCreator' } {'TimeSeriesAnalysis.Utility.UnixTime' } {'TimeSeriesAnalysis.Utility.Plot' } {'TimeSeriesAnalysis.Utility.Plot4Test' } {'TimeSeriesAnalysis.Utility.ParserFeedback' } {'TimeSeriesAnalysis.Utility.SignificantDigits' } {'TimeSeriesAnalysis.Dynamic.DefaultProcessModel' } {'TimeSeriesAnalysis.Dynamic.DefaultProcessModelIdentifier'} {'TimeSeriesAnalysis.Dynamic.DefaultProcessModelParameters'} {'TimeSeriesAnalysis.Dynamic.BandPass' } {'TimeSeriesAnalysis.Dynamic.HighPass' } {'TimeSeriesAnalysis.Dynamic.LowPass' } {'TimeSeriesAnalysis.Dynamic.PIDModel' } {'TimeSeriesAnalysis.Dynamic.PIDModelParameters' } {'TimeSeriesAnalysis.Dynamic.PIDAntiSurgeParams' } {'TimeSeriesAnalysis.Dynamic.PIDcontroller' } {'TimeSeriesAnalysis.Dynamic.PIDgainScheduling' } {'TimeSeriesAnalysis.Dynamic.PIDscaling' } {'TimeSeriesAnalysis.Dynamic.PIDtuning' } {'TimeSeriesAnalysis.Dynamic.SubProcessDataSet' } {'TimeSeriesAnalysis.Dynamic.TimeDelay' } {'TimeSeriesAnalysis.Dynamic.MovingAvg' } It is possible to load classes form namesapces like TimeSeriesAnalysis.Utility and TimeSeriesAnalysis.Dynamic as well, for instance: >> import TimeSeriesAnalysis.* >> import TimeSeriesAnalysis.Utility.* >> TimeSeriesCreator.Step(25,50,0,1) returns a Double[] of length 50 ."
  },
  "articles/multiprocesssim.html": {
    "href": "articles/multiprocesssim.html",
    "title": "ProcessSimulator | TimeSeriesAnalysis reference documentation",
    "keywords": "ProcessSimulator Simulating multiple processes together is orchestrated by the class ProcessSimulator ."
  },
  "articles/nuget.html": {
    "href": "articles/nuget.html",
    "title": "Nuget package upload how-to | TimeSeriesAnalysis reference documentation",
    "keywords": "Nuget package upload how-to This is .NET framework 4.6.1 class library published to github packages, by means of the following tutorial: https://github.community/t/publish-net-framework-nuget-package/3077/2 and here: https://docs.microsoft.com/en-us/nuget/create-packages/creating-a-package-msbuild Note that the steps here are somewhat different to most online tutorials which target .NET Core and use the \"dotnet\" CLI instead of \"nuget\" CLI. For future reference, this is the steps followed: make sure the classes you want to give access to are public. the description that will be shown in nuget when downloading is pulled from in the .csproj file beneath . Consider adding it. Also add the the url to the repository and some other info such as shown below: <RepositoryUrl>https://github.com/equinor/TimeSeriesAnalysis</RepositoryUrl> <RepositoryType>git</RepositoryType> <GeneratePackageOnBuild>true</GeneratePackageOnBuild> <PackageOutputPath>bin\\debug\\</PackageOutputPath> <Version>1.0.0</Version> <Authors>Steinar Elgster</Authors> <description>todo</description> recommend adding in information to the AssemblyInfo.cs before starting. a personal access token xxxxxxx needs to be generated for your user in github,and needs access to \"read:packages\", \"write:packages\" and \"repo\".organization access (authorize with SSO ) and then press \"authorize\" create a nuget.config file that defines \"github\" as a nuget destination: <configuration> <packageSources> <clear /> <add key=\"github\" value=\"https://nuget.pkg.github.com/equinor/index.json\" /> <add key=\"nuget\" value=\"https://api.nuget.org/v3/index.json\" /> </packageSources> <packageSourceCredentials> <github> <add key=\"Username\" value=\"yourgithubuser\" /> <add key=\"ClearTextPassword\" value=xxxxxxx\" /> </github> </packageSourceCredentials> </configuration> pacakges.nuget needs to be moved into project file *.csproj as items instead NuGet.Build.Tasks.Pack need to be added as a pacakage to project need to download nuget.exe and use it to push generated .nupkg file then to publish put the following two commands in a publish.bat file: nuget setapikey xxxxxxxx -source \"github\" nuget push bin\\Debug\\*.nupkg -source \"github\" -SkipDuplicate pause check that the script concludes with \"Your package was pushed\" and no error messages in yellow or red. notice that you need to iterate the version number in your .csproj file every time you push a new version of the package. Warning Make sure that you do not check-in the nuget.config file you create, as it contains a secret token. Add nuget.config to your git ignore file. Nuget package download how-to To use this nuget pacakge, you need to incldue the nuget.config file above in the solution that intends to pull down the package. You can then select github as the package source in Visual Studio \"Manage Nuget packages for Solution\"."
  },
  "articles/nuget_setup.html": {
    "href": "articles/nuget_setup.html",
    "title": "Setting up NuGet | TimeSeriesAnalysis reference documentation",
    "keywords": "Setting up NuGet TimeSeriesAnalysis uses NuGet to retrieve pre-compiled open-source packages on which it is based. NuGet can be set up in several different ways. TimeSeriesAnalysis uses the PackageReference type of configuration, in which NuGet configuration is stored in TimeSeriesAnalysis.csprocj . Note NuGet will not create a local packages subfolder upon a NuGet restore .Instead it creates a global package folder on your computer in the folder %userprofile%\\.nuget\\packages . In some cases it is insightful to examine the contents of this folder if you are having any NuGet issues. In Visual Studio , examine the menu TOOLS>NuGet Package Manager>Package Manager Settings . You should have the following selected: Allow NuGet to download missing packages (should be Checked ) Automatically check for missing packages during build in Visual Studio (should be Checked ) Default package management format should be PacakgeReference Note If you are having issues with NuGet, you can try pressing Clear All NuGet Cache(s) in the above dialog box. Solution Explorer>Solution TimeSeries analysis(right click)>Restore NuGet packages should run with zero errors (observe the Output>Package Manger for possible error) messages."
  },
  "articles/other_languages.html": {
    "href": "articles/other_languages.html",
    "title": "Loading this library from MatLab or Python | TimeSeriesAnalysis reference documentation",
    "keywords": "Loading this library from MatLab or Python Python There is a package for Python called Python.Net that allows you to access the methods in this library. MatLab MatLab supports importing .NET assemblies(*.dlls) through the built-in NET.addAssembly() command. Note Once an assembly is loaded in MatLab , it cannot be unloaded except by restarting the program. Note Not all .NET features are supported in MatLab a list of limitiations is given in https://se.mathworks.com/help/matlab/matlab_external/limitations-to-net-support.html Step-by-step: Take a complete build of TimeSeriesAnalyis.dll and accompanying assemblies such as Accord.NET *.dlls and copy into your MatLab working directory such as C:\\Appl\\OneDrive\\Documents\\MATLAB (either build yourself or copy pre-built zip-file from https://github.com/equinor/TimeSeriesAnalysis/releases/ and unzip.) load the assembly with NET.addAssembly() : import the methods of the .NET assembly using the MatLab command import you can now directly call methods in the \"TimeSeriesAnalysis\" namespace (consult the API reference) A simple \"hello-world\" example: assembly = NET.addAssembly('C:\\Appl\\OneDrive\\Documents\\MATLAB\\TimeSeriesAnalysis.dll') import TimeSeriesAnalysis.* results = Vec.Add([1 2],[3 4]) will give as a result a Double[] where >> result(1) ans = 4 >> result(2) ans = 6 Calling >> assembly.Classes reveals the classes that Matlab has loaded: ans = 301 cell array {'TimeSeriesAnalysis.RegressionResults' } {'TimeSeriesAnalysis.Array2D' } {'TimeSeriesAnalysis.Array2DExtensionMethods' } {'TimeSeriesAnalysis.Matrix' } {'TimeSeriesAnalysis.Vec' } {'TimeSeriesAnalysis.VecExtensionMethods' } {'TimeSeriesAnalysis.Utility.CSV' } {'TimeSeriesAnalysis.Utility.StringToFileWriter' } {'TimeSeriesAnalysis.Utility.TimeSeriesCreator' } {'TimeSeriesAnalysis.Utility.UnixTime' } {'TimeSeriesAnalysis.Utility.Plot' } {'TimeSeriesAnalysis.Utility.Plot4Test' } {'TimeSeriesAnalysis.Utility.ParserFeedback' } {'TimeSeriesAnalysis.Utility.SignificantDigits' } {'TimeSeriesAnalysis.Dynamic.DefaultProcessModel' } {'TimeSeriesAnalysis.Dynamic.DefaultProcessModelIdentifier'} {'TimeSeriesAnalysis.Dynamic.DefaultProcessModelParameters'} {'TimeSeriesAnalysis.Dynamic.BandPass' } {'TimeSeriesAnalysis.Dynamic.HighPass' } {'TimeSeriesAnalysis.Dynamic.LowPass' } {'TimeSeriesAnalysis.Dynamic.PIDModel' } {'TimeSeriesAnalysis.Dynamic.PIDModelParameters' } {'TimeSeriesAnalysis.Dynamic.PIDAntiSurgeParams' } {'TimeSeriesAnalysis.Dynamic.PIDcontroller' } {'TimeSeriesAnalysis.Dynamic.PIDgainScheduling' } {'TimeSeriesAnalysis.Dynamic.PIDscaling' } {'TimeSeriesAnalysis.Dynamic.PIDtuning' } {'TimeSeriesAnalysis.Dynamic.SubProcessDataSet' } {'TimeSeriesAnalysis.Dynamic.TimeDelay' } {'TimeSeriesAnalysis.Dynamic.MovingAvg' } It is possible to load classes form namesapces like TimeSeriesAnalysis.Utility and TimeSeriesAnalysis.Dynamic as well, for instance: >> import TimeSeriesAnalysis.* >> import TimeSeriesAnalysis.Utility.* >> TimeSeriesCreator.Step(25,50,0,1) returns a Double[] of length 50 ."
  },
  "articles/pid_cascade.html": {
    "href": "articles/pid_cascade.html",
    "title": "Cascade control | TimeSeriesAnalysis reference documentation",
    "keywords": "Cascade control This example considers a cascade control scheme consisting of a rapid inner loop( process1 and pid ) and a slower outer loop( process2 and pid2 ), both being subjected to simulated disturbances. (In a real-world case, the inner loop of a cascade is often a (rapid) valve flow-rate controller, while the outer loop could for instance be a level that depends on the flow rate.) A sinusoidal disturbance D1 is introduced on process1, wheras a step disturbance is introduced halfway through the simulation in D2 , and the aim is for the cascade controllers to reject both disturbances as well as possible. The code to implement the controllers: var processParameters1 = new DefaultProcessModelParameters { WasAbleToIdentify = true, TimeConstant_s = 2,//rapid ProcessGains = new double[] { 1.1 }, U0 = new double[] { 50 }, TimeDelay_s = 0, Bias = 50 }; var processParameters2 = new DefaultProcessModelParameters { WasAbleToIdentify = true, TimeConstant_s = 30,//slow ProcessGains = new double[] { 1 }, U0 = new double[] { 50 }, TimeDelay_s = 5, Bias = 50 }; var pidParameters1 = new PIDModelParameters() { Kp = 3, Ti_s = 2 //rapid }; var pidParameters2 = new PIDModelParameters() { Kp = 1, Ti_s = 40 //slow }; var process1 = new DefaultProcessModel(processParameters1, timeBase_s, \"Process1\"); var process2 = new DefaultProcessModel(processParameters2, timeBase_s, \"Process2\"); var pid1 = new PIDModel(pidParameters1, timeBase_s, \"PID1\"); var pid2 = new PIDModel(pidParameters2, timeBase_s, \"PID2\"); var sim = new ProcessSimulator(timeBase_s, new List<ISimulatableModel> { process1, process2, pid1, pid2 }); // pid1.SetManualOutput(50); // pid1.SetToManualMode(); // pid2.SetManualOutput(50); // pid2.SetToManualMode(); sim.ConnectModels(process1, process2); sim.ConnectModels(process1, pid1); sim.ConnectModels(pid1, process1); sim.ConnectModels(process2, pid2); sim.ConnectModels(pid2, pid1,(int)PIDModelInputsIdx.Y_setpoint); sim.AddSignal(pid2,SignalType.Setpoint_Yset,TimeSeriesCreator.Constant(50, N)); sim.AddSignal(process1,SignalType.Disturbance_D,TimeSeriesCreator.Sinus(5,20,timeBase_s,N)); sim.AddSignal(process2,SignalType.Disturbance_D,TimeSeriesCreator.Step(300, N, 0, 1)); var isOK = sim.Simulate(out var simResult); Plot.FromList(new List<double[]> { simResult.GetValues(process1.GetID(),SignalType.Output_Y_sim), simResult.GetValues(process2.GetID(),SignalType.Output_Y_sim), simResult.GetValues(pid2.GetID(),SignalType.Setpoint_Yset), simResult.GetValues(pid1.GetID(),SignalType.PID_U), simResult.GetValues(pid2.GetID(),SignalType.PID_U) }, new List<string> { \"y1=y1\", \"y2=y2[right]\",\"y2=y2_set[right]\", \"y3=u1\", \"y4=u2[right]\" }, timeBase_s, \"CascadeEx\"); The resulting results. To observe the open-loop behavior of the system for the same disturbances but with both controllers in manual mode , comment in the code lines: pid1.SetManualOutput(50); pid1.SetToManualMode(); pid2.SetManualOutput(50); pid2.SetToManualMode(); The resulting open-loop simulation results: These simualtions show the benefits of the cascade control over open-loop: transients in y2 of +/-0.5 , are reduced to approximiately +/-0.1 , and the step disturbance in y2 is rejected. Note There are slight \"bumps\" in both the open-loop and closed-loop cases above. This is because the simulations by design start in steady-state, whereas for the rest of the simulation the entire process is in never-ending transient state because of the sinusoidal disturbance on y1 . Thus this bump is unavoidable, therefore in cases such as this, models should only be evaluated after a run-in-time."
  },
  "articles/pid_feedforward.html": {
    "href": "articles/pid_feedforward.html",
    "title": "Feedforward control | TimeSeriesAnalysis reference documentation",
    "keywords": "Feedforward control . Simulating pid-control against an external disturbance without feed-forward The first part of this example shows the performance of the process and PID-controller when a step change occurs in the disturbance signal. Note that while the PID-controller is able to stabilize the process, it does create significant offset in y , it falls to about y=46.5 at its lowest. var processParameters = new DefaultProcessModelParameters { WasAbleToIdentify = true, TimeConstant_s = 30, ProcessGains = new double[] { 1.1 }, U0 = new double[] { 50 }, TimeDelay_s = 0, Bias = 50 }; var disturbanceParameters = new DefaultProcessModelParameters { WasAbleToIdentify = true, TimeConstant_s = 30, ProcessGains = new double[] { 1 }, U0 = new double[] { 0 }, TimeDelay_s = 5, Bias = 0 }; var pidParameters = new PIDModelParameters() { Kp = 0.3, Ti_s = 20 }; var processModel = new DefaultProcessModel(processParameters, timeBase_s, \"Process1\"); var disturbanceModel = new DefaultProcessModel(disturbanceParameters, timeBase_s, \"Disturbance1\"); var pidModel = new PIDModel(pidParameters, timeBase_s, \"PID\"); var simNoFeedF = new ProcessSimulator(timeBase_s, new List<ISimulatableModel> { processModel, disturbanceModel, pidModel }); simNoFeedF.ConnectModels(pidModel, processModel); simNoFeedF.ConnectModels(processModel, pidModel); simNoFeedF.ConnectModelToOutput(disturbanceModel, processModel); simNoFeedF.AddSignal(pidModel, SignalType.Setpoint_Yset, TimeSeriesCreator.Constant(60, 600)); simNoFeedF.AddSignal(disturbanceModel, SignalType.External_U, TimeSeriesCreator.Step(300, 600, 25, 0)); var isOk = simNoFeedF.Simulate(out var dataNoFeedF); Plot.FromList(new List<double[]> {dataNoFeedF.GetValues(processModel.GetID(),SignalType.Output_Y_sim), dataNoFeedF.GetValues(pidModel.GetID(),SignalType.Setpoint_Yset), dataNoFeedF.GetValues(disturbanceModel.GetID(),SignalType.Output_Y_sim), dataNoFeedF.GetValues(pidModel.GetID(),SignalType.PID_U), dataNoFeedF.GetValues(disturbanceModel.GetID(),SignalType.External_U) }, new List<string> { \"y1=y_run1\", \"y1=y_setpoint\", \"y2=y_dist[right]\", \"y3=u_pid\", \"y3=u_dist\" }, timeBase_s, \"FeedForwardEx1\"); Adding feed-forward to the simulation In the second part of this example a feed-forward term is added to the PID-controller. The input to the disturbance process is assumed to be measured and is used as the feed-forward variable. Since this variable moves slightly in advance of the disturbance as seen on y due to a time delay and time constant, a feed-forward from this variable should improve performance. As seen, the offset between y and y_set is less during the same disturbance step as in the previous part of this example, with y falling to just y=50.4 at its lowest, but at the expense of a slight overshoot in y . var processParameters = new DefaultProcessModelParameters { WasAbleToIdentify = true, TimeConstant_s = 30, ProcessGains = new double[] { 1.1 }, U0 = new double[] { 50 }, TimeDelay_s = 0, Bias = 50 }; var disturbanceParameters = new DefaultProcessModelParameters { WasAbleToIdentify = true, TimeConstant_s = 30, ProcessGains = new double[] { 1 }, U0 = new double[] { 0 }, TimeDelay_s = 5, Bias = 0 }; var pidParameters = new PIDModelParameters() { Kp = 0.3, Ti_s = 20, FeedForward = new PIDfeedForward() { isFFActive = true, FF_Gain = -0.7, FFHP_filter_order = 1, FFLP_filter_order = 1, FF_HP_Tc_s = 60, FF_LP_Tc_s = 0//120 } }; var processModel = new DefaultProcessModel(processParameters, timeBase_s, \"Process1\"); var disturbanceModel = new DefaultProcessModel(disturbanceParameters, timeBase_s, \"Disturbance1\"); var pidModel = new PIDModel(pidParameters, timeBase_s, \"PID\"); var simNoFeedF = new ProcessSimulator(timeBase_s, new List<ISimulatableModel> { processModel, disturbanceModel, pidModel }); simNoFeedF.ConnectModels(pidModel, processModel); simNoFeedF.ConnectModels(processModel, pidModel); simNoFeedF.ConnectModelToOutput(disturbanceModel, processModel); simNoFeedF.AddSignal(pidModel, SignalType.Setpoint_Yset, TimeSeriesCreator.Constant(60, 600)); string dSignalID = simNoFeedF.AddSignal(disturbanceModel, SignalType.External_U, TimeSeriesCreator.Step(300, 600, 25, 0)); simNoFeedF.ConnectSignal(dSignalID, pidModel, (int)PIDModelInputsIdx.FeedForward); var isOk = simNoFeedF.Simulate(out var dataNoFeedF); Plot.FromList(new List<double[]> {dataNoFeedF.GetValues(processModel.GetID(),SignalType.Output_Y_sim), dataNoFeedF.GetValues(pidModel.GetID(),SignalType.Setpoint_Yset), dataNoFeedF.GetValues(disturbanceModel.GetID(),SignalType.Output_Y_sim), dataNoFeedF.GetValues(pidModel.GetID(),SignalType.PID_U), dataNoFeedF.GetValues(disturbanceModel.GetID(),SignalType.External_U) }, new List<string> { \"y1=y_run1\", \"y1=y_setpoint\", \"y2=y_dist[right]\", \"y3=u_pid\", \"y3=u_dist\" }, timeBase_s, \"FeedForwardEx2\");"
  },
  "articles/pid_gainscheduling.html": {
    "href": "articles/pid_gainscheduling.html",
    "title": "Gain-scheduling a nonlinear process | TimeSeriesAnalysis reference documentation",
    "keywords": "Gain-scheduling a nonlinear process This example considers a system that is nonlinear, and illustrates how to apply and simulate gain-scheduling for such a system. Note This example considers gain-scheduling only in Kp , but PIDModel also supports gain scheduling in Ti . Simulating step responses of the open-loop system The system considered is given a negative curvature , meaning that the gain will decrease with increasing values of u . Firstly, the system is defined and the two simulation runs are done, one run at a low value of input, where the gain is high , and a second at a high value of the input, where the gain is low . var modelParameters = new DefaultProcessModelParameters { WasAbleToIdentify = true, TimeConstant_s = 0, ProcessGains = new double[] { 1.1 }, Curvatures = new double[] { -0.7 }, U0 = new double[] { 50 }, UNorm = new double[] { 50 }, TimeDelay_s = 0, Bias = 50 }; var processModel = new DefaultProcessModel(modelParameters, timeBase_s, \"Process1\"); var openLoopSim1 = new ProcessSimulator(timeBase_s, new List<ISimulatableModel> { processModel }); openLoopSim1.AddSignal(processModel, SignalType.External_U, TimeSeriesCreator.Step(50, 200, 80, 90)); openLoopSim1.Simulate(out var openLoopData1); var openLoopSim2 = new ProcessSimulator(timeBase_s, new List<ISimulatableModel> { processModel }); openLoopSim2.AddSignal(processModel, SignalType.External_U, TimeSeriesCreator.Step(50, 200, 20, 30)); var isOk1 = openLoopSim2.Simulate(out var openLoopData2); Plot.FromList(new List<double[]> {openLoopData1.GetValues(processModel.GetID(),SignalType.Output_Y_sim), openLoopData2.GetValues(processModel.GetID(),SignalType.Output_Y_sim), openLoopData1.GetValues(processModel.GetID(),SignalType.External_U), openLoopData2.GetValues(processModel.GetID(),SignalType.External_U) }, new List<string> {\"y1=y1(run1)\",\"y1=y2(run2)\",\"y3=u(run1)\",\"y3=u(run2)\"} ,timeBase_s,\"GainSchedulingEx\"); The resulting plot is shown below: Simulating the use of two standard PID-controllers // the system rejecting a disturbance at y=20 with pidModel1 var pidParameters1 = new PIDModelParameters() { Kp = 0.3, Ti_s = 20 }; var pidModel1 = new PIDModel(pidParameters1, timeBase_s, \"PID1\"); var closedLoopSim1 = new ProcessSimulator(timeBase_s, new List<ISimulatableModel> { pidModel1, processModel }); closedLoopSim1.ConnectModels(pidModel1,processModel); closedLoopSim1.ConnectModels(processModel, pidModel1); closedLoopSim1.AddSignal(pidModel1, SignalType.Setpoint_Yset, TimeSeriesCreator.Constant(20,400)); closedLoopSim1.AddSignal(processModel,SignalType.Disturbance_D, TimeSeriesCreator.Step(100,400,0,10)); var isOk =closedLoopSim1.Simulate(out var closedLoopData1); // the system rejecting a disturbance at y=70 with pidModel2 var pidParameters2 = new PIDModelParameters() { Kp = 1,//NB! higher Kp Ti_s = 20 }; var pidModel2 = new PIDModel(pidParameters2, timeBase_s, \"PID2\"); var closedLoopSim2 = new ProcessSimulator(timeBase_s, new List<ISimulatableModel> { pidModel2, processModel }); closedLoopSim2.ConnectModels(pidModel2, processModel); closedLoopSim2.ConnectModels(processModel, pidModel2); closedLoopSim2.AddSignal(pidModel2, SignalType.Setpoint_Yset, TimeSeriesCreator.Constant(70, 400)); closedLoopSim2.AddSignal(processModel, SignalType.Disturbance_D, TimeSeriesCreator.Step(100, 400, 0, 10)); var isOk2 = closedLoopSim2.Simulate(out var closedLoopData2); Plot.FromList(new List<double[]> {closedLoopData1.GetValues(processModel.GetID(),SignalType.Output_Y_sim), closedLoopData1.GetValues(pidModel1.GetID(),SignalType.Setpoint_Yset), closedLoopData1.GetValues(pidModel1.GetID(),SignalType.PID_U), closedLoopData2.GetValues(processModel.GetID(),SignalType.Output_Y_sim), closedLoopData2.GetValues(pidModel2.GetID(),SignalType.Setpoint_Yset), closedLoopData2.GetValues(pidModel2.GetID(),SignalType.PID_U), }, new List<string> { \"y1=y_run1\",\"y1=y_setpoint(run1)\", \"y2=u_run1(right)\",\"y3=y-run2\", \"y3=y_setpoint(run2)\", \"y4=u_run2(right)\" }, timeBase_s, \"GainSchedulingEx_2\"); The resulting plot is shown below: Note In order to get an approximately equally rapid disturbacne rejection at setpoint y=70 as for y=20 , Kp had to be increased from 0.3 to 1 , so by about a factor of three. It would be quite hard to find a single PID-controller tuning that would work equally well across the entire span of possible outputs y . Thus a gain-scheduled controller could be useful here. Combining the two controllers into a single gain-scheduled controller In the final part of this example, a gain-scheduling controller that performs equally well for both cases is created. The code to create the gain-scheduling controller and simulate both runs: // building a gain-scheduling controller that is able to handle both regimes var pidParametersGS = new PIDModelParameters() { Ti_s = 20, GainScheduling = new PIDgainScheduling() { GSActive_b =true,// turn on gain-scheduling GS_x_Min =0, //Gain-scheduling: x minimum x=GsVariable GS_x_1= 20, //Gain-scheduling: x1,x=GsVariable GS_x_2=70, //Gain-scheduling: x2,x=GsVariable GS_x_Max=100, //Gain-scheduling: x maxiumum, x = GsVariable GS_Kp_Min=0.1, //Gain-scheduling: KP @ GsVariable=GS_x_Min GS_Kp_1=0.2, //Gain-scheduling: KP @ GsVariable=GS_x_1 GS_Kp_2=1, //Gain-scheduling: KP @ GsVariable=GS_x_2 GS_Kp_Max=1.2 //Gain-scheduling: KP @ GsVariable=GS_x_Max } }; var pidModelGS = new PIDModel(pidParametersGS, timeBase_s, \"PID_GS\"); var closedLoopSimGS_1 = new ProcessSimulator(timeBase_s, new List<ISimulatableModel> { pidModelGS, processModel }); closedLoopSimGS_1.ConnectModels(pidModelGS, processModel); closedLoopSimGS_1.ConnectModels(processModel, pidModelGS); closedLoopSimGS_1.AddSignal(pidModelGS, SignalType.Setpoint_Yset, TimeSeriesCreator.Constant(20, 400)); closedLoopSimGS_1.AddSignal(processModel, SignalType.Disturbance_D, TimeSeriesCreator.Step(100, 400, 0, 10)); // Gain-scheduling variable: closedLoopSimGS_1.ConnectModels(processModel,pidModelGS,(int)PIDModelInputsIdx.GainScheduling); var isOk3 = closedLoopSimGS_1.Simulate(out var closedLoopDataGS_1); var closedLoopSimGS_2 = new ProcessSimulator(timeBase_s, new List<ISimulatableModel> { pidModelGS, processModel }); closedLoopSimGS_2.ConnectModels(pidModelGS, processModel); closedLoopSimGS_2.ConnectModels(processModel, pidModelGS); closedLoopSimGS_2.AddSignal(pidModelGS, SignalType.Setpoint_Yset, TimeSeriesCreator.Constant(70, 400)); closedLoopSimGS_2.AddSignal(processModel, SignalType.Disturbance_D, TimeSeriesCreator.Step(100, 400, 0, 10)); // Gain-scheduling variable: closedLoopSimGS_2.ConnectModels(processModel, pidModelGS, (int)PIDModelInputsIdx.GainScheduling); var isOk4 = closedLoopSimGS_2.Simulate(out var closedLoopDataGS_2); Plot.FromList(new List<double[]> {closedLoopDataGS_1.GetValues(processModel.GetID(),SignalType.Output_Y_sim), closedLoopDataGS_1.GetValues(pidModelGS.GetID(),SignalType.Setpoint_Yset), closedLoopDataGS_1.GetValues(pidModelGS.GetID(),SignalType.PID_U), closedLoopDataGS_2.GetValues(processModel.GetID(),SignalType.Output_Y_sim), closedLoopDataGS_2.GetValues(pidModelGS.GetID(),SignalType.Setpoint_Yset), closedLoopDataGS_2.GetValues(pidModelGS.GetID(),SignalType.PID_U) }, new List<string> { \"y1=y_run1\",\"y1=y_setpoint(run1)\", \"y2=u_run1(right)\",\"y3=y-run2\", \"y3=y_setpoint(run2)\", \"y4=u_run2(right)\" }, timeBase_s, \"GainSchedulingEx_3\"); The resulting plot is shown below: Note Notice how in the final plot, the gain-scheduling controller combines the control performance of both controllers in the above parts of the example in a single controller ."
  },
  "articles/pid_select.html": {
    "href": "articles/pid_select.html",
    "title": "min/max select and tracking | TimeSeriesAnalysis reference documentation",
    "keywords": "min/max select and tracking Note Work-in-progress, this article is currently a stub. Tracking signals need to be added, the treatment of tracking signals inside pidcontroller.cs needs to be reviewed, and the how to initialize a system that included select-blocks need to be reviewed. This example considers two controllers who take turns controlling a process through a min-select. PID1 is the controller which is normally active, while PID2 is a more aggressive controller that takes over to more aggressively steer the process. This type of configuration is reminiscent of how inlet separator levels may be controlled: one controller is active during \"typical\" operation with a low gain to let the level fluctuate and exploit the buffer capacity of the tank another controller is need to take over in case that a very large inlet disturbance (a \"slug\" of liquid) to avoid filling the tank completely. The two controllers in this kind of configuration have different setpoints , different integral times and different gains . The output Y could for instance be the level in the tank, and the input U could be the opening of the gas outlet, one strategy to avoid liquid carryover could be to have this valve close more if a slug arrives. . var processParameters = new DefaultProcessModelParameters { WasAbleToIdentify = true, TimeConstant_s = 10, ProcessGains = new double[] { 1 }, U0 = new double[] { 50 }, TimeDelay_s = 5, Bias = 50, Y_min =0, Y_max =100 }; var pidParameters1 = new PIDModelParameters() { Kp = 0.5, //low-gain Ti_s = 250 // slow control (use buffer capacity, use less valve action) }; // // var pidParameters2 = pidParameters1;// var pidParameters2 = new PIDModelParameters() { Kp = 2,//high-gain Ti_s = 15 // faster control(avoid carryover, aggressivley use valve when needed) }; var process = new DefaultProcessModel(processParameters, timeBase_s, \"Process\"); var pid1 = new PIDModel(pidParameters1, timeBase_s, \"PID1\"); var pid2 = new PIDModel(pidParameters2, timeBase_s, \"PID2\"); var minSelect = new Select(SelectType.MIN,\"minSelect\"); var sim = new ProcessSimulator(timeBase_s, new List<ISimulatableModel> { process, pid1, pid2,minSelect }); // tracking and min select-related sim.ConnectModels(process, pid1); sim.ConnectModels(process, pid2); sim.ConnectModels(pid1, minSelect,0); sim.ConnectModels(pid2, minSelect,1); string selectSignalID = sim.ConnectModels(minSelect, process); sim.ConnectSignal(selectSignalID,pid1,(int)PIDModelInputsIdx.Tracking); sim.ConnectSignal(selectSignalID,pid2,(int)PIDModelInputsIdx.Tracking); sim.AddSignal(pid1, SignalType.Setpoint_Yset, TimeSeriesCreator.Constant(50, N)); sim.AddSignal(pid2, SignalType.Setpoint_Yset, TimeSeriesCreator.Constant(70, N)); sim.AddSignal(process, SignalType.Disturbance_D, new Vec().Add(TimeSeriesCreator.Sinus(5,50,timeBase_s,N), TimeSeriesCreator.TwoSteps(N*2/8,N*3/8,N,0,80,0)) ); var isOK = sim.Simulate(out var simResult); Plot.FromList(new List<double[]> { simResult.GetValues(process.GetID(),SignalType.Output_Y_sim), Vec<double>.Fill(85,N), simResult.GetValues(pid1.GetID(),SignalType.Setpoint_Yset), simResult.GetValues(pid2.GetID(),SignalType.Setpoint_Yset), simResult.GetValues(pid1.GetID(),SignalType.PID_U), simResult.GetValues(pid2.GetID(),SignalType.PID_U), simResult.GetValues(minSelect.GetID(),SignalType.SelectorOut), }, new List<string> { \"y1=y1\",\"y1=yHH\", \"y1=y1_set\", \"y1=y2_set\", \"y3=u_pid1\", \"y3=u_pid2\",\"y3=u_select\" }, timeBase_s, \"MinSelectEx\");"
  },
  "articles/pidcontrol.html": {
    "href": "articles/pidcontrol.html",
    "title": "PID control | TimeSeriesAnalysis reference documentation",
    "keywords": "PID control The PID-controller implemented in this library has the following features: anti-windup gain-scheduling input/output scaling feedforward tracking (for min/max select control) input filtering anti-surge \"kick\" control bumpless transfer between manual and automatic modes"
  },
  "articles/plot_setup.html": {
    "href": "articles/plot_setup.html",
    "title": "Setting up plots | TimeSeriesAnalysis reference documentation",
    "keywords": "Setting up plots If you have set up plotting correctly, you should be able to run the \"PlotUnitTests\" test from the Test Explorer in Visual Studio and plots should appear in a new browser window. For plotting to work you need four prerequisites Chrome must installed (by default in C:\\Program Files (x86)\\Google\\Chrome\\Application\\chrome.exe ) you need to be running a local http-server, if it servers a folder [wwwroot] then beneath it there mustbe a [wwwroot]\\plotly that contains the javscript files in the \"www\\plotly\" subfolder in the TimeSeriesAnalysis repository the folder [wwwroot]\\plotly\\Data needs to match the plotDataPath in Plot (by default: C:\\inetpub\\wwwroot\\plotly\\Data ). CSV-data files will be written in here. the front-end JavaScript code needs to find the time-series data in csv-files in its localhost\\plotly\\data folder. (if your http-server is serving another folder than C:\\inetpub\\wwwroot up on localhost , you need to use mklink` to link this folder with the http-server's [root]\\plotly\\data`` folder ) Caution Be aware that you if port 80 and 443 are open on your machine and network, the data in the plotly\\data folder may be shared with the world. It is your responsibility to block these ports if you want to avoid sharing sensitive data. Chrome Currently, plotting requires Chrome,and the project expects Chrome to be installed in the folder C:\\Program Files (x86)\\Google\\Chrome\\Application\\chrome.exe . Running a local HTTP-server In Windows, if you are not already running a http-server, the easiest way to install one may be to install Internet Information Services(IIS) . This is done from Control Panel->Windows Features and selecting Internet information Services in the menu that appears (requires Administrator privileges). If setting up a new server, it is advantageous to map the folder c:\\inetpub\\wwwroot , but it can be any path as long as it contains a \"plotly\" subfolder and that subfolder has a subfolder data where data-files are added. If running IIS, start \"Internet Information Services(IIS) Manager\" from the start menu, then go to \"default website\" press \"basic settings\", make a note of the \"physical path\" and change if needed. The \"physical path\" is where you need to link in the \"plotly\" folder. Serving up the \"plotly\" folder When running a local http-server for development, you will need to add the folder \"plotly\" to it. The preferable way to to this is to add a symbolic link to the TimeSeriesAnalysis folder rather than copying files, to allow for version control. Suppose that your TimeSeriesAnalysis source code is stored in C:\\appl\\source\\TimeSeriesAnalysis , and that you are running an http-sever that is hosting the folder C:\\inetpub\\wwwroot (your localhost ). In Windows : Start a command prompt (cmd.exe) session in Windows with administrator privileges and give the following command: mklink /D c:\\inetpub\\wwwroot\\plotly C:\\appl\\source\\TimeSeriesAnalysis\\www\\plotly Note Plotting using the Plot class will cause browser windows to open on localhost\\plotly\\index.html . This html-file expects to find javscript files CsvToTable.js , plotlyInterface.js and vendor\\plotly.min.js . vendor\\plotly.min.js is obtained from https://plotly.com/javascript/getting-started/ and you can swap the given file for other versions if needed. Changing the paths by editing TimeSeriesAnalysis.dll.config If the paths described above for whatever reason conflict with the setup of your computer, you can change these paths by editing the file TimeSeriesAnalysis.dll.config , which by default has the following content: <?xml version=\"1.0\" encoding=\"utf-8\" ?> <configuration> <appSettings> <add key=\"PlotsAreEnabled\" value= \"true\"/> <add key=\"ChromePath\" value=\"C:\\Program Files (x86)\\Google\\Chrome\\Application\\chrome.exe\"/> <add key=\"PlotlyURL\" value=\"localhost\\plotly\\index.html\"/> <add key=\"PlotDataPath\" value= \"C:\\inetpub\\wwwroot\\plotly\\Data\"/> </appSettings> </configuration> Disabling all plots It is possible to entirely disable all plotting by setting the variable PlotsAreEnabled in the above mention filed to false . This could be useful as a safety-measure if the code was ever to run in a production environment. If necessary localhost\\plotly\\data needs to symbolically linked to c:/inetpub/www/plotly/data folder An alternate way to get around paths that do not suit your runtime environment is to use mklink . If your http-server is mapping \"c:\\inetpub\", then you will not need to do this step. TimeSeriesAnalysis will write data into C:\\inetpub\\plotly\\Data and it will thus be found by the javascript browser-side code and run to display your plots. If you are serving up another folder [PathXYZ] on your computer to localhost than \"c:\\inetpub\" , and do not want or cannot for whatever reason change TimeSeriesAnalysis.dll.config ,an alternate solution is to make a directory link by the following command on the command prompt( cmd.exe ) so: mklink /D C:\\inetpub\\wwwroot\\plotly\\Data C:\\[PathXYZ]\\plotly\\Data"
  },
  "articles/plotly.html": {
    "href": "articles/plotly.html",
    "title": "Plotly.js | TimeSeriesAnalysis reference documentation",
    "keywords": "Plotly.js Plotting of time-series is based on the plotly.js library, which is released under the MIT license and is free to distribute and use commerically. No changes are made or will be made to the original source files, but this class library is distributed with some additional javascript code that handles reading the URL and reading text files from disk containing the time-series information and calling the plotly.js library. Plotting is not a major part of this library's functionality, and the library can be used completely without this plotting. The plotting is also intended mostly as support during testing, for test-driven development, but since the plots are in web-page form they could also be used as a component in web-based dashboards or advisory tools. Note If calling on this library from Matlab or Python, users may choose to use the built-in plotting functionalities of those languages and their tools, the inclusion of plotly.js is to make the choice of plotting tool voluntary and to not require installing additional programs."
  },
  "articles/principles.html": {
    "href": "articles/principles.html",
    "title": "Design choices | TimeSeriesAnalysis reference documentation",
    "keywords": "Design choices Motivation human-configurable and human-readable dynamic process models (all parameters have an intuitive interpretation ) motivated by system identification methodology with intuitive parameters, humans can better understand automatically generated models and it becomes possible for humans to alter such models (semi-autonomous model generation). this excludes neural networks create large-scale dynamic simulator by connecting sub-systems, creating \"digital twin\" models this kind of sub-model is also intuitive to humans and visual start by modeling the process control system (PID-control loops), as this is the handle through which process changes are made. to model the process control system, the library must be able to describe dynamics , feedbacks and different kinds of PID-controllers . try to recreate disturbance signals D of each PID-control loop explicitly , as this is the \"excitation\" that causes variation in an industrial process, yet these signals are not measured or observed directly. How do disturbances move through a process with multiple PID-control stages? Can this be simulated? An explicit estimate of disturbances allows \"playback\" in simulations, which means that the response of the control system with other tunings or configurations can potentially be assessed in simulation. such a representation would negate the need for \"tuning rules\" for PID-controllers, they could instead be tuned by simulation it would become possible to consider the joint effect on re-tuning multiple PID-controllers it would become possible to consider changes in control structure , not just changes in tuning . if it were possible to find models with the above qualities from data it would enable: advanced analytics : autonomous or semi-autonomous analysis of process control which generates recommended actions data-driven digital twins : rapid development of \"fitted\" dynamic models for specific cases-studies or advanced control System identification \"The goal of the identification procedure is, in loose terms, to obtain a good and reliable model with a reasonable amount of work.\" (Lennart Ljung, Theory for the user 2ed, p.399) This quote displays the trade-off of the three different and sometimes opposing goals of identification: a good (accurate, descriptive) model, a reliable model, and a model developed with a reasonable amount of work . This library intends to focus on methods that give deliver a good balance of all three goals . Conversely this means that models that are either not good enough not relivable enough , or cannot be developed with a reasonable amount of work will not be considered. Further the choice of the model should ideally be based on \"posing a criterion for what is a good model and to list the constraints that are imposed on the design by limited time and cost\" (p.406) Thus system identification is a practical field that acknowledges that better models take more time and cost more money, and that these factors need to be taken into consideration. This class library is built on the following principles/assertions: most time-series are not designed for identification, and may have less than ideal amount of excitation, hence handling parameter uncertainty and avoiding over-parametrization are important, almost all systems are actually nonlinear , many but not all can be considered locally linear , real-world data will contain bad data points that need to be filtered out , and you may need to manually remove further non-representative data. Especially for recursive models, a single spurious value can destroy an entire model run, thus the tooling need to support cleaning data to avoid garbage getting into models. expect parameter uncertainty , treat it explicitly. Numerical solvers the models need to simulate without requiring any human intervention , and this has impacts on design choices for how models should be initialized and solved: rather than using numerical solvers on large matrices to find steady-state, a conscious choice is made to rather require each model to include an explicit steady-state calculation. rather than use numerical solvers on large matrices to simulate the model, a conscious choice is made to rather use logic to traverse the connected models as graphs and simulate them one-by-one in an order that is feasible. That means that this library must provide a solver that includes logic to determine a feasible solution order. Code design use dependency injection , generics and interfaces to make the process model easily replaceable - if you provide a new process model that implements the correct interfaces, it should immediately be compatible with re-usable functionality such as PID-control or simulation. do not use inheritance - except for abstract base classes - deep inheritance is hard to understand for others."
  },
  "articles/processsimulator.html": {
    "href": "articles/processsimulator.html",
    "title": "ProcessSimulator | TimeSeriesAnalysis reference documentation",
    "keywords": "ProcessSimulator Simulating multiple processes together is orchestrated by the class ProcessSimulator . External interface The intention is that the ProcessSimualtor class should be able to simulate any well-formulated combination of models that implement the ISimulateableModel (such as PIDModel and DefaultProcessModel .) Connections can be done using ConnectSignal connects a signal to a model ConnectModels : connects an output of one model to an input of another model ConnectModelToOutput : connects an output of model model to the output (additive) of another model External signals are defined using AddSignal : defines a new external signal that is to be included in the simulation Once all connections and signals are defined, the model combination is then simulated by ProcessSimulator.Simulate() . The entire simulated dataset is presented after simulation as an object of the TimeSeriesDataSet class. Internal workings Internally each signal in the returned TimeSeriesDataSet is named by a naming convention that is handled by SignalNamer , which combines information about modelID and signal type to create a unique ID for each signal in the simulation. Determining calculation order, parsing connections By default, ProcessSimulator traverses the combination of models and signals to create a feasible run-order in which to run the model, orchestrated by ConnectionParser.DetermineCalculationOrderOfModels . Models are then run in that given order for each iteration in ProcessSimulator.Simulate() . This means that process simulation does not rely on simultaneously solving large sets of dynamic equations, which an approach that may be easier to comprehend and debug, but it is reliant on the quite complex logic required to determine the calculation order. Initialization of the dynamic model The model can be started without supplying a initial state. In that case the model attempts to start in the steady state that results from the first value (at t=t0 ) in each supplied ProcessSimulator.AddSignal() . Determining the initial state is handled by the private method ProcessSimulator.InitToSteadyState() , which is handled by parsing the model set and connections by logic. ModelBaseClass: Two types of inputs All models should inherit from ModelBaseClass . Each model has a number of inputs that travel through the model, each with an id these are referred to as model input IDs . In addition, models support adding signals directly to the output. This is a feature intended for modeling disturbances. The IDs of such signals are referred to as additive input IDs ."
  },
  "articles/python.html": {
    "href": "articles/python.html",
    "title": "Loading this library from Python | TimeSeriesAnalysis reference documentation",
    "keywords": "Loading this library from Python Loading and using the TimeSeriesAnalysis .NET class library in Python is possible by utilizing the Python.NET package. pythonnet enables calling .NET code in Python, and allows Python code to interact with the .NET Common Language Runtime (CLR). Note The current version of Python.NET is supported for Python 2.7 and for versions <= 3.8. Python setup In order to set up a working configuration in Windows, follow the steps below: Install a compatible version of Python (>= 3.5, <= 3.8). In your project directory (e.g. \"C:\\Appl\\myProject\"), create a new virtual environment and specify the desired Python version (e.g. 3.8): # In project directory \"C:\\Appl\\myProject\" > python3.8 -m venv venv Activate the virtual environment: > venv\\Scripts\\activate Install the Python.NET package: > pip install pythonnet Download a complete build of the TimeSeriesAnalysis assembly and accompanying dependecies from the list of online releases , and unzip the assembly in a designated folder you have created in your project directory (e.g. \"C:\\Appl\\myProject\\TSABuild\"). Note Alternatively, you can build and assemble the Dynamic-link libraries yourself, and copy the *.ddl-files into the folder in your project directory. If the Dynamic-link libraries are downloaded from the Internet on a Windows computer, unblock the TimeSeriesAnalysis assembly: Locate the file TimeSeriesAnalysis.dll in your project directory (e.g. \"C:\\Appl\\myProject\\TSABuild\"). Right-click on the file and select Properties from the menu. Click \"Unblock\" under the General tab. Click Apply, and then OK. To ensure the assembly can be implicitly imported, the directory containing the TimeSeriesAnalysis assembly must be added to your Python system path. In your desired Python file within your project, append the path of the folder containing the *.dll-files (e.g. \"C:\\Appl\\myProject\\TSABuild\") to the PYTHONPATH of your system: import sys assembly_path = r\"C:\\Appl\\myProject\\TSABuild\" sys.path.append(assembly_path) Load the TimeSeriesAnalysis assembly using Python.NET: import clr clr.AddReference(\"TimeSeriesAnalysis\") The non-private classes, structs, interfaces and methods from the TimeSeriesAnalysis .NET class library can now be utilized in Python. Consult the API documentation for reference, or check out some of the Python-specific introductory code examples. Using the modules in Python Classes and methods can be imported from the TimeSeriesAnalysis namespace and subnamespaces and used in Python. Importing the vector class and implementing the vector addition from TimeSeriesAnalysis import Vec results = Vec().Add([1, 2], [3, 4]) will yield an array of the type System.Double[] , which can be accessed using standard Python list indexing syntax: >> results[0] 4.0 >> results[1] 6.0"
  },
  "articles/sysid.html": {
    "href": "articles/sysid.html",
    "title": "| TimeSeriesAnalysis reference documentation",
    "keywords": "The field of system identification uses statistical methods to build mathematical models of dynamical systems from measured data . This library initially focuses on a simple and understandable, yet versatile class of models. For lack of a better name, this model class is referred to as the default process model . For those of you with a background in system identification, you can think of this model class as \"1.order ARX models with time delay and states(for dealing with disturbances).\" The default process model"
  },
  "articles/sysid_defaultmodel.html": {
    "href": "articles/sysid_defaultmodel.html",
    "title": "The default model | TimeSeriesAnalysis reference documentation",
    "keywords": "The default model The \"default\" model in this library is intended to be a model that can describe most average process systems. It aims to avoid over-parametrization , as this is known to cause issues on real-world datasets with limited excitation. As a design choice, the model has built in support for explicitly treating measured/modeled external disturbances , for use in analysis of closed-loop systems. The model is on the form y[k] = x[k] + d[k] where x[k] is the state at time k , d[k] is an external disturbance at time k , furthermore the state x[k] is modeled as x[k] = ax[k-1] + b(u[k-td]-u0) + q (linear in u) where t_d here denotes the time-delay in samples. The parameter a in the above equation should always be between [0;0.9999] . Note Notice that if a=0 the the recursive term is stricken, the disturbance is neglected and time delay is zero, then the model reverts to standard linear static model y[k] = bu[k] . The model is a difference model as x[k] depends on the previous value x[k-1] . is local as the terms b and optionally c apply locally around the operating point u0 . The above shows the model for a single input u , but the model excepts any number of inputs, so in the case of two inputs u1 and u2 for instance x[k] = ax[k-1] + b1(u1[k-t_d]-u_10)+ b2(u2[k-t_d]-u_20) + q (linear in u) Note All inputs in the same model by design share the same dynamic parameters a and t_d . If multiple inputs act on a single output y with different dynamics, then this should be modeled by two or more separate \"default models\" that are then added together - in identification the input of other sub-models can be accounted for by the disturbance-term d Second-order polynominal nolinear gain Optionally the default model can be extended with a square term: x[k] = ax[k-1] + b(u[k-t_d]-u_0) + c/uNorm(u[k-t_d]-u_0)^2 + q (non-linear in u) Internally the paramter c is referred to as the \"Curvature\" of the default model. uNorm is a scaling paramter that is intended to ensure that the paramters b and c are of approximately equal scale during identification. It is reccomended to choose uNorm equal to how much u is expect to vary from u0 . For example, if u0 and u is expected to vary in the range [20,80] , then uNorm should be chosen as 30 . Note The sign of the curvature terms c can be either positive or negative . If c is negative , then this means that the gains is higer below u0 and lower above u0 . If c is positive , then this means that the gains is lower below u0 and higher above u0 . Note If the model has curvature terms c then the process gain depends on both parameters b and c . Process gain and time constant It is related to the time-constant Tc by the equation a = 1/(1+Ts/Tc) where Ts is the sampling time , so that: Tc = Ts/(1/a-1). Note The time-constant is far easier to interpret intuitively, and is much easier to relate to PID-controller terms or filters than a directly. The process gain G1 between an input u1 and the output y is: G1 = b1/(1-a). If the model has two inputs, the second input u2 will have a process gain that depends on b2 G2 = b2/(1-a). If the default model has a second-order term with parameters c1,c2,... ,the the process gains are no longer constant, but will vary dependent on the value of the inputs u . Thus, these models are \"nonlinear in u\" , but the beauty of this model is that these model are still \"linear in parameters [a, b1,..bN, c1,...CN] \" so that the identifier can be based on linear regression. The process gains become functions of u , so for instance for u1 , the process gain will be G1(u1) becomes: G1(u1) = b1/(1-a) + c1/(1-a)2u1. Solver Determining [a,b,c,q,t_d] can be expressed as a linear mixed-integer problem. If the integer term t_d is given, then determining the continuous parameters [a,b,c,q] is a linear optimization problem. The solver DefaultProcessModelIdentifier takes a sequential approach to solving the parameter estimation problem. It solves for the continuous parameters starting at zero time delay and then for increasing time-delays, until the logic determines that attempting to solve for larger time delays is not necessary. The solver then selects the best time delay and the associated continuous parameters. This logic is implemented in the class ProcessTimeDelayIdentifier . Because the optimization problem of finding [a,b,c,q,t_d] requires solving a difference equation and the solver looks at difference between subsequent data points, the formulation favors estimating [a,b,c,] , but at the expense of the value of the bias q . Thus once the parameters [a,b,c,] which express the dynamics are found, the bias q is found in a subsequent calculation DefaultProcessModelIdentifier.ReEstimateBias() to minimize the overall difference between measured and modeled outputs y . The flow of the solver is as below: start at zero time delay t_d , while( TimeDelay object says to continue ), Solve for [a,b,c,] for a given t_d , for a given [a,c,d,t_q] find q , save the model run in TimeDelay class object, and increase time delay. TimeDelay object chooses the best model run out of all the saved runs."
  },
  "articles/unit_tests.html": {
    "href": "articles/unit_tests.html",
    "title": "Setting up and running unit tests | TimeSeriesAnalysis reference documentation",
    "keywords": "Setting up and running unit tests Note Unit tests are an important part of the documenting this class library, as they give examples of how to run the public interface of the library, and document the expected output. Thus, unit tests are worth studying even for users who do not intend to write or modify unit tests. Unit tests are implemented using NUnit 3. In Visual Studio you should be able to browse the unit tests in the window Tests>>Test Explorer . In the Test Explorer window, pressing Run All tests should cause all tests to turn green . In some cases, it may be that the tests appear grayed or or with a blue exclamation point beside them. That indicate an issue with the installation of the Nunit3TestAdapter package through NuGet, which is required for integration NUnit with Visual Studio. Note If you want to submit a pull request for new functionality, writing a new a unit test is required. Note Note that some tests related to plotting are Explicit , and will need be run one-by-one. This has been done this way as this tests require manual inspection, and to avoid drowning the user in plots when re-running unit tests."
  },
  "contributing.html": {
    "href": "contributing.html",
    "title": "Contributing | TimeSeriesAnalysis reference documentation",
    "keywords": "Contributing This project welcomes contributions and suggestions. We believe in collaboration. Collaboration with developers and users, vendors and educational institutions, partners and competitors. Within and outside our industry. Contribution code-of-conduct When contributing to this repository, please first discuss the change you wish to make via issue, or by the GitHub discussions forum, or any other method with the owners of this repository before making a change. Proposed code changes to this project should be submitted for review as pull requests. Pull request Requirements for pull requests: pull request should only address a single feature/issue, all existing tests should pass, any new feature should be supported by at least one new unit test, that both shows that the new feature works and documents how to use the new feature, consider using TestCase to re-run a new unit test for more than one set of input parameters (remember: testing edge-cases and testing the negative.) the submitter must be available for questions of the reviewer, and for complex methods such as those related to filtering, dynamic models or PID-control, unit tests should use the Plot4Test class to plot the time-series that illustrate the test data sets used and the results of any new calculation. It is much easier to understand capability visually both for code review but also for other users. Code to plot the time-series should be available in the code, but should either be disabled with logic by default or commented out, this is to avoid swamping the user with plots if re-running all tests. Avoiding feature-creep: not an encyclopedia of every possible method The more code this repository has, the more time it will take to maintain it and the more things that can go wrong. An important part of Lean is \"maximizing the work not done\" - we want to apply this idea to this repository as well, or \"just because something can be added, does not mean it should \". This repository should not become an encyclopedia of everything time-series related. You may of course pull this library into your own projects and in those you can mix and match and add functionality on top of or beside of to meet your needs. The question is though under what circumstances should something be added back into this repository ? Take for instance file input : Time-series can be stored on file in endless different ways, does that mean that we should add drivers for reading every kind of file format? No To keep things simple and maintainable, adding file drivers is something we would like to keep outside of the repository (even though we have broken our own rule and added support for comma-separated-variable files). The same goes for other areas than file IO. Filters for instance, they are many different ways to make a filter, but this repository is not an encyclopedia of every possible such method. It is hard to give absolute rules, but some guidelines to consider before proposing to add new functionality to this class library: If the functionality is useful on its won, could the functionality instead be a stand-alone repository and NuGet package? If the stand-alone functionality already exists on NuGet in another repository, it is probably better for users to just pull in that package. If the new feature does a task like process modeling, filtering or PID-control in a different way than what the repository already does, there should be a clear benefit of the new approach in terms of performance or features . This repository is aimed toward industrial applications , so esoteric methods(i.e. of specicial, rare or unusual interest) that have academic interest but lack proven practical benefit on real-world data from real-world systems are better left outside this package. If the new feature builds on top of existing functionality it could be interesting to add in, but only if it is generally applicable methodology with practical and industrial use-cases. In general the repository should be kept as \"narrow\" as possible, so we do not want to add in different ways of accomplishing the same things, but methods that build on top of existing methods in the repository to go \"deeper\" are very welcome. What kind of contributions? Data mining/ advanced analytics methods that build on top of existing methods If you would like to contribute on this, this is very welcome. Developing the repository in this direction is on the roadmap toward versions 2.x . Benchmarking and academic comparisons If you would like to compare and benchmark other methods in this project, such as the PID-controller or system identification, that would be much appreciated (even if the other methods you tried appear to be better). For academic use, this project could be used as a reference for academics who are developing their own methods. Bug fixes Any bugs you may find, you are encouraged to report using our issue tracker, and if you can propose a fix, that is much appreciated Expanding on the capability of the PID-controller It will always be possible to add more functionality to the PID-controller, to accommodate different types of advanced control that it may not currently support. Expanding on capability of the array/matrix classes Array/Matrix/Vector classes do not contain every conceivable operation. If you find that the method you need is missing, addition of new methods that perform new operations are appreciated. Be aware that Accord.Math already contains a Matrix namespace with many familiar operators - instead of just duplicating functionality, consider if you can use Accord.Math.Matrix directly. Expanding on the (dynamic) system-identification tool set Do you have a great idea for how better to identify models for dynamic systems? If you would like to contribute your own method into the tool set, that sort of method is much appreciated. This library was initially developed with the DefaultProcessModel in mind, but is should be possible to extend the library with other process model parametrization. To do so, you should replicate how the DefaultProcessModel has been implemented, and your model classes should implement the interfaces specified. In general, this class library is intended to be applied to industrial data where excitation may be less-than-ideal. For that reason the focus should be on parametric identification, not non-parametric models like Finite-Impulse Repsonse(FIR) models."
  },
  "readme.html": {
    "href": "readme.html",
    "title": "TimeSeriesAnalysis | TimeSeriesAnalysis reference documentation",
    "keywords": "TimeSeriesAnalysis A library for efficient test-driven development(TDD) of time-series-based algorithms. Transients/dynamic model identification, dynamic simulation, filtering and advanced industrial PID-control. The aim is to support \"mining\" of industrial time-series data for advanced analytics. Documentation:  TimeSeriesAnalysis documentation   TimeSeriesAnalysis API documentation  Getting started Regardless if you call this library from C#, Python or Matlab, the resulting code is very similar. A good first step is to read through the getting started examples and try copying in that code and getting it to run to get the hang of things Calling this library from Python The library can be conveniently used from Python grab the zipped binaries from a release and unzip set up Python.Net , start calling the API-methods (see help article Getting started:Python .) Calling this library from MatLab The library be conveniently used from Matlab grab the zipped binaries from a release and unzip load the assembly with NET.addAssembly() start calling the API (see article Getting started:Matlab .) Calling this library from your .NET project create a project in Visual Studio, and import the \"TimeSeriesAnalysis\" library from NuGet start calling the API Working with the code of this repository check out this repository, make sure NuGet is setup correctly, and all examples are implemented as unit-tests using NUnit, try running these to Roadmap Currently in versions 1.x , the development focuses on creating small-scale \"building blocks\", modeling components such as individual PID-controllers and small-scale process models. Toward version 2.x the plan is to build on top the established building blocks to expand into more automated modeling and analysis of large-scale systems (connecting sub-systems together), to build \"digital twins\" of larger parts of process plants based on data mining . Models should be human-configurable and human-readable so that \"mined\" models can be adjusted with human insight (\"grey-box\" rather than \"black-box\"). Contributing This project welcomes contributions and suggestions. Please read CONTRIBUTING.md for details on our code of conduct, and the process for submitting pull requests. Discussion forum and contact person The contact person for this repository is Steinar Elgster, please post any question you may have related to TimeSeriesAnalysis in the github discussion pages . License TimeSeriesAnalysis is distributed under the MIT license ."
  }
}